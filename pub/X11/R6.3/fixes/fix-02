                     Release 6.3 Public Patch #02
                      Open Group X Project Team

To apply this patch:

cd to the top of the source tree (to the directory containing the "xc"
and "contrib" subdirectories) and do:

        patch -p -s < ThisFile

Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument 
to patch.

Finally, to rebuild after applying this patch, cd to the "xc" subdirectory
and do:
        make Everything >& every.log

If this is your first time building please see the instructions in the
INSTALL.TXT file.


The following files are new for this patch:

   include/HPkeysym.h  (moved from programs/Xserver/hw/hp/input/X11/HPkeysym.h)
   programs/xkbcomp/compat/keypad
   programs/xkbcomp/geometry/sgi/O2
   programs/xkbcomp/keymap/sgi/hu
   programs/xkbcomp/keymap/sgi/jp
   programs/xkbcomp/symbols/hu
   programs/xkbcomp/symbols/keypad
   programs/xkbcomp/symbols/lock
   programs/xkbcomp/symbols/pc104
   programs/xkbcomp/symbols/sgi		(new directory)
   programs/xkbcomp/symbols/sgi/Imakefile
   programs/xkbcomp/symbols/sgi/jp

Among the defects fixed in this patch:

   Xext: Fix build problems
   Xi: BadClass protocol error causes crash in error print routine
   Xlib: XKB-aware clients can't input Latin1 characters with Mode_switch
   Xlib: Commit event sent from IMS has `state` field uninitialized
   Xlib: Core dump when using STATUS and/or PREEDIT callback style
   Xlib: XKB fixes
   Xlib: address array bounds write errors
   Xlib: TekHVC fails on DEC Alpha
   Xlib: When IMS die the library closes ALL the open IM.
   Xlib: Wrong or gratuitous use of <locale.h>
   Xlib: Xlib: typo in FontScopeRec structure name
   Xlib: bug in BIG-REQUEST extension on Alpha architecture
   Xlib: core dump in XcmsDefaultCCC
   Xlib: ctstowcs parser mishandles charset escape seq in COMPOUND_TEXT
   Xlib: locale database installed during a build has links to the wrong files
   Xlib: calculate length correctly in default per-char text extents
   Xlib: questionable C in utils/makekeys.c
   Xlib: XGetIcValues fail when requested to return local compound values.
   Xlib: xset -q reports incorrect autorepeat keys on Cray
   Xplib: Gratuitous or wrong use of <locale.h>
   Xt: TopLevelShell's XtNiconic resource doesn't work
   Xt: XtRealloc on Malloc0ReturnsNull systems.
   Xt: segmentation violation if DISPLAY not defined
   config: Unmatched quotes in comments gives errors on SGI`s cpp
   config: Better zlib linking
   config: Determine more default defines in imake on linux
   config: operating systems updates
   config: absolute compilers
   config: bug in win32 _mkdir return value checking
   config: imake writes bogus octal constants on HPUX 9.x
   config: problems building other packages with X installed
   config: hp.cf fails, 10.x w/o transition links
   config: sunLib.tmpl SunOS library versions 
   config: typo in Imake.rules 
   config: unnecessary chmod a+x on scripts during `make install`
   config: add rules that use LANG for Motif/CDE
   config: mdepend.cpp (makedepend) doesn't honor -f- like makedepend
   config: fix Real_MessageCatalogRule Motif.rules 
   fontlib: missing info in fontlib doc
   fontlib: Errors from xalloc() aren`t checked.
   fontlib: scaled bitmaps no longer work after `xset fp +`
   fontlib: Incorrect property names produced by scalable fonts
   fontlib: communications with font server fails after 65536 requests.
   fontlib: SEGV in server when font server terminates or dies
   fontlib: Speedo code uses an uninitialized variable.
   fontlib: Type1: memory leak in Type1OpenScalable
   fontlib: Type1: scanfont.c: `lenIV` entry misspelled
   fontlib: When a fontserver goes away it doesn`t properly disconnect.
   fontlib: fontlib: bad #includes in font .h files
   fontlib: off-by-one error in font cache initialization
   fontserver: crash when configured with alternate fontservers.
   fontserver: The README uses (fs &) to start the font server.
   fontserver: The manual page doesn`t list the default tcp port number 
   fontserver: non-blank default character is lost when font padded
   fontserver: NULL pointer deref
   fontserver: fontserver: dumps core after over clientmax
   fontserver: can be killed by interrupting an FS client.
   fontserver: crashes after running for some time. 
   fontserver: cloning self fails
   free86ddx: XC ident line prevents autoloading
   include: move HP`s HPkeysym.h from hpddx to include
   include: new Japanese keyboards have PreviousCandidate and MultipleCandidate
   lbxproxy: change default compression level in lbxproxy
   printddx: PCL_MONO driver problems
   printddx: address array bounds write errors
   printddx: mispelling in feature macro for mono PCL print driver
   server: Array Bounds Write in dixutils.c
   server: last ClientDied is never flushed in record
   server: race condition between dying and new client strands client struct
   server: core dump on opaque moves from bottom of screen
   server: crash in shape
   twm: gram.y input to bison 1.25 fails
   xdm: xdmcp.c manage() leaks memory
   xinput: DeviceButtonMotion events broken in R6
   xinput: potential memory leak in ProcXGetDeviceMotionEvents.
   xkb: /usr/bin/X11/xkbcomp is hardcoded into the sources.
   xkb: Passing either -ar1 or -ar2 to the server breaks auto repeat
   sunddx: trouble with german keyboard w/ XKB
   xkb: zap benign extra `/` in xkbcomp directory
   xmodmap: minor edits to xmodmap man page
   xrx: new Open Group default values for RX
   xrx: sample CGI scripts should set DISPLAY in the environment.
   zlib: better build support and update to latest version.

While this patch was being tested, the following defects were found.
Defect reports have already been filed for these defects:

   o xkbcomp/action.c: bad arguments in call to CreateKeyNames()

   o proxymngr's config file contains an incorrect path for lbxproxy

******************************************************************************

Prereq: R6.3, public-patch-1

*** xc/bug-report@@/PUBLIC-LATEST	Tue Dec 31 08:17:10 1996
--- xc/bug-report	Mon Jun 23 21:53:42 1997
***************
*** 3,9 ****
  
       VERSION:
  
! R6.3, public-patch-1
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
--- 3,9 ----
  
       VERSION:
  
! R6.3, public-patch-2
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
*** xc/config/cf/FreeBSD.cf@@/PUBLIC-LATEST	Sun Sep 29 20:17:36 1996
--- xc/config/cf/FreeBSD.cf	Thu Jun 12 07:43:13 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: FreeBSD.cf /main/13 1996/09/29 20:13:31 kaleb $
  
  #ifndef OSName
  #define OSName			DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: FreeBSD.cf /main/18 1997/06/12 07:40:35 kaleb $
  
  #ifndef OSName
  #define OSName			DefaultOSName
***************
*** 18,24 ****
  XCOMM operating system:  OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
  
  #define HasPutenv		YES
! #define HasBSD44Sockets	 YES
  
  #define CppCmd			/usr/libexec/cpp -traditional
  #define PreProcessCmd		/usr/libexec/cpp -traditional
--- 18,25 ----
  XCOMM operating system:  OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
  
  #define HasPutenv		YES
! #define HasBSD44Sockets		YES
! #define HasZlib			YES
  
  #define CppCmd			/usr/libexec/cpp -traditional
  #define PreProcessCmd		/usr/libexec/cpp -traditional
***************
*** 51,62 ****
  #define DefaultCCOptions	-pipe
  #endif
  
- #ifdef i386Architecture
- #define OptimizedCDebugFlags	-m486 -O2 -fno-strength-reduce
- #else
- #define OptimizedCDebugFlags	-O2
- #endif
- 
  #if OSMajorVersion > 1
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME
  #define XawI18nDefines		-DUSE_XWCHAR_STRING
--- 52,57 ----
***************
*** 63,77 ****
--- 58,124 ----
  #define HasMakefileSafeInclude	YES
  #define IncludeMakefile(file)	@@# dependencies are in .depend
  #define DependFileName		.depend
+ #if OSMinorVersion < 2
  #ifndef ExtraLibraries
  #define ExtraLibraries		-lgnumalloc
  #endif
  #else
+ #ifndef ExtraLoadFlags
+ /* 
+  * This doesn't work the way it does on every other system. On FreeBSD it's
+  * only a "hint, not a demand", whatever that means. Note that this is not 
+  * what it says in the ld and ld.so man pages, which are rather vague on the
+  * matter.
+  *
+  * But we do know that if a) you do what the X Project team does and set your 
+  * ProjectRoot to something like "/X11", and b) you have other X libraries, 
+  * e.g. in /usr/X11R6/lib, and you have added /usr/X11R6/lib to your 
+  * ld.so.cache with ldconfig, then any programs linked with this "hint" will
+  * find that ld.so ignores the "hint" at runtime and loads the libraries in 
+  * the ld.so.cache, * i.e.the wrong ones, instead! Empirically we find that
+  * the run-path is only used as a last resort to find the libraries, after
+  * the LD_LIBRARY_PATH and ld.so.cache.
+  *
+  * N. B. to FreeBSD users who are not familiar with the semantics of the run-
+  * path on other systems. The run-path is akin to a per-program ld.so.cache. 
+  * If a program is linked with a run-path, that run-path should take 
+  * precedence over _everything_ else! In my opinion ldconfig and the 
+  * ld.so.cache should be deprecated immediately now that FreeBSD has run-
+  * paths. Any program that needs libraries that are outside the "well known" 
+  * locations should be linked with a run-path.
+  *
+  * All of which begs the question: If this option doesn't work in any useful
+  * way, why did they (FreeBSD) bother to add it? It would be nice if FreeBSD
+  * would fix ld.so so that run-paths are truly useful.
+  *
+  * Using run-paths is added with the intent that vendors who ship X for 
+  * FreeBSD should use it too. Once everyone uses it then there will be no 
+  * reason for FreeBSD to assume that it knows where X libraries are installed 
+  * and they can remove it from the list of directories they add to ld.so.cache 
+  * in their /etc/rc file.
+  */
+ #define ExtraLoadFlags		-Wl,-R,$(USRLIBDIRPATH)
+ #endif
+ #endif
+ #else
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME -DXNO_SYSCONF
  #define XawI18nDefines		-DUSE_XWCHAR_STRING -DUSE_XMBTOWC
  #ifndef ExtraLibraries
  #define ExtraLibraries		/* -lmalloc */
  #endif
+ #endif
+ 
+ /* The GCC strength-reduce bug is fixed for FreeBSD 2.1.5 and later */
+ #ifndef DefaultGcc2i386Opt
+ #if OSMajorVersion > 2 || (OSMajorVersion == 2 && OSMinorVersion > 1) || (OSMajorVersion == 2 && OSMinorVersion == 1 && OSTeenyVersion >= 5)
+ #define DefaultGcc2i386Opt -O2
+ #endif
+ #endif
+ 
+ #ifdef i386Architecture
+ # define OptimizedCDebugFlags DefaultGcc2i386Opt
+ #else
+ # define OptimizedCDebugFlags -O2
  #endif
  
  #define ServerExtraDefines	GccGasOption XFree86ServerDefines
*** xc/config/cf/Imake.cf@@/PUBLIC-LATEST	Sat Sep 28 16:13:28 1996
--- xc/config/cf/Imake.cf	Wed Jun 25 08:31:34 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imake.cf /main/26 1996/09/28 16:05:09 rws $
  /*
   * To add support for another platform:
   * 
--- 1,4 ----
! XCOMM $TOG: Imake.cf /main/28 1997/06/25 08:31:36 barstow $
  /*
   * To add support for another platform:
   * 
***************
*** 420,425 ****
--- 420,426 ----
  # define FujitsuArchitecture
  # undef __uxp__
  # define UXPArchitecture
+ # define SVR4Architecture
  # ifdef sparc
  #  undef sparc
  #  define SparcArchitecture
*** xc/config/cf/Imake.rules@@/PUBLIC-LATEST	Thu Dec  5 09:50:16 1996
--- xc/config/cf/Imake.rules	Thu Jun  5 17:53:20 1997
***************
*** 1,6 ****
  XCOMM ---------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $XConsortium: Imake.rules /main/217 1996/12/05 09:48:26 kaleb $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
--- 1,6 ----
  XCOMM ---------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $TOG: Imake.rules /main/220 1997/06/05 18:05:16 kaleb $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
***************
*** 135,140 ****
--- 135,143 ----
   * LinkSourceFile		(src,dir)
   * LinkFile			(tofile,fromfile)
   * MakeSubincludesForBuild	(step,dir,srclist)
+  * LangNamedTargetSubdirs	(lang,name,dirs,verb,flags,subname)
+  * LangNamedMakeSubdirs		(lang,name,dirs)
+  * LangMakeSubdirs		(lang,dirs)
   * NamedTargetSubdirs		(name,dirs,verb,flags,subname)
   * NamedMakeSubdirs		(name,dirs)
   * MakeSubdirs			(dirs)
***************
*** 1478,1484 ****
   */
  #ifndef UnsharedLibReferences
  #define UnsharedLibReferences(varname,libname,libsource)		@@\
! ProjectUnsharedLibReferences(var,libname,libsource,$(BUILDLIBDIR))
  #endif
  
  /*
--- 1481,1487 ----
   */
  #ifndef UnsharedLibReferences
  #define UnsharedLibReferences(varname,libname,libsource)		@@\
! ProjectUnsharedLibReferences(varname,libname,libsource,$(BUILDLIBDIR))
  #endif
  
  /*
***************
*** 2067,2072 ****
--- 2070,2109 ----
  
  
  /*
+  * LangNamedTargetSubdirs - recursively make a series of steps
+  */
+ #ifndef LangNamedTargetSubdirs
+ #define LangNamedTargetSubdirs(lang,name,dirs,verb,flags,subname)	@@\
+ name::									@@\
+ 	@MakeFlagsToShellFlags(ik,set +e); \				@@\
+ 	for i in dirs ;\						@@\
+ 	do \								@@\
+ 		echo verb "in $(CURRENT_DIR)/$$i..."; \			@@\
+ 		(cd $$i && LANG=lang $(MAKE) $(MFLAGS) flags subname);\ @@\
+ 	done
+ #endif
+ 
+ 
+ /*
+  * NamedMakeSubdirs - generate rules to do makes in the given subdirectories.
+  * If you want CDEBUGFLAGS passed along to subdirectories, provide a line like
+  * the following in the appropriate Imakefile
+  * 
+  *         #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
+  */
+ #ifndef LangNamedMakeSubdirs
+ #define LangNamedMakeSubdirs(lang,name,dirs) \
+ LangNamedTargetSubdirs(lang,name,dirs,"making" name,PassCDebugFlags,all)
+ #endif /* LangNamedMakeSubdirs */
+ 
+ #ifndef LangMakeSubdirs
+ #define LangMakeSubdirs(lang,dirs)					@@\
+ LangNamedMakeSubdirs(lang,all,dirs)
+ #endif /* LangMakeSubdirs */
+ 
+ 
+ 
+ /*
   * NamedTargetSubdirs - recursively make a series of steps
   */
  #ifndef NamedTargetSubdirs
***************
*** 2332,2338 ****
  #define CppScriptTarget(dst,src,defs,deplist)				@@\
  	CppFileTarget(dst,src,defs,deplist)				@@\
  									@@\
! dst::									@@\
  	chmod a+x $@
  #else
  #define CppScriptTarget(dst,src,defs,deplist)				@@\
--- 2369,2375 ----
  #define CppScriptTarget(dst,src,defs,deplist)				@@\
  	CppFileTarget(dst,src,defs,deplist)				@@\
  									@@\
! dst::	src deplist							@@\
  	chmod a+x $@
  #else
  #define CppScriptTarget(dst,src,defs,deplist)				@@\
*** xc/config/cf/Imake.tmpl@@/PUBLIC-LATEST	Wed Nov 13 14:46:46 1996
--- xc/config/cf/Imake.tmpl	Tue May 20 10:02:31 1997
***************
*** 1,6 ****
  XCOMM ----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $XConsortium: Imake.tmpl /main/243 1996/11/13 14:42:56 lehors $
  XCOMM
  
  /*
--- 1,6 ----
  XCOMM ----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $TOG: Imake.tmpl /main/245 1997/05/20 10:05:47 kaleb $
  XCOMM
  
  /*
***************
*** 262,267 ****
--- 262,270 ----
  #ifndef HasFfs
  #define HasFfs			YES
  #endif
+ #ifndef HasZlib
+ #define HasZlib			NO
+ #endif
  #if HasKrb5
  #ifndef Krb5Includes
  #define Krb5Includes -I/krb5/include
***************
*** 658,663 ****
--- 661,671 ----
  #ifndef Malloc0ReturnsNull
  #define Malloc0ReturnsNull NO
  #endif
+ #if Malloc0ReturnsNull
+ #ifndef Malloc0ReturnsNullDefines
+ #define Malloc0ReturnsNullDefines -DMALLOC_0_RETURNS_NULL
+ #endif
+ #endif
  #ifndef ToolkitStringsABIOptions
  #define ToolkitStringsABIOptions /**/
  #endif
***************
*** 914,920 ****
           CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
  #endif
           COMPRESS = CompressCmd
!              GZIP = GzipCmd
                CPP = CppCmd $(STD_CPP_DEFINES)		/* simple filters */
      PREPROCESSCMD = PreProcessCmd $(STD_CPP_DEFINES)	/* prefered; mdep */
            INSTALL = InstallCmd
--- 922,928 ----
           CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
  #endif
           COMPRESS = CompressCmd
!           GZIPCMD = GzipCmd
                CPP = CppCmd $(STD_CPP_DEFINES)		/* simple filters */
      PREPROCESSCMD = PreProcessCmd $(STD_CPP_DEFINES)	/* prefered; mdep */
            INSTALL = InstallCmd
*** xc/config/cf/Library.tmpl@@/PUBLIC-LATEST	Wed Dec  4 10:10:20 1996
--- xc/config/cf/Library.tmpl	Mon Apr 28 11:38:15 1997
***************
*** 14,20 ****
   * Define LargePICTable YES if large (32-bit) PIC tables are needed.
   */
  
! XCOMM $XConsortium: Library.tmpl /main/42 1996/12/04 10:10:19 swick $
  
  #ifndef LibraryCplusplusOptions
  # if DoSharedLib && defined(SharedLibraryCplusplusOptions)
--- 14,20 ----
   * Define LargePICTable YES if large (32-bit) PIC tables are needed.
   */
  
! XCOMM $TOG: Library.tmpl /main/44 1997/04/28 11:47:53 kaleb $
  
  #ifndef LibraryCplusplusOptions
  # if DoSharedLib && defined(SharedLibraryCplusplusOptions)
***************
*** 148,154 ****
  #  define _SharedObjCplusplusCompile(options) NormalSharedLibObjCplusplusCompile(options)
  #else
  # define _SharedObjCompile(options) NormalLibObjCompile(options)
! # define _SharedObjCpluplusCompile(options) NormalLibObjCplusplusCompile(options)
  #endif
  #endif
  
--- 148,154 ----
  #  define _SharedObjCplusplusCompile(options) NormalSharedLibObjCplusplusCompile(options)
  #else
  # define _SharedObjCompile(options) NormalLibObjCompile(options)
! # define _SharedObjCplusplusCompile(options) NormalLibObjCplusplusCompile(options)
  #endif
  #endif
  
***************
*** 203,215 ****
  
  #ifndef SpecialLibObjectRule
  # define SpecialLibObjectRule(objs,depends,options)			@@\
! _CompileObj(objs: depends,options)					@@\
! _CompileObjCplusplus(objs: depends,options)
  #endif /* SpecialLibObjectRule */
  
  #ifndef SpecialCLibObjectRule
  # define SpecialCLibObjectRule(basename,depends,options)		@@\
! SpecialLibObjectRule(basename.Osuf,basename.SRCsuf depends,options)	@@\
  									@@\
  basename.i: basename.SRCsuf depends					@@\
  	CPPOnlyCompile(basename.SRCsuf,options)				@@\
--- 203,214 ----
  
  #ifndef SpecialLibObjectRule
  # define SpecialLibObjectRule(objs,depends,options)			@@\
! _CompileObj(objs: depends,options)
  #endif /* SpecialLibObjectRule */
  
  #ifndef SpecialCLibObjectRule
  # define SpecialCLibObjectRule(basename,depends,options)		@@\
! _CompileObj(basename.Osuf: basename.SRCsuf depends,options)		@@\
  									@@\
  basename.i: basename.SRCsuf depends					@@\
  	CPPOnlyCompile(basename.SRCsuf,options)				@@\
***************
*** 219,225 ****
  
  #ifndef SpecialCplusplusLibObjectRule
  # define SpecialCplusplusLibObjectRule(basename,depends,options)	@@\
! SpecialLibObjectRule(basename.Osuf,basename.SRCsuf depends,options)	@@\
  									@@\
  CenterLoadTarget(debug_src,basename.SRCsuf,NullParameter,$(ALLDEFINES) options)
  #endif /* SpecialCplusplusLibObjectRule */
--- 218,224 ----
  
  #ifndef SpecialCplusplusLibObjectRule
  # define SpecialCplusplusLibObjectRule(basename,depends,options)	@@\
! _CompileObjCplusplus(basename.Osuf: basename.SRCsuf depends,options)	@@\
  									@@\
  CenterLoadTarget(debug_src,basename.SRCsuf,NullParameter,$(ALLDEFINES) options)
  #endif /* SpecialCplusplusLibObjectRule */
*** xc/config/cf/Motif.rules@@/PUBLIC-LATEST	Wed Dec  4 10:12:51 1996
--- xc/config/cf/Motif.rules	Mon Mar 24 09:12:26 1997
***************
*** 13,19 ****
   * (c) Copyright 1996 FUJITSU LIMITED.
   * (c) Copyright 1996 Hitachi.
   */ 
! XCOMM $XConsortium: Motif.rules /main/2 1996/12/04 10:12:49 swick $
  
  /* Note whether we are the top level project. */
  #ifndef SeenTopLevelProject
--- 13,19 ----
   * (c) Copyright 1996 FUJITSU LIMITED.
   * (c) Copyright 1996 Hitachi.
   */ 
! XCOMM $TOG: Motif.rules /main/3 1997/03/24 09:10:35 mgreess $
  
  /* Note whether we are the top level project. */
  #ifndef SeenTopLevelProject
***************
*** 611,617 ****
  #ifndef Real_MessageCatalogRule
  #define Real_MessageCatalogRule(prefix)					@@\
  prefix.cat Concat(prefix,MsgCatI.h):					@@\
! 	$(RM) Concat(prefix,MsgCatI.h) prefix.cat			@@\
  	$(MKCATTOOL) Concat(prefix,MsgCatI.h) prefix.msg > $(MLOCSRC)/C/msg/prefix.msg	@@\
  	$(GENCAT) prefix.cat $(MLOCSRC)/C/msg/prefix.msg		@@\
  									@@\
--- 611,617 ----
  #ifndef Real_MessageCatalogRule
  #define Real_MessageCatalogRule(prefix)					@@\
  prefix.cat Concat(prefix,MsgCatI.h):					@@\
! 	$(RM) Concat(prefix,MsgCatI.h) prefix.cat $(MLOCSRC)/C/msg/prefix.msg	@@\
  	$(MKCATTOOL) Concat(prefix,MsgCatI.h) prefix.msg > $(MLOCSRC)/C/msg/prefix.msg	@@\
  	$(GENCAT) prefix.cat $(MLOCSRC)/C/msg/prefix.msg		@@\
  									@@\
*** xc/config/cf/README@@/PUBLIC-LATEST	Thu Dec 26 08:35:18 1996
--- xc/config/cf/README	Tue May 20 10:01:53 1997
***************
*** 1,4 ****
! $XConsortium: README /main/64 1996/12/26 08:30:09 kaleb $
  
  The easiest way to write an Imakefile is to find another one that does
  something similar and copy/modify it!
--- 1,4 ----
! $TOG: README /main/66 1997/05/20 10:05:36 kaleb $
  
  The easiest way to write an Imakefile is to find another one that does
  something similar and copy/modify it!
***************
*** 76,81 ****
--- 76,82 ----
  	HasTestCenter		boolean for system has TestCenter
  	HasVFork		boolean for system has vfork()
  	HasVoidSignalReturn	boolean for POSIX signal() procs
+ 	HasZlib			boolean for /usr/lib/libz.a
  	IncRoot			parent of X11 include directory
  	InstBinFlags		install flags for binaries
  	InstDatFlags		install flags for data files
***************
*** 103,108 ****
--- 104,110 ----
  	MacroIncludeFile	<MacroFile>
  	MakeCmd			command to run make
  	Malloc0ReturnsNull	boolean for malloc(0) == NULL
+ 	Malloc0ReturnsNullDefines -D's to build libX11/libXt
  	MathLibrary		library for programs using C math functions
  	MsMacros		macro flag for TroffCmd, normally "-ms"
  	MvCmd			command to rename a file
***************
*** 300,305 ****
--- 302,308 ----
  	XFileSearchPathBase	base file search path
  	XFileSearchPathDefault	default path to search for app defaults files
  	XInputDefines		XINPUT define
+ 	XMalloc0ReturnsNullDefines -D's specifically for libX11
  	XawClientDepLibs	DEPLIBS for clients that use Xaw
  	XawClientLibs		LOCAL_LIBRARIES for clients that use Xaw
  	XdmConfigurationSubdirectory	name of default xdm configuration
***************
*** 311,316 ****
--- 314,320 ----
  	XmanLocalSearchPath	non-standard path for man pages
  	XtErrorPrefix		leading text in XtError() msg; eg. 'X Toolkit '
  	XtWarningPrefix		leading text in XtWarning()msg, same as above
+ 	XtMalloc0ReturnsNullDefines -D's specifically for libXt
  	ZBDFTOSNFFILT		-D to run uncompress and bdftosnf
  
  
***************
*** 350,355 ****
--- 354,360 ----
  	SharedLibraryDef	-D's for defining which kind of shared lib
  	ShLibIncludeFile	location of the <os>Lib.tmpl file
  	SharedLibraryLoadFlags	loader flags when making the library
+ 	UseExportLists		boolean for using an export list
  	PositionIndependentCFlags 		PIC compiler flags for C
  	PositionIndependentCplusplusFlags	PIC compiler flags for C++
  
*** xc/config/cf/X11.rules@@/PUBLIC-LATEST	Wed Dec  4 10:13:02 1996
--- xc/config/cf/X11.rules	Wed Apr 30 15:14:01 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: X11.rules /main/2 1996/12/04 10:13:00 swick $
  
  /* Note whether we are the top level project. */
  #ifndef SeenTopLevelProject
--- 1,4 ----
! XCOMM $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
  
  /* Note whether we are the top level project. */
  #ifndef SeenTopLevelProject
***************
*** 69,75 ****
  #elif !UseInstalledX11
  # define TopXInclude	-I$(TOP)/exports/include
  #else
! # define TopXInclude	/**/
  #endif
  #ifdef TopIncludes
  # undef TopIncludes
--- 69,75 ----
  #elif !UseInstalledX11
  # define TopXInclude	-I$(TOP)/exports/include
  #else
! # define TopXInclude	-I$(XPROJECTROOT)/include
  #endif
  #ifdef TopIncludes
  # undef TopIncludes
*** xc/config/cf/X11.tmpl@@/PUBLIC-LATEST	Fri Dec 27 16:21:38 1996
--- xc/config/cf/X11.tmpl	Tue May 20 10:02:44 1997
***************
*** 1,6 ****
  XCOMM ----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $XConsortium: X11.tmpl /main/290 1996/12/27 16:14:21 kaleb $
  
  /***************************************************************************
   *                                                                         *
--- 1,6 ----
  XCOMM ----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $TOG: X11.tmpl /main/292 1997/05/20 10:05:59 kaleb $
  
  /***************************************************************************
   *                                                                         *
***************
*** 209,214 ****
--- 209,222 ----
  #define XawI18nDefines -DUSE_XWCHAR_STRING
  #endif
  #endif
+ #if Malloc0ReturnsNull
+ #ifndef XMalloc0ReturnsNullDefines
+ #define XMalloc0ReturnsNullDefines Malloc0ReturnsNullDefines
+ #endif
+ #ifndef XtMalloc0ReturnsNullDefines
+ #define XtMalloc0ReturnsNullDefines Malloc0ReturnsNullDefines
+ #endif
+ #endif
  #ifndef ExtensionOSDefines
  #define ExtensionOSDefines /**/
  #endif
***************
*** 1274,1280 ****
  #if GzipFontCompression
  #define CompressedFontTarget(basename)					@@\
  FontBaseObj(basename).gz:  FontSrc(basename)				@@\
! 	RunProgram(FONTC,$(FONTCFLAGS) $?) | $(GZIP) > $@
  #else
  #define CompressedFontTarget(basename)					@@\
  FontBaseObj(basename).Z:  FontSrc(basename)				@@\
--- 1282,1288 ----
  #if GzipFontCompression
  #define CompressedFontTarget(basename)					@@\
  FontBaseObj(basename).gz:  FontSrc(basename)				@@\
! 	RunProgram(FONTC,$(FONTCFLAGS) $?) | $(GZIPCMD) > $@
  #else
  #define CompressedFontTarget(basename)					@@\
  FontBaseObj(basename).Z:  FontSrc(basename)				@@\
*** xc/config/cf/fujitsu.cf@@/PUBLIC-LATEST	Wed Dec  4 10:10:28 1996
--- xc/config/cf/fujitsu.cf	Thu Apr 17 14:02:59 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: fujitsu.cf /main/8 1996/12/04 10:10:25 swick $
  
  #ifndef OSName
  # define OSName		DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: fujitsu.cf /main/9 1997/04/17 14:11:44 barstow $
  
  #ifndef OSName
  # define OSName		DefaultOSName
***************
*** 20,25 ****
--- 20,53 ----
  #define StandardCppDefines -D__uxp__ -DSVR4 -DANSICPP
  
  #define CppCmd             /usr/ccs/lib/cpp
+ 
+ #ifndef  ArCmdBase
+ # define ArCmdBase	/usr/ccs/bin/ar
+ #endif
+ #ifndef  AsCmd
+ # define AsCmd		/usr/ccs/bin/as
+ #endif
+ #ifndef  CcCmd
+ # define CcCmd		/usr/ccs/bin/cc
+ #endif
+ #ifndef  CplusplusCmd
+ # define CplusplusCmd	/opt/uxpcplus/bin/CC
+ #endif
+ #ifndef  CplusplusFilt
+ # define CplusplusFilt	/opt/uxpcplus/bin/c++filt
+ #endif
+ #ifndef  CplusplusDependIncludes
+ # define CplusplusDependIncludes	-I/opt/uxpcplus/include/CC
+ #endif
+ #ifndef  LdCmd
+ # define LdCmd		/usr/ccs/bin/ld
+ #endif
+ #ifndef  LexCmd
+ # define LexCmd		/usr/ccs/bin/lex
+ #endif
+ #ifndef  YaccCmd
+ # define YaccCmd	/usr/ccs/bin/yacc
+ #endif
  
  #define BuildLibPathVar	   LD_LIBRARY_PATH
  #define SystemV4	   YES
*** xc/config/cf/hp.cf@@/PUBLIC-LATEST	Thu Dec 26 08:57:57 1996
--- xc/config/cf/hp.cf	Thu Apr 17 14:02:50 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: hp.cf /main/83 1996/12/26 08:52:54 kaleb $
  
  #ifndef OSName
  # define OSName		DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: hp.cf /main/85 1997/04/17 14:11:34 barstow $
  
  #ifndef OSName
  # define OSName		DefaultOSName
***************
*** 32,51 ****
   */
  
  #if HasHPCplusplus
! # ifndef HasCplusplus
  #  define HasCplusplus YES
  # endif
! # ifndef DefaultCplusplusOptions
  #  define DefaultCplusplusOptions	-Aa
  # endif
! # ifndef CplusplusOptions
  #  define CplusplusOptions		-Aa
  # endif
! # ifndef CplusplusDependIncludes 
! #  define CplusplusDependIncludes	-I/usr/include/CC
  # endif
  #endif
  
  #if HasCenterLineCplusplus
  # ifndef HasCplusplus
  #  define HasCplusplus			YES
--- 32,67 ----
   */
  
  #if HasHPCplusplus
! # ifndef  HasCplusplus
  #  define HasCplusplus YES
  # endif
! # ifndef  DefaultCplusplusOptions
  #  define DefaultCplusplusOptions	-Aa
  # endif
! # ifndef  CplusplusOptions
  #  define CplusplusOptions		-Aa
  # endif
! # ifndef  CplusplusCmd
! #  define CplusplusCmd 			/opt/CC/bin/CC
  # endif
+ # ifndef  CplusplusDependIncludes 
+ #  define CplusplusDependIncludes	-I/opt/CC/include/CC
+ # endif
  #endif
  
+ #ifndef  CcCmd
+ # define CcCmd			/opt/ansic/bin/cc
+ #endif
+ #ifndef  YaccCmd
+ # define YaccCmd		/opt/langtools/bin/yacc
+ #endif
+ #ifndef  LexCmd
+ # define LexCmd			/opt/langtools/bin/lex
+ #endif
+ #ifndef  LintCmd
+ # define LintCmd		/opt/ansic/bin/lint
+ #endif
+ 
  #if HasCenterLineCplusplus
  # ifndef HasCplusplus
  #  define HasCplusplus			YES
***************
*** 146,155 ****
  # endif
  #endif
  
! #if OSMajorVersion == 10
  # if ThreadedX
  #  define MTSafeAPIDefines	-DXUSE_MTSAFE_API -DXUSE_NETDB_R_API
  # endif
  #endif
  
  /* CC does not recognize -Ae, and has a different meaning for +e. */
--- 162,172 ----
  # endif
  #endif
  
! #if OSMajorVersion > 9
  # if ThreadedX
  #  define MTSafeAPIDefines	-DXUSE_MTSAFE_API -DXUSE_NETDB_R_API
  # endif
+ # define CppCmd			/opt/langtools/lbin/cpp
  #endif
  
  /* CC does not recognize -Ae, and has a different meaning for +e. */
***************
*** 172,180 ****
--- 189,203 ----
  #define DtSearchDefines		-DI18N_MSG DtSvcDefines
  #define DtWidgetDefines		DtSearchDefines
  #define DtPrintDefines		DtSearchDefines
+ #if OSMajorVersion > 9
  #define DtMailDefines		\
    -DBIG_ENDIAN -DDO_ANONYMOUS_MAP -DNEED_MMAP_WRAPPER -DSENDMAIL_LOCKS \
+   -DMAILGROUP_REQUIRED -DMAIL_SPOOL_PATH=\"/var/mail/%s\"
+ #else
+ #define DtMailDefines		\
+   -DBIG_ENDIAN -DDO_ANONYMOUS_MAP -DNEED_MMAP_WRAPPER -DSENDMAIL_LOCKS \
    -DMAILGROUP_REQUIRED -DMAIL_SPOOL_PATH=\"/usr/mail/%s\"
+ #endif
  
  #define ArchitectureDefines	-DHP_ARCHITECTURE
  
*** xc/config/cf/linux.cf@@/PUBLIC-LATEST	Thu Dec 26 08:57:45 1996
--- xc/config/cf/linux.cf	Mon Jun 16 22:26:27 1997
***************
*** 1,10 ****
! XCOMM platform:  $XConsortium: linux.cf /main/27 1996/12/26 08:52:44 kaleb $
  
  #ifndef OSName
  #define OSName			DefaultOSName
  #endif
  #ifndef OSVendor
! #define OSVendor		Slackware 3.1 (ELF)
  #endif
  #ifndef OSMajorVersion
  #define OSMajorVersion		DefaultOSMajorVersion
--- 1,10 ----
! XCOMM platform:  $TOG: linux.cf /main/36 1997/06/16 22:21:03 kaleb $
  
  #ifndef OSName
  #define OSName			DefaultOSName
  #endif
  #ifndef OSVendor
! #define OSVendor		RedHat 4.2
  #endif
  #ifndef OSMajorVersion
  #define OSMajorVersion		DefaultOSMajorVersion
***************
*** 15,21 ****
--- 15,38 ----
  #ifndef OSTeenyVersion
  #define OSTeenyVersion		DefaultOSTeenyVersion
  #endif
+ 
+ #ifndef LinuxCLibMajorVersion
+ #define LinuxCLibMajorVersion   DefaultLinuxCLibMajorVersion
+ #endif
+ #ifndef LinuxCLibMinorVersion
+ #define LinuxCLibMinorVersion   DefaultLinuxCLibMinorVersion
+ #endif
+ #ifndef LinuxCLibMinorVersion
+ #define LinuxCLibTeenyVersion   DefaultLinuxCLibTeenyVersion
+ #endif
+ 
+ #ifndef LinuxBinUtilsMajorVersion
+ #define LinuxBinUtilsMajorVersion	DefaultLinuxBinUtilsMajorVersion
+ #endif
+ 
  XCOMM operating system:  OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
+ XCOMM libc:  (LinuxCLibMajorVersion./**/LinuxCLibMinorVersion./**/LinuxCLibTeenyVersion)
+ XCOMM binutils:  (LinuxBinUtilsMajorVersion)
  
  #ifndef UseElfFormat
  #if OSMajorVersion > 1 || (OSMajorVersion == 1 && OSMinorVersion > 1)
***************
*** 37,42 ****
--- 54,60 ----
  #define HasPutenv		YES
  #define HasShm			YES
  #define HasSockets		YES
+ #define HasZlib			YES
  
  #define AvoidNullMakeCommand	YES
  #define StripInstalledPrograms	YES
***************
*** 79,85 ****
  #define LexCmd			flex -l
  #define LexLib			-lfl
  #define PreProcessCmd		CcCmd -E
! #define PostIncDir		`CcCmd --print-libgcc-file-name | sed 's/libgcc.a/include/'`
  #define LdCombineFlags		-r
  #define XawI18nDefines		-DUSE_XWCHAR_STRING -DUSE_XMBTOWC
  #define HasWChar32		YES
--- 97,103 ----
  #define LexCmd			flex -l
  #define LexLib			-lfl
  #define PreProcessCmd		CcCmd -E
! #define PostIncDir		DefaultGccIncludeDir
  #define LdCombineFlags		-r
  #define XawI18nDefines		-DUSE_XWCHAR_STRING -DUSE_XMBTOWC
  #define HasWChar32		YES
***************
*** 86,95 ****
  #define StandardCppDefines	-traditional StandardDefines
  #define ExtensionOSDefines	-DXTESTEXT1
  
  #ifdef i386Architecture
! #define OptimizedCDebugFlags	-O2 -m486
! #define StandardDefines		-Dlinux -D__i386__ -D_POSIX_SOURCE \
! 				-D_BSD_SOURCE -D_GNU_SOURCE -DX_LOCALE
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME
  #define ServerExtraDefines	-DGCCUSESGAS XFree86ServerDefines
  #endif /* i386Architecture */
--- 104,126 ----
  #define StandardCppDefines	-traditional StandardDefines
  #define ExtensionOSDefines	-DXTESTEXT1
  
+ #if LinuxCLibMajorVersion < 6
+ #define LinuxSourceDefines	-D_POSIX_SOURCE \
+ 				-D_BSD_SOURCE -D_SVID_SOURCE -DX_LOCALE
+ #else
+ #define LinuxSourceDefines	-D_POSIX_C_SOURCE=199309L \
+ 				-D_POSIX_SOURCE \
+ 				-D_BSD_SOURCE -D_SVID_SOURCE
+ #define HasPosixThreads		YES
+ #define ThreadedX		YES
+ #define HasThreadSafeAPI	YES
+ #define ThreadsLibraries	-lpthread
+ #define SystemMTDefines		-D_REENTRANT
+ #endif
+ 
  #ifdef i386Architecture
! #define OptimizedCDebugFlags	DefaultGcc2i386Opt
! #define LinuxMachineDefines	-D__i386__
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME
  #define ServerExtraDefines	-DGCCUSESGAS XFree86ServerDefines
  #endif /* i386Architecture */
***************
*** 96,106 ****
  
  #ifdef AlphaArchitecture
  #define OptimizedCDebugFlags	-O2
! #define StandardDefines		-Dlinux -D__alpha__ -D_POSIX_SOURCE \
! 				-D_BSD_SOURCE -D_GNU_SOURCE -DX_LOCALE
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME -DPART_NET
  #define ServerExtraDefines	-DGCCUSESGAS XFree86ServerDefines -D_XSERVER64
  #endif /* AlphaArchitecture */
  
  #define ConnectionFlags		-DUNIXCONN -DTCPCONN
  
--- 127,146 ----
  
  #ifdef AlphaArchitecture
  #define OptimizedCDebugFlags	-O2
! #define LinuxMachineDefines	-D__alpha__
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME -DPART_NET
  #define ServerExtraDefines	-DGCCUSESGAS XFree86ServerDefines -D_XSERVER64
  #endif /* AlphaArchitecture */
+ 
+ #ifdef Mc68020Architecture
+ #define OptimizedCDebugFlags	-O2
+ #define LinuxMachineDefines	-D__mc68000__
+ #define StandardCppDefines      -traditional StandardDefines
+ #define ServerOSDefines         XFree86ServerOSDefines -DDDXTIME -DPART_NET
+ #define ServerExtraDefines      -DGCCUSESGAS XFree86ServerDefines
+ #endif /* Mc68020Architecture */
+ 
+ #define StandardDefines		-Dlinux LinuxMachineDefines LinuxSourceDefines
  
  #define ConnectionFlags		-DUNIXCONN -DTCPCONN
  
*** xc/config/cf/mach.cf@@/PUBLIC-LATEST	Thu Oct 31 14:51:46 1996
--- xc/config/cf/mach.cf	Sun Jun  8 19:57:05 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: mach.cf /main/1 1996/10/31 14:47:20 kaleb $
  
  
  
--- 1,4 ----
! XCOMM $TOG: mach.cf /main/2 1997/06/08 20:08:20 kaleb $
  
  
  
*** xc/config/cf/osf1.cf@@/PUBLIC-LATEST	Fri Dec 27 16:18:03 1996
--- xc/config/cf/osf1.cf	Tue May 27 15:48:59 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: osf1.cf /main/73 1996/12/27 16:10:46 kaleb $
  /* only tested with Digital OSF/1 */
  
  #ifndef OSName
--- 1,4 ----
! XCOMM platform:  $TOG: osf1.cf /main/74 1997/05/27 15:51:24 kaleb $
  /* only tested with Digital OSF/1 */
  
  #ifndef OSName
***************
*** 154,163 ****
  #endif
  #ifndef BuildServer
  #define BuildServer		NO
  
  /* For DtHelp's TIFF processing routines. */
  #define LSBBitOrder		YES
- #endif
  
  #define MotifDefines		-DNO_REGCOMP -DNO_REGEX -DSTRINGS_ALIGNED
  #define DtSvcDefines		-DXK_MISCELLANY -DMULTIBYTE -DMESSAGE_CAT
--- 154,163 ----
  #endif
  #ifndef BuildServer
  #define BuildServer		NO
+ #endif
  
  /* For DtHelp's TIFF processing routines. */
  #define LSBBitOrder		YES
  
  #define MotifDefines		-DNO_REGCOMP -DNO_REGEX -DSTRINGS_ALIGNED
  #define DtSvcDefines		-DXK_MISCELLANY -DMULTIBYTE -DMESSAGE_CAT
*** xc/config/cf/sgi.cf@@/PUBLIC-LATEST	Tue Dec  3 15:54:15 1996
--- xc/config/cf/sgi.cf	Wed Jun 18 18:07:53 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: sgi.cf /main/42 1996/12/03 15:54:15 swick $
  
  #ifndef OSName
  # define OSName		DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: sgi.cf /main/45 1997/06/18 18:01:03 kaleb $
  
  #ifndef OSName
  # define OSName		DefaultOSName
***************
*** 122,129 ****
  #   define sgiCCOptions -xansi
  #  endif
  #  if OSMinorVersion > 1
! /* if you haven't installed patches 1361, 1367, and 1429 on IRIX 6.2  then
!  * you must #define HasPosixThreads NO in your site.def or host.def file
   */
  #   ifndef HasPosixThreads
  #    define HasPosixThreads	YES
--- 122,129 ----
  #   define sgiCCOptions -xansi
  #  endif
  #  if OSMinorVersion > 1
! /* if you haven't installed patch 1361, 1403, or 1645 on IRIX 6.2 then you
!  * must add "#define HasPosixThreads NO" in your site.def or host.def file
   */
  #   ifndef HasPosixThreads
  #    define HasPosixThreads	YES
***************
*** 130,135 ****
--- 130,145 ----
  #   endif
  #   define ThreadedX HasPosixThreads
  #   define ThreadsLibraries -lpthread
+ /* 
+  * Add "#define HasSgiThreadsPatch1403 NO" to your site.def or host.def if 
+  * that's which patch you have.
+  */
+ #   ifndef HasSgiThreadsPatch1403
+ #    define HasSgiThreadsPatch1403 YES
+ #   endif
+ #   if (HasSgiThreadsPatch1403) 
+ #    define SystemMTDefines -D_POSIX_THREAD_SAFE_FUNCTIONS
+ #   endif
  #  endif
  # endif
  /* SGI's -lsocket -lnsl is broken, at least in 5.2, so override here */
***************
*** 211,226 ****
  
  #define MotifDefines		-DSYS_DIR -DPORT_NOVFORK -DNO_REGCOMP
  
- /* since we're using cc -E as cpp we need to make the input file named as
-  * a C file */
  #ifndef CppFileTarget
  #define CppFileTarget(dst,src,defs,deplist)				@@\
  dst::  src deplist							@@\
  	RemoveFile($@)							@@\
- 	$(CP) src Concat3(_$$$$_,src,.c); \
  	ClearmakeOSName \
! 	$(CPP) CppNoLineInfoOption defs Concat3(_$$$$_,src,.c) | \
! 	CppSedMagic >$@; $(RM) Concat3(_$$$$_,src,.c)			@@\
  									@@\
  clean::									@@\
  	RemoveFiles(dst)
--- 221,232 ----
  
  #define MotifDefines		-DSYS_DIR -DPORT_NOVFORK -DNO_REGCOMP
  
  #ifndef CppFileTarget
  #define CppFileTarget(dst,src,defs,deplist)				@@\
  dst::  src deplist							@@\
  	RemoveFile($@)							@@\
  	ClearmakeOSName \
! 	$(CPP) CppNoLineInfoOption defs src | CppSedMagic >$@; 		@@\
  									@@\
  clean::									@@\
  	RemoveFiles(dst)
*** xc/config/cf/sun.cf@@/PUBLIC-LATEST	Thu Dec 26 08:57:17 1996
--- xc/config/cf/sun.cf	Sun Jun  8 19:57:09 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: sun.cf /main/160 1996/12/26 08:52:18 kaleb $
  
  #ifndef OSName
  # define OSName		DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: sun.cf /main/163 1997/06/08 20:08:23 kaleb $
  
  #ifndef OSName
  # define OSName		DefaultOSName
***************
*** 128,133 ****
--- 128,151 ----
  #define XkbServerDefines  -DXKB_ALWAYS_USES_SOFT_REPEAT
  
  #if OSMajorVersion > 4
+ #if HasSunC
+ /* 
+  * Assume /opt/SUNWspro/bin/ contains symlinks to the appropriate tools
+  */
+ #ifndef  CcCmd
+ # define CcCmd		/opt/SUNWspro/bin/cc
+ #endif
+ #ifndef  CplusplusCmd
+ # define CplusplusCmd	/opt/SUNWspro/bin/CC
+ #endif
+ #ifndef  CplusplusFilt
+ # define CplusplusFilt	/opt/SUNWspro/bin/c++filt
+ #endif
+ #ifndef  CplusplusDependIncludes
+ # define CplusplusDependIncludes	-I/opt/SUNWspro/SC3.0/include/CC
+ #endif
+ #endif
+ 
  # if HasSunC && (CCompilerMajorVersion < 3)
  #  define BootstrapCFlags	-DSVR4
  # else
***************
*** 225,231 ****
  # if HasGcc2
  #  ifndef OptimizedCDebugFlags
  #   ifdef i386Architecture
! #    define OptimizedCDebugFlags -m486 -O2 -fno-strength-reduce
  #   else
  #    define OptimizedCDebugFlags -O2
  #   endif
--- 243,249 ----
  # if HasGcc2
  #  ifndef OptimizedCDebugFlags
  #   ifdef i386Architecture
! #    define OptimizedCDebugFlags -m486 DefaultGcc2i386Opt
  #   else
  #    define OptimizedCDebugFlags -O2
  #   endif
*** xc/config/cf/sunLib.tmpl@@/PUBLIC-LATEST	Mon Dec  9 16:39:21 1996
--- xc/config/cf/sunLib.tmpl	Thu Feb 13 13:48:33 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl /main/44 1996/12/09 16:34:30 kaleb $
  
  /*
   * SunOS shared library template
--- 1,4 ----
! XCOMM $TOG: sunLib.tmpl /main/45 1997/02/13 13:52:59 kaleb $
  
  /*
   * SunOS shared library template
***************
*** 10,39 ****
  #  define SharedXmuReqs $(LDPRELIBS) $(XTOOLLIB) $(XLIB)
  # endif
  
! # ifndef SharedX11Rev
! #  define SharedX11Rev 4.20
! # endif
! # ifndef SharedOldXRev
! #  define SharedOldXRev 4.20
! # endif
! # ifndef SharedXtRev
! #  define SharedXtRev 4.20
! # endif
! # ifndef SharedXmuRev
! #  define SharedXmuRev 4.20
! # endif
! # ifndef SharedXextRev
! #  define SharedXextRev 4.30
! # endif
! # ifndef SharedXiRev
! #  define SharedXiRev 4.20
! # endif
! # ifndef SharedXtstRev
! #  define SharedXtstRev 1.10
! # endif
! # ifndef SharedPexRev
! #  define SharedPexRev 1.10
! # endif
  
  #else				/* else it's Solaris */
  
--- 10,42 ----
  #  define SharedXmuReqs $(LDPRELIBS) $(XTOOLLIB) $(XLIB)
  # endif
  
! #ifndef SharedX11Rev
! #define SharedX11Rev 4.30
! #endif
! #ifndef SharedOldXRev
! #define SharedOldXRev 4.20
! #endif
! #ifndef SharedXtRev
! #define SharedXtRev 4.20
! #endif
! #ifndef SharedXawRev
! #define SharedXawRev 6.10
! #endif
! #ifndef SharedXmuRev
! #define SharedXmuRev 4.20
! #endif
! #ifndef SharedXextRev
! #define SharedXextRev 4.40
! #endif
! #ifndef SharedXiRev
! #define SharedXiRev 4.20
! #endif
! #ifndef SharedXtstRev
! #define SharedXtstRev 1.20
! #endif
! #ifndef SharedPexRev
! #define SharedPexRev 1.10
! #endif
  
  #else				/* else it's Solaris */
  
*** xc/config/cf/svr4.cf@@/PUBLIC-LATEST	Sat Sep 28 16:21:59 1996
--- xc/config/cf/svr4.cf	Sun Jun  8 19:57:17 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: svr4.cf /main/16 1996/09/28 16:13:41 rws $
  /*
   * A default OS name
   */
--- 1,4 ----
! XCOMM $TOG: svr4.cf /main/17 1997/06/08 20:08:31 kaleb $
  /*
   * A default OS name
   */
***************
*** 104,110 ****
  #ifndef DefaultCDebugFlags
  #if HasGcc2
  #ifdef i386Architecture
! #define DefaultCDebugFlags -m486 -O2 -fno-strength-reduce
  #else
  #define DefaultCDebugFlags -O2
  #endif
--- 104,110 ----
  #ifndef DefaultCDebugFlags
  #if HasGcc2
  #ifdef i386Architecture
! #define DefaultCDebugFlags -m486 DefaultGcc2i386Opt
  #else
  #define DefaultCDebugFlags -O2
  #endif
*** xc/config/cf/usl.cf@@/PUBLIC-LATEST	Wed Dec  4 10:11:09 1996
--- xc/config/cf/usl.cf	Thu Apr 17 14:02:55 1997
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: usl.cf /main/49 1996/12/04 10:11:06 swick $
  
  #ifndef OSName
  # define OSName		DefaultOSName
--- 1,4 ----
! XCOMM platform:  $TOG: usl.cf /main/50 1997/04/17 14:11:39 barstow $
  
  #ifndef OSName
  # define OSName		DefaultOSName
***************
*** 14,22 ****
  #endif
  XCOMM operating system: OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
  
! #ifndef CcCmd
  # define CcCmd			/usr/ccs/bin/cc
  #endif
  #define BootstrapCFlags		/* none needed */
  #define StandardDefines		-DUSL -DSVR4 -Di386
  #define NeedWidePrototypes	NO	/* experimental */
--- 14,32 ----
  #endif
  XCOMM operating system: OSName (OSMajorVersion./**/OSMinorVersion./**/OSTeenyVersion)
  
! #ifndef  CcCmd
  # define CcCmd			/usr/ccs/bin/cc
  #endif
+ #ifndef  CplusplusCmd
+ # define CplusplusCmd		/usr/ccs/bin/CC
+ #endif
+ #ifndef  CplusplusFilt
+ # define CplusplusFilt		/usr/ccs/bin/c++filt
+ #endif
+ #ifndef  CplusplusDependIncludes
+ # define CplusplusDependIncludes	-I/usr/include/CC
+ #endif
+ 
  #define BootstrapCFlags		/* none needed */
  #define StandardDefines		-DUSL -DSVR4 -Di386
  #define NeedWidePrototypes	NO	/* experimental */
*** xc/config/cf/xfree86.cf@@/PUBLIC-LATEST	Fri Dec  6 11:51:02 1996
--- xc/config/cf/xfree86.cf	Sun Jun  8 19:57:21 1997
***************
*** 6,12 ****
   * Most of these settings can be overridden in a vendor.cf or the
   * BeforeVendor part of the site.def file.
   */
! XCOMM $XConsortium: xfree86.cf /main/34 1996/12/06 11:45:18 rws $
  
  /*
   * The LinkKit needs to inherit some settings (from the xc build that
--- 6,12 ----
   * Most of these settings can be overridden in a vendor.cf or the
   * BeforeVendor part of the site.def file.
   */
! XCOMM $TOG: xfree86.cf /main/35 1997/06/08 20:08:35 kaleb $
  
  /*
   * The LinkKit needs to inherit some settings (from the xc build that
***************
*** 557,562 ****
--- 557,568 ----
  #else
  #define DefaultCCOptions -ansi -pedantic
  #endif
+ #endif
+ #endif
+ 
+ #if HasGcc2 && defined(i386Architecture)
+ #ifndef DefaultGcc2i386Opt
+ #define DefaultGcc2i386Opt -O2 -fno-strength-reduce
  #endif
  #endif
  
*** xc/config/imake/Imakefile@@/PUBLIC-LATEST	Sat Sep 28 16:22:30 1996
--- xc/config/imake/Imakefile	Wed Apr 30 15:29:45 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/8 1996/09/28 16:14:12 rws $
  
  XCOMM Some compilers generate fatal errors if an -L directory does
  XCOMM not exist.  Since BUILDLIBDIR may not exist yet suppress its use.
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/10 1997/04/30 15:39:17 kaleb $
  
  XCOMM Some compilers generate fatal errors if an -L directory does
  XCOMM not exist.  Since BUILDLIBDIR may not exist yet suppress its use.
***************
*** 7,13 ****
  
  DEPLIBS = 
  
! INCLUDES = -I$(TOP)/include -I$(TOP)/imports/x11/include/X11
  CPP_PROGRAM = CppCmd
  CPP_DEFINES = -DCPP_PROGRAM="\"$(CPP_PROGRAM)\""
  DEFINES = $(SIGNAL_DEFINES) $(BOOTSTRAPCFLAGS) $(CPP_DEFINES)
--- 7,13 ----
  
  DEPLIBS = 
  
! INCLUDES = -I$(TOP)/include $(TOP_X_INCLUDES)/X11
  CPP_PROGRAM = CppCmd
  CPP_DEFINES = -DCPP_PROGRAM="\"$(CPP_PROGRAM)\""
  DEFINES = $(SIGNAL_DEFINES) $(BOOTSTRAPCFLAGS) $(CPP_DEFINES)
*** xc/config/imake/Makefile.ini@@/PUBLIC-LATEST	Sat Sep 28 16:22:38 1996
--- xc/config/imake/Makefile.ini	Wed Feb 19 18:00:53 1997
***************
*** 1,4 ****
! # $XConsortium: Makefile.ini /main/24 1996/09/28 16:14:20 rws $
  #
  #   WARNING    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING
  #
--- 1,4 ----
! # $TOG: Makefile.ini /main/25 1997/02/19 18:00:59 mgreess $
  #
  #   WARNING    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING
  #
***************
*** 22,28 ****
  NPROC = 1
  
  imake::
! 	@echo "making imake with BOOTSTRAPCFLAGS=$(BOOTSTRAPCFLAGS)"
  
  imake:: imake.o
  	$(CC) -o imake imake.o
--- 22,28 ----
  NPROC = 1
  
  imake::
! 	@echo "making imake with BOOTSTRAPCFLAGS=$(BOOTSTRAPCFLAGS) in config/imake"
  
  imake:: imake.o
  	$(CC) -o imake imake.o
*** xc/config/imake/imake.c@@/PUBLIC-LATEST	Wed Nov 13 14:47:12 1996
--- xc/config/imake/imake.c	Fri Jun 20 20:25:21 1997
***************
*** 1,4 ****
! /* $XConsortium: imake.c /main/90 1996/11/13 14:43:23 lehors $ */
  
  /***************************************************************************
   *                                                                         *
--- 1,4 ----
! /* $TOG: imake.c /main/97 1997/06/20 20:23:51 kaleb $ */
  
  /***************************************************************************
   *                                                                         *
***************
*** 229,234 ****
--- 229,242 ----
  #  define SYS_NMLN 257
  # endif
  #endif
+ #ifdef linux
+ #include <limits.h>
+ #endif
+ /* 
+  * is strstr() in <strings.h> on X_NOT_STDC_ENV? 
+  * are there any X_NOT_STDC_ENV machines left in the world?
+  */
+ #include <string.h>
  #include "imakemdep.h"
  
  /*
***************
*** 779,786 ****
--- 787,895 ----
    *result = '\0';
    (void) sscanf(buf, fmt + arg + 1, result);
  }
+ 
+ /* Trim leading 0's and periods from version names.  The 0's cause
+    the number to be interpreted as octal numbers.  Some version strings
+    have the potential for different numbers of .'s in them.
+  */
+ 	
+ static char *
+ trim_version(p)
+ 	char *p;
+ {
+ 
+ 	if (p != 0 && *p != '\0')
+ 	{
+ 		while ((*p == '0' || *p == '.') && *(p + 1) != '\0')
+ 			++p;
+ 	}
+ 	return (p);
+ }
  #endif
  
+ #ifdef linux
+ static void get_libc_version(inFile)
+   FILE* inFile;
+ {
+   static char* libcso = "/usr/lib/libc.so";
+   struct stat sb;
+   char buf[PATH_MAX];
+   char* ptr;
+   int libcmajor, libcminor, libcteeny;
+ 
+   if (lstat (libcso, &sb) == 0) {
+     if (S_ISLNK (sb.st_mode)) {
+       if (readlink (libcso, buf, PATH_MAX) >= 0) {
+ 	for (ptr = buf; *ptr && !isdigit (*ptr); ptr++);
+ 	  (void) sscanf (ptr, "%d.%d.%d", &libcmajor, &libcminor, &libcteeny);
+ 	  fprintf(inFile, "#define DefaultLinuxCLibMajorVersion %d\n", libcmajor);    
+ 	  fprintf(inFile, "#define DefaultLinuxCLibMinorVersion %d\n", libcminor);    
+ 	  fprintf(inFile, "#define DefaultLinuxCLibTeenyVersion %d\n", libcteeny);    
+       }
+     }
+   }
+ }
+ 
+ static void get_ld_version(inFile)
+   FILE* inFile;
+ {
+   FILE* ldprog = popen ("ld -v", "r");
+   char c;
+   int ldmajor, ldminor;
+ 
+   if (ldprog) {
+     do {
+       c = fgetc (ldprog);
+     } while (c != EOF && !isdigit (c));
+     ungetc (c, ldprog);
+     (void) fscanf (ldprog, "%d.%d", &ldmajor, &ldminor);
+     fprintf(inFile, "#define DefaultLinuxBinUtilsMajorVersion %d\n", 
+ 	    ldmajor * 10 + ldminor);    
+     pclose (ldprog);
+   }
+ }
+ #endif
+ 
+ #ifndef PATH_MAX
+ #define PATH_MAX 1024
+ #endif
+ 
+ static void get_gcc_incdir(inFile)
+   FILE* inFile;
+ {
+   static char* gcc_path[] = {
+ #ifdef linux
+     "/usr/bin/cc",	/* for Linux PostIncDir */
+ #endif
+     "/usr/local/bin/gcc",
+     "/opt/gnu/bin/gcc"
+   };
+   struct stat sb;
+   int i;
+   FILE* gccproc;
+   char buf[PATH_MAX];
+   char cmd[PATH_MAX];
+   char* ptr;
+ 
+   buf[0] = '\0';
+   for (i = 0; i < sizeof gcc_path / sizeof gcc_path[0]; i++) {
+     if (lstat (gcc_path[i], &sb) == 0) {
+       strcpy (cmd, gcc_path[i]);
+       strcat (cmd, " --print-libgcc-file-name");
+       if ((gccproc = popen (cmd, "r")) != NULL) {
+ 	if (fgets (buf, PATH_MAX, gccproc) != NULL) {
+ 	  ptr = strstr (buf, "libgcc.a");
+ 	  if (ptr) strcpy (ptr, "include");
+ 	}
+ 	(void) pclose (gccproc);
+ 	break;
+       }
+     }
+   }
+   if (buf[0])
+     fprintf (inFile, "#define DefaultGccIncludeDir %s\n", buf);
+ }
+ 
  boolean
  define_os_defaults(inFile)
  	FILE	*inFile;
***************
*** 805,825 ****
  # ifdef DEFAULT_OS_MAJOR_REV
  	parse_utsname(&name, DEFAULT_OS_MAJOR_REV, buf,
  		      "Bad DEFAULT_OS_MAJOR_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSMajorVersion %s\n", *buf ? buf : "0");
  # endif
  
  # ifdef DEFAULT_OS_MINOR_REV
  	parse_utsname(&name, DEFAULT_OS_MINOR_REV, buf,
  		      "Bad DEFAULT_OS_MINOR_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSMinorVersion %s\n", *buf ? buf : "0");
  # endif
  
  # ifdef DEFAULT_OS_TEENY_REV
  	parse_utsname(&name, DEFAULT_OS_TEENY_REV, buf,
  		      "Bad DEFAULT_OS_TEENY_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSTeenyVersion %s\n", *buf ? buf : "0");
  # endif
  #endif
  #endif /* WIN32 */
  	return FALSE;
  }
--- 914,942 ----
  # ifdef DEFAULT_OS_MAJOR_REV
  	parse_utsname(&name, DEFAULT_OS_MAJOR_REV, buf,
  		      "Bad DEFAULT_OS_MAJOR_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSMajorVersion %s\n", 
! 		*buf ? trim_version(buf) : "0");
  # endif
  
  # ifdef DEFAULT_OS_MINOR_REV
  	parse_utsname(&name, DEFAULT_OS_MINOR_REV, buf,
  		      "Bad DEFAULT_OS_MINOR_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSMinorVersion %s\n", 
! 		*buf ? trim_version(buf) : "0");
  # endif
  
  # ifdef DEFAULT_OS_TEENY_REV
  	parse_utsname(&name, DEFAULT_OS_TEENY_REV, buf,
  		      "Bad DEFAULT_OS_TEENY_REV syntax %s");
! 	fprintf(inFile, "#define DefaultOSTeenyVersion %s\n", 
! 		*buf ? trim_version(buf) : "0");
  # endif
  #endif
+ #ifdef linux
+     get_libc_version (inFile);
+     get_ld_version(inFile);
+ #endif
+     get_gcc_incdir(inFile);
  #endif /* WIN32 */
  	return FALSE;
  }
***************
*** 1100,1106 ****
  		initialized = TRUE;
  	    fprintf (tmpfd, "# Makefile generated by imake - do not edit!\n");
  	    fprintf (tmpfd, "# %s\n",
! 		"$XConsortium: imake.c /main/90 1996/11/13 14:43:23 lehors $");
  	}
  
  	for (p1 = pline; p1 < end; p1++) {
--- 1217,1223 ----
  		initialized = TRUE;
  	    fprintf (tmpfd, "# Makefile generated by imake - do not edit!\n");
  	    fprintf (tmpfd, "# %s\n",
! 		"$TOG: imake.c /main/97 1997/06/20 20:23:51 kaleb $");
  	}
  
  	for (p1 = pline; p1 < end; p1++) {
*** xc/config/imake/imakemdep.h@@/PUBLIC-LATEST	Thu Oct 31 14:36:27 1996
--- xc/config/imake/imakemdep.h	Fri Jun  6 09:11:54 1997
***************
*** 1,4 ****
! /* $XConsortium: imakemdep.h /main/100 1996/10/31 14:32:02 kaleb $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $TOG: imakemdep.h /main/101 1997/06/06 09:13:20 bill $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 562,571 ****
  # define DEFAULT_OS_TEENY_REV	"r %*[^.].%*d.%*c%[0-9]"
  # define DEFAULT_OS_NAME	"srvm %[^\n]"
  #elif defined(USL) || defined(__USLC__)
! /* uname -v returns "x.yz", e.g. "2.02". */
  # define DEFAULT_OS_MAJOR_REV	"v %[0-9]"
  # define DEFAULT_OS_MINOR_REV	"v %*d.%1s"
! # define DEFAULT_OS_TEENY_REV	"v %*d.%*c%[0-9]"
  # define DEFAULT_OS_NAME	"srvm %[^\n]"
  #elif defined(__osf__)
  /* uname -r returns "Wx.y", e.g. "V3.2" or "T4.0" */
--- 562,571 ----
  # define DEFAULT_OS_TEENY_REV	"r %*[^.].%*d.%*c%[0-9]"
  # define DEFAULT_OS_NAME	"srvm %[^\n]"
  #elif defined(USL) || defined(__USLC__)
! /* uname -v returns "x.yz" or "x.y.z", e.g. "2.02" or "2.1.2". */
  # define DEFAULT_OS_MAJOR_REV	"v %[0-9]"
  # define DEFAULT_OS_MINOR_REV	"v %*d.%1s"
! # define DEFAULT_OS_TEENY_REV	"v %*d.%*c%[.0-9]"
  # define DEFAULT_OS_NAME	"srvm %[^\n]"
  #elif defined(__osf__)
  /* uname -r returns "Wx.y", e.g. "V3.2" or "T4.0" */
*** xc/config/makedepend/Imakefile@@/PUBLIC-LATEST	Sat Sep 28 16:23:16 1996
--- xc/config/makedepend/Imakefile	Wed Apr 30 15:28:37 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/25 1996/09/28 16:14:57 rws $
  
      SRCS = include.c main.c parse.c pr.c cppsetup.c ifparser.c 
      OBJS = include.o main.o parse.o pr.o cppsetup.o ifparser.o 
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/27 1997/04/30 15:38:09 kaleb $
  
      SRCS = include.c main.c parse.c pr.c cppsetup.c ifparser.c 
      OBJS = include.o main.o parse.o pr.o cppsetup.o ifparser.o 
***************
*** 28,34 ****
  OSUF = .Osuf
  OSUF_DEFINES = -DOBJSUFFIX=\"$(OSUF)\"
  MAIN_DEFINES = $(INC_DEFINES) $(SIGNAL_DEFINES) $(OSUF_DEFINES)
! INCLUDES = -I$(IMAKESRC) -I$(TOP)/include -I$(TOP)/imports/x11/include/X11
  
   DEPLIBS =
  
--- 28,34 ----
  OSUF = .Osuf
  OSUF_DEFINES = -DOBJSUFFIX=\"$(OSUF)\"
  MAIN_DEFINES = $(INC_DEFINES) $(SIGNAL_DEFINES) $(OSUF_DEFINES)
! INCLUDES = -I$(IMAKESRC) -I$(TOP)/include $(TOP_X_INCLUDES)/X11
  
   DEPLIBS =
  
*** xc/config/util/mdepend.cpp@@/PUBLIC-LATEST	Fri Dec  9 22:50:34 1994
--- xc/config/util/mdepend.cpp	Fri Jun 20 21:18:04 1997
***************
*** 1,6 ****
  XCOMM!/bin/sh
  XCOMM
! XCOMM $XConsortium: mdepend.cpp,v 1.12 94/12/09 22:50:34 gildea Exp $
  XCOMM
  XCOMM	Do the equivalent of the 'makedepend' program, but do it right.
  XCOMM
--- 1,6 ----
  XCOMM!/bin/sh
  XCOMM
! XCOMM $TOG: mdepend.cpp /main/13 1997/06/20 21:12:18 kaleb $
  XCOMM
  XCOMM	Do the equivalent of the 'makedepend' program, but do it right.
  XCOMM
***************
*** 81,89 ****
  			    magic_string="$2"
  			    shift
  			    ;;
! 			-f)
! 			    makefile="$2"
! 			    shift
  			    ;;
  			-o)
  			    objsuffix="$2"
--- 81,93 ----
  			    magic_string="$2"
  			    shift
  			    ;;
! 			-f*)
! 			    if [ "$1" = "-f-" ]; then
! 				makefile="-"
! 			    else
! 				makefile="$2"
! 				shift
! 			    fi
  			    ;;
  			-o)
  			    objsuffix="$2"
*** xc/config/util/mkdirhier.c@@/PUBLIC-LATEST	Wed Nov 13 14:47:23 1996
--- xc/config/util/mkdirhier.c	Thu Jun  5 17:57:38 1997
***************
*** 1,4 ****
! /* $XConsortium: mkdirhier.c /main/1 1996/11/13 14:43:34 lehors $ */
  /*
  
  Copyright (C) 1996 X Consortium
--- 1,4 ----
! /* $TOG: mkdirhier.c /main/2 1997/06/05 18:09:26 kaleb $ */
  /*
  
  Copyright (C) 1996 X Consortium
***************
*** 69,75 ****
  	    _mkdir(buf);	/* no error checking to avoid barfing on C: */
  	prev = next + 1;
      }
!     if (!_mkdir(dirname)) {
  	perror("mkdirhier failed");
  	exit(1);
      }
--- 69,75 ----
  	    _mkdir(buf);	/* no error checking to avoid barfing on C: */
  	prev = next + 1;
      }
!     if (_mkdir(dirname) == -1) {
  	perror("mkdirhier failed");
  	exit(1);
      }
*** xc/include/Imakefile@@/PUBLIC-LATEST	Sat Nov 30 10:12:29 1996
--- xc/include/Imakefile	Fri Jun 13 15:37:05 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/92 1996/11/30 10:09:25 lehors $
  #define IHaveSubdirs
  #define PassCDebugFlags /**/
  
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/93 1997/06/13 15:34:58 kaleb $
  #define IHaveSubdirs
  #define PassCDebugFlags /**/
  
***************
*** 9,14 ****
--- 9,15 ----
  #endif
  
  HEADERS = DECkeysym.h \
+ 	HPkeysym.h \
  	Sunkeysym.h \
  	X.h \
  	XWDFile.h \
*** xc/include/extensions/XKBstr.h@@/PUBLIC-LATEST	Fri Mar  1 14:30:55 1996
--- xc/include/extensions/XKBstr.h	Tue Jun 10 07:02:42 1997
***************
*** 1,4 ****
! /* $XConsortium: XKBstr.h /main/15 1996/03/01 14:29:15 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: XKBstr.h /main/16 1997/06/10 06:53:12 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 295,301 ****
--- 295,306 ----
  
  	XkbBehavior		*behaviors;
  	unsigned short		*key_acts;
+ #if defined(__cplusplus) || defined(c_plusplus)
+ 	/* explicit is a C++ reserved word */
+ 	unsigned char		*c_explicit;
+ #else
  	unsigned char		*explicit;
+ #endif
  	unsigned char		 vmods[XkbNumVirtualMods];
  	unsigned short		*vmodmap;
  } XkbServerMapRec, *XkbServerMapPtr;
*** xc/include/fonts/FS.h@@/PUBLIC-LATEST	Sun Apr 17 20:11:05 1994
--- xc/include/fonts/FS.h	Fri Jun 13 13:03:17 1997
***************
*** 1,4 ****
! /* $XConsortium: FS.h,v 1.8 94/04/17 20:11:05 dpw Exp $ */
  
  /*
   * Copyright 1990, 1991 Network Computing Devices;
--- 1,4 ----
! /* $TOG: FS.h /main/9 1997/06/13 13:01:10 barstow $ */
  
  /*
   * Copyright 1990, 1991 Network Computing Devices;
***************
*** 55,61 ****
  #ifndef _FS_H_
  #define	_FS_H_
  
! #include <fsmasks.h>
  
  #define	FS_PROTOCOL		2
  #define	FS_PROTOCOL_MINOR	0
--- 55,61 ----
  #ifndef _FS_H_
  #define	_FS_H_
  
! #include "fsmasks.h"
  
  #define	FS_PROTOCOL		2
  #define	FS_PROTOCOL_MINOR	0
*** xc/include/keysymdef.h@@/PUBLIC-LATEST	Fri Feb  2 14:29:35 1996
--- xc/include/keysymdef.h	Sat Jun 21 10:55:13 1997
***************
*** 1,4 ****
! /* $XConsortium: keysymdef.h /main/24 1996/02/02 14:28:10 kaleb $ */
  
  /***********************************************************
  Copyright (c) 1987, 1994  X Consortium
--- 1,4 ----
! /* $TOG: keysymdef.h /main/25 1997/06/21 10:54:51 kaleb $ */
  
  /***********************************************************
  Copyright (c) 1987, 1994  X Consortium
***************
*** 75,80 ****
--- 75,83 ----
  /* International & multi-key character composition */
  
  #define XK_Multi_key		0xFF20  /* Multi-key character compose */
+ #define XK_SingleCandidate	0xFF3C
+ #define XK_MultipleCandidate	0xFF3D
+ #define XK_PreviousCandidate	0xFF3E
  
  /* Japanese keyboard support */
  
***************
*** 95,100 ****
--- 98,105 ----
  #define XK_Kana_Shift		0xFF2E  /* Kana Shift */
  #define XK_Eisu_Shift		0xFF2F  /* Alphanumeric Shift */
  #define XK_Eisu_toggle		0xFF30  /* Alphanumeric toggle */
+ #define XK_Zen_Koho		0xFF3D	/* Multiple/All Candidate(s) */
+ #define XK_Mae_Koho		0xFF3E	/* Previous Candidate */
  
  /* 0xFF31 thru 0xFF3F are under XK_KOREAN */
  
*** xc/lib/Imakefile@@/PUBLIC-LATEST	Sun Nov  3 19:36:45 1996
--- xc/lib/Imakefile	Wed Feb 26 18:06:55 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/38 1996/11/03 19:32:18 kaleb $
  #define IHaveSubdirs
  #define PassCDebugFlags
  
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/39 1997/02/26 18:09:44 kaleb $
  #define IHaveSubdirs
  #define PassCDebugFlags
  
***************
*** 18,24 ****
  LBXUTILDIR = lbxutil
  #endif
  
! #if BuildLBX || GzipFontCompression
  ZLIBDIR = zlib
  #endif
  
--- 18,24 ----
  LBXUTILDIR = lbxutil
  #endif
  
! #if (BuildLBX || GzipFontCompression) && !HasZlib
  ZLIBDIR = zlib
  #endif
  
*** xc/lib/X11/GetDflt.c@@/PUBLIC-LATEST	Tue Dec  3 19:15:12 1996
--- xc/lib/X11/GetDflt.c	Wed Jun 11 06:44:56 1997
***************
*** 1,4 ****
! /* $XConsortium: GetDflt.c /main/55 1996/12/03 19:15:16 kaleb $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $TOG: GetDflt.c /main/56 1997/06/11 06:40:28 kaleb $ */
  
  /***********************************************************
  
***************
*** 143,149 ****
      XrmInitialize();
  
      /*
!      * See lib/Xtk/Initialize.c
       *
       * First, get the defaults from the server; if none, then load from
       * ~/.Xdefaults.  Next, if there is an XENVIRONMENT environment variable,
--- 143,149 ----
      XrmInitialize();
  
      /*
!      * See lib/Xt/Initialize.c
       *
       * First, get the defaults from the server; if none, then load from
       * ~/.Xdefaults.  Next, if there is an XENVIRONMENT environment variable,
***************
*** 153,159 ****
      if (dpy->xdefaults == NULL) {
  	char *slashDotXdefaults = "/.Xdefaults";
  
! 	(void) GetHomeDir (fname, PATH_MAX - sizeof slashDotXdefaults - 1);
  	(void) strcat (fname, slashDotXdefaults);
  	xdb = XrmGetFileDatabase (fname);
      } else {
--- 153,159 ----
      if (dpy->xdefaults == NULL) {
  	char *slashDotXdefaults = "/.Xdefaults";
  
! 	(void) GetHomeDir (fname, PATH_MAX - strlen (slashDotXdefaults) - 1);
  	(void) strcat (fname, slashDotXdefaults);
  	xdb = XrmGetFileDatabase (fname);
      } else {
***************
*** 164,170 ****
  	char *slashDotXdefaultsDash = "/.Xdefaults-";
  	int len;
  
! 	(void) GetHomeDir (fname, PATH_MAX - sizeof slashDotXdefaultsDash - 1);
  	(void) strcat (fname, slashDotXdefaultsDash);
  	len = strlen (fname);
  	(void) _XGetHostname (fname+len, PATH_MAX-len);
--- 164,170 ----
  	char *slashDotXdefaultsDash = "/.Xdefaults-";
  	int len;
  
! 	(void) GetHomeDir (fname, PATH_MAX - strlen (slashDotXdefaultsDash) - 1);
  	(void) strcat (fname, slashDotXdefaultsDash);
  	len = strlen (fname);
  	(void) _XGetHostname (fname+len, PATH_MAX-len);
*** xc/lib/X11/GetKCnt.c@@/PUBLIC-LATEST	Tue Oct 22 14:23:37 1996
--- xc/lib/X11/GetKCnt.c	Sun Jun 22 17:31:24 1997
***************
*** 1,4 ****
! /* $XConsortium: GetKCnt.c /main/11 1996/10/22 14:19:17 kaleb $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $TOG: GetKCnt.c /main/12 1997/06/22 17:29:31 kaleb $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 29,36 ****
  #define NEED_REPLIES
  #include "Xlibint.h"
  
- struct kmap {char keys[32];};
- 
  XGetKeyboardControl (dpy, state)
      register Display *dpy;
      register XKeyboardState *state;
--- 29,34 ----
***************
*** 48,54 ****
      state->bell_duration = rep.bellDuration;
      state->led_mask = rep.ledMask;
      state->global_auto_repeat = rep.globalAutoRepeat;
!     * (struct kmap *) state->auto_repeats = * (struct kmap *) rep.map;
      UnlockDisplay(dpy);
      SyncHandle();
      return 1;
--- 46,52 ----
      state->bell_duration = rep.bellDuration;
      state->led_mask = rep.ledMask;
      state->global_auto_repeat = rep.globalAutoRepeat;
!     memcpy (state->auto_repeats, rep.map, sizeof state->auto_repeats);
      UnlockDisplay(dpy);
      SyncHandle();
      return 1;
*** xc/lib/X11/Imakefile@@/PUBLIC-LATEST	Sun Dec 29 10:27:44 1996
--- xc/lib/X11/Imakefile	Tue May 20 10:02:54 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/195 1996/12/29 10:22:36 kaleb $
  #define DoNormalLib NormalLibX11
  #define DoSharedLib SharedLibX11
  #define DoDebugLib DebugLibX11
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/196 1997/05/20 10:06:09 kaleb $
  #define DoNormalLib NormalLibX11
  #define DoSharedLib SharedLibX11
  #define DoDebugLib DebugLibX11
***************
*** 24,30 ****
  EXTRA_LIBRARIES = /**/
  #endif
  #if Malloc0ReturnsNull
!      MALLOC_DEFINES = -DMALLOC_0_RETURNS_NULL
  #endif
  #if HasXdmAuth
          XDMAUTHDEFS = -DHASXDMAUTH
--- 24,30 ----
  EXTRA_LIBRARIES = /**/
  #endif
  #if Malloc0ReturnsNull
!      MALLOC_DEFINES = XMalloc0ReturnsNullDefines
  #endif
  #if HasXdmAuth
          XDMAUTHDEFS = -DHASXDMAUTH
*** xc/lib/X11/KeysymStr.c@@/PUBLIC-LATEST	Thu Jun  8 23:20:39 1995
--- xc/lib/X11/KeysymStr.c	Sun Jun 22 15:32:59 1997
***************
*** 1,4 ****
! /* $XConsortium: KeysymStr.c,v 11.10 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: KeysymStr.c /main/12 1997/06/22 15:31:42 kaleb $ */
  
  /*
  
***************
*** 93,99 ****
      unsigned char val1, val2;
      XrmDatabase keysymdb;
  
!     if (!ks)
  	return ((char *)NULL);
      if (ks == XK_VoidSymbol)
  	ks = 0;
--- 93,99 ----
      unsigned char val1, val2;
      XrmDatabase keysymdb;
  
!     if (!ks || (ks & ((unsigned long) ~0x1fffffff)) != 0)
  	return ((char *)NULL);
      if (ks == XK_VoidSymbol)
  	ks = 0;
*** xc/lib/X11/SetFPath.c@@/PUBLIC-LATEST	Tue Oct 22 14:26:23 1996
--- xc/lib/X11/SetFPath.c	Tue Apr 22 15:46:11 1997
***************
*** 1,4 ****
! /* $XConsortium: SetFPath.c /main/8 1996/10/22 14:22:03 kaleb $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $TOG: SetFPath.c /main/9 1997/04/22 15:55:16 barstow $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 40,45 ****
--- 40,46 ----
  	register int nbytes;
  	char *p;
  	register xSetFontPathReq *req;
+ 	int retCode;
  
          LockDisplay(dpy);
  	GetReq (SetFontPath, req);
***************
*** 49,66 ****
  	}
  	nbytes = (n + 3) & ~3;
  	req->length += nbytes >> 2;
! 	BufAlloc (char *, p, nbytes);
! 	/*
! 	 * pack into counted strings.
! 	 */
! 	for (i = 0; i < ndirs; i++) {
! 		register int length = safestrlen (directories[i]);
! 		*p = length;
! 		memcpy (p + 1, directories[i], length);
! 		p += length + 1;
  	}
          UnlockDisplay(dpy);
  	SyncHandle();
! 	return 1;
  }
- 		      
--- 50,75 ----
  	}
  	nbytes = (n + 3) & ~3;
  	req->length += nbytes >> 2;
! 	if (p = (char *) Xmalloc ((unsigned) nbytes)) {
! 		/*
! 	 	 * pack into counted strings.
! 	 	 */
! 		char	*tmp = p;
! 
! 		for (i = 0; i < ndirs; i++) {
! 			register int length = safestrlen (directories[i]);
! 			*p = length;
! 			memcpy (p + 1, directories[i], length);
! 			p += length + 1;
! 		}
! 		Data (dpy, tmp, nbytes);
! 		Xfree ((char *) tmp);
! 		retCode = 1;
  	}
+ 	else
+ 		retCode = 0;
+ 
          UnlockDisplay(dpy);
  	SyncHandle();
! 	return (retCode);
  }
*** xc/lib/X11/SetLocale.c@@/PUBLIC-LATEST	Sat Sep 28 16:42:42 1996
--- xc/lib/X11/SetLocale.c	Mon Jun  2 17:26:33 1997
***************
*** 1,4 ****
! /* $XConsortium: SetLocale.c /main/35 1996/09/28 16:34:22 rws $ */
  
  /*
   * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
--- 1,4 ----
! /* $TOG: SetLocale.c /main/37 1997/06/02 17:27:45 kaleb $ */
  
  /*
   * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
***************
*** 102,108 ****
  	name = getenv("LC_CTYPE");
      if (!name || !*name)
  	name = getenv("LANG");
!     if (!name || !*name)
  	name = "C";
      old_name = xsl_name;
      xsl_name = (char *)name;
--- 102,108 ----
  	name = getenv("LC_CTYPE");
      if (!name || !*name)
  	name = getenv("LANG");
!     if (!name || !*name || !_XOpenLC(name))
  	name = "C";
      old_name = xsl_name;
      xsl_name = (char *)name;
*** xc/lib/X11/XKBBind.c@@/PUBLIC-LATEST	Fri Dec 27 15:19:49 1996
--- xc/lib/X11/XKBBind.c	Tue Jun 10 07:02:46 1997
***************
*** 1,4 ****
! /* $XConsortium: XKBBind.c /main/21 1996/12/27 15:12:34 kaleb $ */
  /*
  
  Copyright (c) 1985, 1987, 1994  X Consortium
--- 1,4 ----
! /* $TOG: XKBBind.c /main/27 1997/06/10 06:53:17 kaleb $ */
  /*
  
  Copyright (c) 1985, 1987, 1994  X Consortium
***************
*** 36,42 ****
  #include <X11/keysym.h>
  #include <stdio.h>
  #include <ctype.h>
- #include <locale.h>
  
  #include <X11/extensions/XKBproto.h>
  #include "XKBlibint.h"
--- 36,41 ----
***************
*** 543,553 ****
  	    register struct _XKeytrans *p;
  	    for (p = dpy->key_bindings; p; p = p->next) {
  		register int i;
! 		p->state = AnyModifier;
! 		for (i = 0; i < p->mlen; i++) {
! 		    p->state|= XkbKeysymToModifiers(dpy,p->modifiers[i]);
  		}
- 		p->state &= AllMods;
  	    }
  	}
  	UnlockDisplay(dpy);
--- 542,555 ----
  	    register struct _XKeytrans *p;
  	    for (p = dpy->key_bindings; p; p = p->next) {
  		register int i;
! 		p->state= 0;
! 	  	if (p->mlen>0) {
! 		    for (i = 0; i < p->mlen; i++) {
! 			p->state|= XkbKeysymToModifiers(dpy,p->modifiers[i]);
! 		    }
! 		    if (p->state)	p->state &= AllMods;
! 		    else		p->state = AnyModifier;
  		}
  	    }
  	}
  	UnlockDisplay(dpy);
***************
*** 583,588 ****
--- 585,591 ----
      xkbi->desc = desc;
  
      _XkbGetConverters(_XkbGetCharset(),&xkbi->cvt);
+     _XkbGetConverters("ISO8859-1",&xkbi->latin1cvt);
      UnlockDisplay(dpy);
      oldEvents= xkbi->selected_events;
      if (!(xkbi->xlib_ctrls&XkbLC_IgnoreNewKeyboards)) {
***************
*** 665,670 ****
--- 668,675 ----
  #endif
  {
      register XkbInfoPtr	xkb;
+     XkbKSToMBFunc cvtr;
+     XPointer priv;
      char tmp[4];
      register struct _XKeytrans *p; 
      int n;
***************
*** 702,709 ****
      if ( xkb->cvt.KSToUpper && (mods&LockMask) ) {
  	*sym_rtrn = (*xkb->cvt.KSToUpper)(*sym_rtrn);
      }
!     n = (*xkb->cvt.KSToMB)(xkb->cvt.KSToMBPriv,*sym_rtrn,buffer,nbytes,
! 								extra_rtrn);
  
      if ((!xkb->cvt.KSToUpper)&&( mods&LockMask )) {
  	register int i;
--- 707,721 ----
      if ( xkb->cvt.KSToUpper && (mods&LockMask) ) {
  	*sym_rtrn = (*xkb->cvt.KSToUpper)(*sym_rtrn);
      }
!     if (xkb->xlib_ctrls & XkbLC_ForceLatin1Lookup) {
! 	cvtr = xkb->latin1cvt.KSToMB;
! 	priv = xkb->latin1cvt.KSToMBPriv;
!     } else {
! 	cvtr = xkb->cvt.KSToMB;
! 	priv = xkb->cvt.KSToMBPriv;
!     }
! 
!     n = (*cvtr)(priv,*sym_rtrn,buffer,nbytes,extra_rtrn);
  
      if ((!xkb->cvt.KSToUpper)&&( mods&LockMask )) {
  	register int i;
*** xc/lib/X11/XKBCvt.c@@/PUBLIC-LATEST	Fri Dec 27 15:20:02 1996
--- xc/lib/X11/XKBCvt.c	Tue Jun 10 07:02:49 1997
***************
*** 1,4 ****
! /* $XConsortium: XKBCvt.c /main/25 1996/12/27 15:12:44 kaleb $ */
  /*
  
  Copyright (c) 1988, 1989  X Consortium
--- 1,4 ----
! /* $TOG: XKBCvt.c /main/28 1997/06/10 06:53:20 kaleb $ */
  /*
  
  Copyright (c) 1988, 1989  X Consortium
***************
*** 108,114 ****
     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x000c};
  
  /* maps Cyrillic keysyms to 8859-5 */
! static unsigned char Const cyrillic[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
--- 108,114 ----
     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x000c};
  
  /* maps Cyrillic keysyms to 8859-5 */
! unsigned char Const _Xcyrillic[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
***************
*** 126,133 ****
      0xbf, 0xcf, 0xc0, 0xc1, 0xc2, 0xc3, 0xb6, 0xb2, /* 15 */
      0xcc, 0xcb, 0xb7, 0xc8, 0xcd, 0xc9, 0xc7, 0xca};
  
! /* maps Cyrillic keysyms to KOI0-8 */
! static unsigned char Const koi8[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
--- 126,133 ----
      0xbf, 0xcf, 0xc0, 0xc1, 0xc2, 0xc3, 0xb6, 0xb2, /* 15 */
      0xcc, 0xcb, 0xb7, 0xc8, 0xcd, 0xc9, 0xc7, 0xca};
  
! /* maps Cyrillic keysyms to KOI8-R */
! unsigned char Const _Xkoi8[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
***************
*** 146,152 ****
      0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
  
  /* maps Greek keysyms to 8859-7 */
! static unsigned char Const greek[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
--- 146,152 ----
      0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
  
  /* maps Greek keysyms to 8859-7 */
! unsigned char Const _Xgreek[128] =
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
***************
*** 295,304 ****
                  count = 0;
              break;
          case sCyrillic:
!             buf[0] = cyrillic[keysym & 0x7f];
              break;
          case sGreek:
!             buf[0] = greek[keysym & 0x7f];
              if (!buf[0])
                  count = 0;
              break;
--- 295,304 ----
                  count = 0;
              break;
          case sCyrillic:
!             buf[0] = _Xcyrillic[keysym & 0x7f];
              break;
          case sGreek:
!             buf[0] = _Xgreek[keysym & 0x7f];
              if (!buf[0])
                  count = 0;
              break;
***************
*** 469,475 ****
  	if (nbytes>0) {
  	    if ( (keysym&0x80)==0 )
  		 buffer[0] = keysym&0x7f;
! 	    else buffer[0] = koi8[keysym & 0x7f];
  	    if (nbytes>1)
  		buffer[1]= '\0';
  	    return 1;
--- 469,475 ----
  	if (nbytes>0) {
  	    if ( (keysym&0x80)==0 )
  		 buffer[0] = keysym&0x7f;
! 	    else buffer[0] = _Xkoi8[keysym & 0x7f];
  	    if (nbytes>1)
  		buffer[1]= '\0';
  	    return 1;
***************
*** 491,498 ****
          return buffer[0];
      else if ((buffer[0]&0x7f)>=32) {
  	register int i;
! 	for (i=0;i<sizeof(koi8)/sizeof(unsigned char);i++) {
! 	    if (koi8[i]==buffer[0])
  		return 0x680|i;
  	}
      }
--- 491,498 ----
          return buffer[0];
      else if ((buffer[0]&0x7f)>=32) {
  	register int i;
! 	for (i=0;i<sizeof(_Xkoi8)/sizeof(unsigned char);i++) {
! 	    if (_Xkoi8[i]==buffer[0])
  		return 0x680|i;
  	}
      }
***************
*** 621,627 ****
  	     *cvt_rtrn = cvt_X0201;
  	else if (Strcmp(encoding_name, "kana")==0) /* ??? */
  	     *cvt_rtrn = cvt_kana;
! 	else if (Strcmp(encoding_name, "tactis")==0)
  	     *cvt_rtrn = cvt_Thai;
  	else if (Strcmp(encoding_name, "koi8-r")==0)
  	     *cvt_rtrn = cvt_Koi8;
--- 621,628 ----
  	     *cvt_rtrn = cvt_X0201;
  	else if (Strcmp(encoding_name, "kana")==0) /* ??? */
  	     *cvt_rtrn = cvt_kana;
! 	else if ((Strcmp(encoding_name, "tactis")==0)||
! 		 (Strcmp(encoding_name, "tis620.2533-1")==0))
  	     *cvt_rtrn = cvt_Thai;
  	else if (Strcmp(encoding_name, "koi8-r")==0)
  	     *cvt_rtrn = cvt_Koi8;
*** xc/lib/X11/XKBSetGeom.c@@/PUBLIC-LATEST	Tue Oct 22 14:28:33 1996
--- xc/lib/X11/XKBSetGeom.c	Tue Jun 10 07:02:53 1997
***************
*** 1,4 ****
! /* $XConsortium: XKBSetGeom.c /main/7 1996/10/22 14:24:13 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: XKBSetGeom.c /main/8 1997/06/10 06:53:24 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 464,470 ****
  
  /***====================================================================***/
  
! static Status 
  #if NeedFunctionPrototypes
  _SendSetGeometry(Display *dpy,XkbGeometryPtr geom,xkbSetGeometryReq *req)
  #else
--- 464,470 ----
  
  /***====================================================================***/
  
! static Status
  #if NeedFunctionPrototypes
  _SendSetGeometry(Display *dpy,XkbGeometryPtr geom,xkbSetGeometryReq *req)
  #else
***************
*** 552,561 ****
      req->nKeyAliases= geom->num_key_aliases;
      req->baseColorNdx= (geom->base_color-geom->colors);
      req->labelColorNdx= (geom->label_color-geom->colors);
!     if ((ret = _SendSetGeometry(dpy,geom,req)) != Success)
! 	return ret;
      UnlockDisplay(dpy);
      SyncHandle();
!     return Success;
  }
  
--- 552,561 ----
      req->nKeyAliases= geom->num_key_aliases;
      req->baseColorNdx= (geom->base_color-geom->colors);
      req->labelColorNdx= (geom->label_color-geom->colors);
! 
!     ret = _SendSetGeometry(dpy,geom,req);
      UnlockDisplay(dpy);
      SyncHandle();
!     return ret;
  }
  
*** xc/lib/X11/XKBlibint.h@@/PUBLIC-LATEST	Fri Dec 27 15:20:05 1996
--- xc/lib/X11/XKBlibint.h	Tue Jun 10 07:02:56 1997
***************
*** 1,4 ****
! /* $XConsortium: XKBlibint.h /main/12 1996/12/27 15:12:48 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: XKBlibint.h /main/15 1997/06/10 06:53:27 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 83,88 ****
--- 83,89 ----
  	XkbMapChangesRec changes;
  	Atom		 composeLED;
  	XkbConverters	 cvt;
+ 	XkbConverters	 latin1cvt;
  } XkbInfoRec, *XkbInfoPtr;
  
  
***************
*** 166,172 ****
  #endif
  );
  
! extern _XRefreshKeyboardMapping(
  #if NeedFunctionPrototypes
      XMappingEvent*	/* event_map */    
  #endif
--- 167,173 ----
  #endif
  );
  
! extern int _XRefreshKeyboardMapping(
  #if NeedFunctionPrototypes
      XMappingEvent*	/* event_map */    
  #endif
***************
*** 343,348 ****
--- 344,350 ----
      void
  #endif
  );
+ 
  extern int	 _XkbGetConverters(
  #if NeedFunctionPrototypes
      char *		/* encoding_name */,
*** xc/lib/X11/Ximint.h@@/PUBLIC-LATEST	Mon Oct 10 18:33:16 1994
--- xc/lib/X11/Ximint.h	Mon Apr 28 16:39:30 1997
***************
*** 1,4 ****
! /* $XConsortium: Ximint.h,v 1.9 94/10/10 18:33:16 kaleb Exp $ */
  /******************************************************************
  
                  Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: Ximint.h /main/10 1997/04/28 16:40:16 barstow $ */
  /******************************************************************
  
                  Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 664,670 ****
  
  extern void	_XimServerDestroy(
  #if NeedFunctionPrototypes
!     void
  #endif
  );
  
--- 664,670 ----
  
  extern void	_XimServerDestroy(
  #if NeedFunctionPrototypes
!     Xim			im
  #endif
  );
  
*** xc/lib/X11/XlcPubI.h@@/PUBLIC-LATEST	Sat Sep 28 16:43:27 1996
--- xc/lib/X11/XlcPubI.h	Tue Jun  3 15:51:02 1997
***************
*** 1,4 ****
! /* $XConsortium: XlcPubI.h /main/6 1996/09/28 16:35:06 rws $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: XlcPubI.h /main/8 1997/06/03 15:52:40 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 207,223 ****
  extern int _XlcResolveLocaleName(
  #if NeedFunctionPrototypes
      char*		/* lc_name */,
!     char*		/* full_name */,
!     char*		/* language */,
!     char*		/* territory */,
!     char*		/* codeset */
! #endif
! );
! 
! extern int _XlcResolveDBName(
! #if NeedFunctionPrototypes
!     char*		/* lc_name */,
!     char*		/* file_name */
  #endif
  );
  
--- 207,213 ----
  extern int _XlcResolveLocaleName(
  #if NeedFunctionPrototypes
      char*		/* lc_name */,
!     XLCdPublicPart*	/* pub */
  #endif
  );
  
*** xc/lib/X11/XlcPublic.h@@/PUBLIC-LATEST	Thu Dec  5 10:40:14 1996
--- xc/lib/X11/XlcPublic.h	Sun Jun 22 07:40:38 1997
***************
*** 1,4 ****
! /* $XConsortium: XlcPublic.h /main/5 1996/12/05 10:40:11 swick $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: XlcPublic.h /main/6 1997/06/22 07:38:55 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 54,60 ****
      XlcUnknown, XlcC0, XlcGL, XlcC1, XlcGR, XlcGLGR, XlcOther, XlcNONE
  } XlcSide;
  
! typedef struct _FonScope {
          unsigned long   start;
          unsigned long   end;
          unsigned long   shift;
--- 54,60 ----
      XlcUnknown, XlcC0, XlcGL, XlcC1, XlcGR, XlcGLGR, XlcOther, XlcNONE
  } XlcSide;
  
! typedef struct _FontScope {
          unsigned long   start;
          unsigned long   end;
          unsigned long   shift;
*** xc/lib/X11/Xrm.c@@/PUBLIC-LATEST	Thu Jun  8 23:20:39 1995
--- xc/lib/X11/Xrm.c	Sun Jun 22 07:13:22 1997
***************
*** 1,4 ****
! /* $XConsortium: Xrm.c,v 1.89 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard
--- 1,4 ----
! /* $TOG: Xrm.c /main/92 1997/06/22 07:14:10 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard
***************
*** 486,491 ****
--- 486,492 ----
      if (db) {
  	_XCreateMutex(&db->linfo);
  	db->table = (NTable)NULL;
+ 	db->mbstate = (XPointer)NULL;
  	db->methods = _XrmInitParseInfo(&db->mbstate);
  	if (!db->methods)
  	    db->methods = (XrmMethods)&mb_methods;
***************
*** 1065,1073 ****
   * Chris Peterson, MIT X Consortium		5/17/90.
   */
  
! #define LIST_SIZE 101
! #define BUFFER_SIZE 100
  
  static void GetIncludeFile();
  
  static void GetDatabase(db, str, filename, doall)
--- 1066,1084 ----
   * Chris Peterson, MIT X Consortium		5/17/90.
   */
  
! /* 
!  * Xlib spec says max 100 quarks in a lookup, will stop and return if
!  * return if any single production's lhs has more than 100 components.
!  */
! #define QLIST_SIZE 100
  
+ /* 
+  * This should be big enough to handle things like the XKeysymDB or biggish
+  * ~/.Xdefaults or app-defaults files. Anything bigger will be allocated on
+  * the heap.
+  */
+ #define DEF_BUFF_SIZE 8192
+ 
  static void GetIncludeFile();
  
  static void GetDatabase(db, str, filename, doall)
***************
*** 1076,1094 ****
      char *filename;
      Bool doall;
  {
      register char *ptr;
      register XrmBits bits = 0;
      register char c;
-     int len;
      register Signature sig;
      register char *ptr_max;
!     register XrmQuarkList t_quarks;
      register XrmBindingList t_bindings;
  
!     int alloc_chars = BUFSIZ;
!     char buffer[BUFSIZ], *value_str;
!     XrmQuark quarks[LIST_SIZE];
!     XrmBinding bindings[LIST_SIZE];
      XrmValue value;
      Bool only_pcs;
      Bool dolines;
--- 1087,1107 ----
      char *filename;
      Bool doall;
  {
+     char *rhs;
+     char *lhs, lhs_s[DEF_BUFF_SIZE];
+     XrmQuark quarks[QLIST_SIZE + 1];	/* allow for a terminal NullQuark */
+     XrmBinding bindings[QLIST_SIZE + 1];
+ 
      register char *ptr;
      register XrmBits bits = 0;
      register char c;
      register Signature sig;
      register char *ptr_max;
!     register int num_quarks;
      register XrmBindingList t_bindings;
  
!     int len, alloc_chars;
!     unsigned long str_len;
      XrmValue value;
      Bool only_pcs;
      Bool dolines;
***************
*** 1096,1104 ****
      if (!db)
  	return;
  
!     if (!(value_str = Xmalloc(sizeof(char) * alloc_chars)))
  	return;
  
      (*db->methods->mbinit)(db->mbstate);
      str--;
      dolines = True;
--- 1109,1141 ----
      if (!db)
  	return;
  
!     /* 
!      * if strlen (str) < DEF_BUFF_SIZE allocate buffers on the stack for 
!      * speed otherwise malloc the buffer. From a buffer overflow standpoint
!      * we can be sure that neither: a) a component on the lhs, or b) a
!      * value on the rhs, will be longer than the overall length of str,
!      * i.e. strlen(str).
!      *
!      * This should give good performance when parsing "*foo: bar" type 
!      * databases as might be passed with -xrm command line options; but
!      * with larger databases, e.g. .Xdefaults, app-defaults, or KeysymDB
!      * files, the size of the buffers will be overly large. One way
!      * around this would be to double-parse each production with a resulting
!      * performance hit. In any event we can be assured that a lhs component
!      * name or a rhs value won't be longer than str itself.
!      */
! 
!     str_len = strlen (str);
!     if (DEF_BUFF_SIZE > str_len) lhs = lhs_s;
!     else if ((lhs = (char*) Xmalloc (str_len)) == NULL) 
  	return;
  
+     alloc_chars = DEF_BUFF_SIZE < str_len ? str_len : DEF_BUFF_SIZE;
+     if ((rhs = (char*) Xmalloc (alloc_chars)) == NULL) {
+ 	if (lhs != lhs_s) Xfree (lhs);
+ 	return;
+     }
+ 
      (*db->methods->mbinit)(db->mbstate);
      str--;
      dolines = True;
***************
*** 1177,1195 ****
  	/*
  	 * Third: loop through the LHS of the resource specification
  	 * storing characters and converting this to a Quark.
- 	 *
- 	 * If the number of quarks is greater than LIST_SIZE - 1.  This
- 	 * function will trash your memory.
- 	 *
- 	 * If the length of any quark is larger than BUFSIZ this function
- 	 * will also trash memory.
  	 */
  	
  	t_bindings = bindings;
- 	t_quarks = quarks;
  
  	sig = 0;
! 	ptr = buffer;
  	*t_bindings = XrmBindTightly;	
  	for(;;) {
  	    if (!is_binding(bits)) {
--- 1214,1226 ----
  	/*
  	 * Third: loop through the LHS of the resource specification
  	 * storing characters and converting this to a Quark.
  	 */
  	
+ 	num_quarks = 0;
  	t_bindings = bindings;
  
  	sig = 0;
! 	ptr = lhs;
  	*t_bindings = XrmBindTightly;	
  	for(;;) {
  	    if (!is_binding(bits)) {
***************
*** 1199,1207 ****
  		    bits = next_char(c, str);
  		}
  
! 		*t_quarks++ = _XrmInternalStringToQuark(buffer, ptr - buffer,
! 							sig, False);
  
  		if (is_separator(bits))  {
  		    if (!is_space(bits))
  			break;
--- 1230,1245 ----
  		    bits = next_char(c, str);
  		}
  
! 		quarks[num_quarks++] = 
! 			_XrmInternalStringToQuark(lhs, ptr - lhs, sig, False);
  
+ 		if (num_quarks > QLIST_SIZE) {
+ 		    Xfree(rhs);
+ 		    if (lhs != lhs_s) Xfree (lhs);
+ 		    (*db->methods->mbfinish)(db->mbstate);
+ 		    return;
+ 		}
+ 
  		if (is_separator(bits))  {
  		    if (!is_space(bits))
  			break;
***************
*** 1219,1225 ****
  
  		    if (is_separator(bits))
  			break;
! 		    t_quarks--;
  		    continue;
  		}
  
--- 1257,1263 ----
  
  		    if (is_separator(bits))
  			break;
! 		    num_quarks--;
  		    continue;
  		}
  
***************
*** 1229,1235 ****
  		    *(++t_bindings) = XrmBindLoosely;
  
  		sig = 0;
! 		ptr = buffer;
  	    }
  	    else {
  		/*
--- 1267,1273 ----
  		    *(++t_bindings) = XrmBindLoosely;
  
  		sig = 0;
! 		ptr = lhs;
  	    }
  	    else {
  		/*
***************
*** 1249,1255 ****
  	    bits = next_char(c, str);
  	}
  
! 	*t_quarks = NULLQUARK;
  
  	/*
  	 * Make sure that there is a ':' in this line.
--- 1287,1293 ----
  	    bits = next_char(c, str);
  	}
  
! 	quarks[num_quarks] = NULLQUARK;
  
  	/*
  	 * Make sure that there is a ':' in this line.
***************
*** 1305,1311 ****
  	 * Fifth: Process the right hand side.
  	 */
  
! 	ptr = value_str;
  	ptr_max = ptr + alloc_chars - 4;
  	only_pcs = True;
  	len = 1;
--- 1343,1349 ----
  	 * Fifth: Process the right hand side.
  	 */
  
! 	ptr = rhs;
  	ptr_max = ptr + alloc_chars - 4;
  	only_pcs = True;
  	len = 1;
***************
*** 1432,1448 ****
  		char * temp_str;
  
  		alloc_chars += BUFSIZ/10;		
! 		temp_str = Xrealloc(value_str, sizeof(char) * alloc_chars);
  
  		if (!temp_str) {
! 		    Xfree(value_str);
  		    (*db->methods->mbfinish)(db->mbstate);
  		    return;
  		}
  
! 		ptr = temp_str + (ptr - value_str); /* reset pointer. */
! 		value_str = temp_str;
! 		ptr_max = value_str + alloc_chars - 4;
  	    }
  	}
  
--- 1470,1487 ----
  		char * temp_str;
  
  		alloc_chars += BUFSIZ/10;		
! 		temp_str = Xrealloc(rhs, sizeof(char) * alloc_chars);
  
  		if (!temp_str) {
! 		    Xfree(rhs);
! 		    if (lhs != lhs_s) Xfree (lhs);
  		    (*db->methods->mbfinish)(db->mbstate);
  		    return;
  		}
  
! 		ptr = temp_str + (ptr - rhs); /* reset pointer. */
! 		rhs = temp_str;
! 		ptr_max = rhs + alloc_chars - 4;
  	    }
  	}
  
***************
*** 1454,1466 ****
  	*ptr++ = '\0';
  
  	/* Store it in database */
! 	value.size = ptr - value_str;
! 	value.addr = (XPointer) value_str;
  	
  	PutEntry(db, bindings, quarks, XrmQString, &value);
      }
  
!     Xfree(value_str);
      (*db->methods->mbfinish)(db->mbstate);
  }
  
--- 1493,1507 ----
  	*ptr++ = '\0';
  
  	/* Store it in database */
! 	value.size = ptr - rhs;
! 	value.addr = (XPointer) rhs;
  	
  	PutEntry(db, bindings, quarks, XrmQString, &value);
      }
  
!     if (lhs != lhs_s) Xfree (lhs);
!     Xfree (rhs);
! 
      (*db->methods->mbfinish)(db->mbstate);
  }
  
*** xc/lib/X11/imConv.c@@/PUBLIC-LATEST	Sun Dec 29 10:28:13 1996
--- xc/lib/X11/imConv.c	Tue Feb 11 17:50:36 1997
***************
*** 1,4 ****
! /* $XConsortium: imConv.c /main/9 1996/12/29 10:23:02 kaleb $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
--- 1,4 ----
! /* $TOG: imConv.c /main/11 1997/02/11 17:48:36 kaleb $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
***************
*** 37,47 ****
  #include "Xlibint.h"
  #include "Xlcint.h"
  #include "Ximint.h"
  
  #ifdef XKB
! #define	XLookupString		_XLookupString
! #endif
! 
  /* maps Cyrillic keysyms to 8859-5 */
  static unsigned char cyrillic[128] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x80 - */
--- 37,55 ----
  #include "Xlibint.h"
  #include "Xlcint.h"
  #include "Ximint.h"
+ #include "XlcPubI.h"
  
  #ifdef XKB
! #include "XKBlib.h"
! #define	XLOOKUPSTRING lookup_string
! extern unsigned char _Xcyrillic[];
! #define cyrillic _Xcyrillic
! extern unsigned char _Xkoi8[];
! #define koi8 _Xkoi8
! extern unsigned char _Xgreek[];
! #define greek _Xgreek
! #else
! #define	XLOOKUPSTRING XLookupString
  /* maps Cyrillic keysyms to 8859-5 */
  static unsigned char cyrillic[128] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x80 - */
***************
*** 62,67 ****
--- 70,95 ----
      0xcc, 0xcb, 0xb7, 0xc8, 0xcd, 0xc9, 0xc7, 0xca
  };
  
+ /* maps Cyrillic keysyms to KOI8-R */
+ unsigned char Const koi8[128] =
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0xa3, 0x00, 0x00, 0x00, 0x00, /* 10 */
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00, /* 11 */
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, /* 12 */
+     0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+     0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, /* 13 */
+     0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+     0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, /* 14 */
+     0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+     0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, /* 15 */
+     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
+ 
+ 
  /* maps Greek keysyms to 8859-7 */
  static unsigned char greek[128] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x80 - */
***************
*** 82,89 ****
      0xf8, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  
! static unsigned char get_code(), get_greek(), get_cyril();
  
  struct CodesetRec {
      unsigned long kset;
      char *designator;
--- 110,119 ----
      0xf8, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  
! #endif
  
+ static unsigned char get_code(), get_greek(), get_cyril(), get_koi8();
+ 
  struct CodesetRec {
      unsigned long kset;
      char *designator;
***************
*** 104,109 ****
--- 134,144 ----
  
  static int codeset_size = sizeof(codeset) / sizeof(codeset[0]);
  
+ #define sCyrillic 6
+ static struct CodesetRec koi8codeset = {
+     0x06l, "\033%/1\200\210koi8-r\002", get_koi8  /* KIO8-R (Cyrillic) */
+ };
+ 
  static unsigned char
  get_code(keysym)
  KeySym keysym;
***************
*** 115,130 ****
  get_cyril(keysym)
  KeySym keysym;
  {
!     return(cyrillic[keysym & 0x7f]);
  }
  
  static unsigned char
  get_greek(keysym)
  KeySym keysym;
  {
!     return(greek[keysym & 0x7f]);
  }
  
  #define BUF_SIZE (20)
  
  int
--- 150,190 ----
  get_cyril(keysym)
  KeySym keysym;
  {
!     return cyrillic[keysym & 0x7f];
  }
  
  static unsigned char
+ get_koi8(keysym)
+ KeySym keysym;
+ {
+     return koi8[keysym & 0x7f];
+ }
+ 
+ static unsigned char
  get_greek(keysym)
  KeySym keysym;
  {
!     return greek[keysym & 0x7f];
  }
  
+ #ifdef XKB
+ static int lookup_string (event, buffer, nbytes, keysym, status)
+     XKeyEvent		*event;
+     unsigned char	*buffer;
+     int			 nbytes;
+     KeySym		*keysym;
+     XComposeStatus	*status;
+ {
+     int ret;
+     unsigned ctrls = XkbGetXlibControls (event->display);
+     XkbSetXlibControls (event->display, 
+ 			XkbLC_ForceLatin1Lookup, XkbLC_ForceLatin1Lookup);
+     ret = XLookupString(event, buffer, nbytes, keysym, status);
+     XkbSetXlibControls (event->display, ctrls, ctrls);
+     return ret;
+ }
+ #endif
+ 
  #define BUF_SIZE (20)
  
  int
***************
*** 144,153 ****
      unsigned char c;
      Status	dummy;
      Xim	im = (Xim)ic->core.im;
      char local_buf[BUF_SIZE];
      unsigned char look[BUF_SIZE];
  
!     count = XLookupString(event, (char *)buffer, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
--- 204,214 ----
      unsigned char c;
      Status	dummy;
      Xim	im = (Xim)ic->core.im;
+     XLCd lcd = im->core.lcd;
      char local_buf[BUF_SIZE];
      unsigned char look[BUF_SIZE];
  
!     count = XLOOKUPSTRING(event, (char *)buffer, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
***************
*** 160,165 ****
--- 221,230 ----
  		break;
  	    }
  	}
+ 	if (kset == sCyrillic &&
+ 	    (strcmp (XLC_PUBLIC(lcd,encoding_name),"KOI8-R") == 0)) {
+ 	    cset = &koi8codeset;
+ 	}
  	if ((cset) && (c = (*cset->char_code)(symbol))) {
  	    strcpy(local_buf, cset->designator);
  	    local_count = strlen(cset->designator);
***************
*** 201,210 ****
      unsigned char c;
      Status	dummy;
      Xim	im = (Xim)ic->core.im;
      char local_buf[BUF_SIZE];
      unsigned char look[BUF_SIZE];
  
!     count = XLookupString(event, (char *)look, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
--- 266,276 ----
      unsigned char c;
      Status	dummy;
      Xim	im = (Xim)ic->core.im;
+     XLCd lcd = im->core.lcd;
      char local_buf[BUF_SIZE];
      unsigned char look[BUF_SIZE];
  
!     count = XLOOKUPSTRING(event, (char *)look, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
***************
*** 217,222 ****
--- 283,292 ----
  		cset = &codeset[i];
  		break;
  	    }
+ 	}
+ 	if (kset == sCyrillic &&
+ 	    (strcmp (XLC_PUBLIC(lcd,encoding_name),"KOI8-R") == 0)) {
+ 	    cset = &koi8codeset;
  	}
  	if ((cset) && (c = (*cset->char_code)(symbol))) {
  	    strcpy(local_buf, cset->designator);
*** xc/lib/X11/imDefFlt.c@@/PUBLIC-LATEST	Wed Dec  6 11:23:59 1995
--- xc/lib/X11/imDefFlt.c	Mon Apr 28 16:38:32 1997
***************
*** 1,4 ****
! /* $XConsortium: imDefFlt.c /main/8 1995/12/06 11:23:17 kaleb $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: imDefFlt.c /main/9 1997/04/28 16:39:25 barstow $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 370,376 ****
  	    return True;
  	}
  #endif /* XIM_CONNECTABLE */
! 	_XimServerDestroy();
      }
      return True;
  }
--- 370,376 ----
  	    return True;
  	}
  #endif /* XIM_CONNECTABLE */
! 	_XimServerDestroy(im);
      }
      return True;
  }
*** xc/lib/X11/imDefIc.c@@/PUBLIC-LATEST	Sat Sep 28 16:45:33 1996
--- xc/lib/X11/imDefIc.c	Sun Jun 22 18:13:07 1997
***************
*** 1,4 ****
! /* $XConsortium: imDefIc.c /main/16 1996/09/28 16:37:13 rws $ */
  /******************************************************************
  
             Copyright 1991, 1992 by Sun Microsystems, Inc.
--- 1,4 ----
! /* $TOG: imDefIc.c /main/18 1997/06/22 18:11:11 kaleb $ */
  /******************************************************************
  
             Copyright 1991, 1992 by Sun Microsystems, Inc.
***************
*** 352,358 ****
  				ic->private.proto.ic_num_resources, arg,
  				&buf_s[3], &len, XIM_GETICVALUES);
  
!     if (len) {
  	buf_s[0] = im->private.proto.imid;		/* imid */
  	buf_s[1] = ic->private.proto.icid;		/* icid */
  	buf_s[2] = len;				/* length of ic-attr-id */
--- 352,358 ----
  				ic->private.proto.ic_num_resources, arg,
  				&buf_s[3], &len, XIM_GETICVALUES);
  
!     if (len > 0) {
  	buf_s[0] = im->private.proto.imid;		/* imid */
  	buf_s[1] = ic->private.proto.icid;		/* icid */
  	buf_s[2] = len;				/* length of ic-attr-id */
***************
*** 400,406 ****
  	data = &buf_s[4];
  	data_len = buf_s[2];
      }
!     else {
  	return arg->name;
      }
  
--- 400,406 ----
  	data = &buf_s[4];
  	data_len = buf_s[2];
      }
!     else if (len < 0) {
  	return arg->name;
      }
  
***************
*** 684,696 ****
      int			 ret_code;
      BITMASK32		 flag = 0L;
      char		*name;
  
  #ifndef XIM_CONNECTABLE
      if (!IS_IC_CONNECTED(ic))
! 	return arg->name;
  #else
      if (!_XimSaveICValues(ic, arg))
! 	return False;
  
      if (!IS_IC_CONNECTED(ic)) {
  	if (IS_CONNECTABLE(im)) {
--- 684,697 ----
      int			 ret_code;
      BITMASK32		 flag = 0L;
      char		*name;
+     char		*tmp_name = (arg) ? arg->name : NULL;
  
  #ifndef XIM_CONNECTABLE
      if (!IS_IC_CONNECTED(ic))
! 	return tmp_name;
  #else
      if (!_XimSaveICValues(ic, arg))
! 	return NULL;
  
      if (!IS_IC_CONNECTED(ic)) {
  	if (IS_CONNECTABLE(im)) {
***************
*** 703,709 ****
  	        return _XimDelayModeSetICValues(ic, arg);
  	    }
          } else {
! 	    return arg->name;
          }
      }
  #endif /* XIM_CONNECTABLE */
--- 704,710 ----
  	        return _XimDelayModeSetICValues(ic, arg);
  	    }
          } else {
! 	    return tmp_name;
          }
      }
  #endif /* XIM_CONNECTABLE */
***************
*** 732,738 ****
  	buf_size += ret_len;
  	if (buf == tmp_buf) {
  	    if (!(tmp = (char *)Xmalloc(buf_size + data_len))) {
! 		return arg->name;
  	    }
  	    memcpy(tmp, buf, buf_size);
  	    buf = tmp;
--- 733,739 ----
  	buf_size += ret_len;
  	if (buf == tmp_buf) {
  	    if (!(tmp = (char *)Xmalloc(buf_size + data_len))) {
! 		return tmp_name;
  	    }
  	    memcpy(tmp, buf, buf_size);
  	    buf = tmp;
***************
*** 739,745 ****
  	} else {
  	    if (!(tmp = (char *)Xrealloc(buf, (buf_size + data_len)))) {
  		Xfree(buf);
! 		return arg->name;
  	    }
  	    buf = tmp;
  	}
--- 740,746 ----
  	} else {
  	    if (!(tmp = (char *)Xrealloc(buf, (buf_size + data_len)))) {
  		Xfree(buf);
! 		return tmp_name;
  	    }
  	    buf = tmp;
  	}
***************
*** 747,756 ****
      _XimSetCurrentICValues(ic, &ic_values);
  
      if (!total) {
! 	if(arg)
! 	    return arg->name;
! 	else
! 	    return (char *)NULL;
      }
  
      buf_s = (CARD16 *)&buf[XIM_HEADER_SIZE];
--- 748,754 ----
      _XimSetCurrentICValues(ic, &ic_values);
  
      if (!total) {
!         return tmp_name;
      }
  
      buf_s = (CARD16 *)&buf[XIM_HEADER_SIZE];
***************
*** 771,777 ****
      if (!(_XimWrite(im, len, (XPointer)buf))) {
  	if (buf != tmp_buf)
  	    Xfree(buf);
! 	return arg->name;
      }
      _XimFlush(im);
      if (buf != tmp_buf)
--- 769,775 ----
      if (!(_XimWrite(im, len, (XPointer)buf))) {
  	if (buf != tmp_buf)
  	    Xfree(buf);
! 	return tmp_name;
      }
      _XimFlush(im);
      if (buf != tmp_buf)
***************
*** 790,800 ****
  	if(ret_code != XIM_TRUE) {
  	    Xfree(preply);
  	    ic->private.proto.waitCallback = False;
! 	    return arg->name;
  	}
      } else {
  	ic->private.proto.waitCallback = False;
! 	return arg->name;
      }
      ic->private.proto.waitCallback = False;
      buf_s = (CARD16 *)((char *)preply + XIM_HEADER_SIZE);
--- 788,798 ----
  	if(ret_code != XIM_TRUE) {
  	    Xfree(preply);
  	    ic->private.proto.waitCallback = False;
! 	    return tmp_name;
  	}
      } else {
  	ic->private.proto.waitCallback = False;
! 	return tmp_name;
      }
      ic->private.proto.waitCallback = False;
      buf_s = (CARD16 *)((char *)preply + XIM_HEADER_SIZE);
***************
*** 802,808 ****
  	_XimProcError(im, 0, (XPointer)&buf_s[3]);
  	if(reply != preply)
  	    Xfree(preply);
! 	return arg->name;
      }
      if(reply != preply)
  	Xfree(preply);
--- 800,806 ----
  	_XimProcError(im, 0, (XPointer)&buf_s[3]);
  	if(reply != preply)
  	    Xfree(preply);
! 	return tmp_name;
      }
      if(reply != preply)
  	Xfree(preply);
*** xc/lib/X11/imDefLkup.c@@/PUBLIC-LATEST	Wed Dec  6 11:24:13 1995
--- xc/lib/X11/imDefLkup.c	Sat Jun 21 21:32:16 1997
***************
*** 1,4 ****
! /* $XConsortium: imDefLkup.c /main/16 1995/12/06 11:23:31 kaleb $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: imDefLkup.c /main/17 1997/06/21 21:30:12 kaleb $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 761,766 ****
--- 761,767 ----
      ev.display = im->core.display;
      ev.window = ic->core.focus_window;
      ev.keycode = 0;
+     ev.state = 0;
  
      XPutBackEvent(im->core.display, (XEvent *)&ev);
  
*** xc/lib/X11/imInt.c@@/PUBLIC-LATEST	Sat Mar 26 17:00:26 1994
--- xc/lib/X11/imInt.c	Mon Apr 28 16:39:09 1997
***************
*** 1,4 ****
! /* $XConsortium: imInt.c,v 1.3 94/03/26 17:00:26 rws Exp $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: imInt.c /main/4 1997/04/28 16:39:57 barstow $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 86,92 ****
  }
  
  Public void
! _XimServerDestroy()
  {
      register int  i;
      Xim		  im;
--- 86,93 ----
  }
  
  Public void
! _XimServerDestroy(im_2_destroy)
!     Xim		  im_2_destroy;
  {
      register int  i;
      Xim		  im;
***************
*** 95,100 ****
--- 96,106 ----
      for(i = 0; i < _XimCurrentIMcount; i++) {
  	if(!(im = _XimCurrentIMlist[i]))
  	    continue;
+ 	/*
+ 	 * Only continue if this im is the one to be destroyed.
+ 	 */
+ 	if (im != im_2_destroy)
+ 	    continue;
  
  	if (im->core.destroy_callback.callback)
  	    (*im->core.destroy_callback.callback)(im,
***************
*** 108,117 ****
  	_XimResetIMInstantiateCallback( im );
  	(void)im->methods->close((XIM)im);
  	Xfree(im);
      }
-     Xfree(_XimCurrentIMlist);
-     _XimCurrentIMlist  = (Xim *)NULL;
-     return;
  }
  
  #ifdef XIM_CONNECTABLE
--- 114,122 ----
  	_XimResetIMInstantiateCallback( im );
  	(void)im->methods->close((XIM)im);
  	Xfree(im);
+ 	_XimCurrentIMlist[i] = NULL;
+ 	return;
      }
  }
  
  #ifdef XIM_CONNECTABLE
*** xc/lib/X11/imRm.c@@/PUBLIC-LATEST	Sat Nov 18 16:08:47 1995
--- xc/lib/X11/imRm.c	Sun Jun 22 18:28:11 1997
***************
*** 1,4 ****
! /* $XConsortium: imRm.c /main/10 1995/11/18 16:08:18 kaleb $ */
  /******************************************************************
  
  	  Copyright 1990, 1991, 1992,1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: imRm.c /main/11 1997/06/22 18:26:20 kaleb $ */
  /******************************************************************
  
  	  Copyright 1990, 1991, 1992,1993, 1994 by FUJITSU LIMITED
***************
*** 2919,2927 ****
--- 2919,2929 ----
      if(mode & XIM_PREEDIT_ATTR) {
  	info = ic_pre_attr_info;
  	num  = XIMNumber(ic_pre_attr_info);
+ 	top = (XPointer) &((XimDefICValues *)top)->preedit_attr;
      } else if(mode & XIM_STATUS_ATTR) {
  	info = ic_sts_attr_info;
  	num  = XIMNumber(ic_sts_attr_info);
+ 	top = (XPointer) &((XimDefICValues *)top)->status_attr;
      } else {
  	info = ic_attr_info;
  	num  = XIMNumber(ic_attr_info);
*** xc/lib/X11/imRmAttr.c@@/PUBLIC-LATEST	Tue Oct 22 14:29:05 1996
--- xc/lib/X11/imRmAttr.c	Sun Jun 22 18:13:28 1997
***************
*** 1,4 ****
! /* $XConsortium: imRmAttr.c /main/12 1996/10/22 14:24:45 kaleb $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $TOG: imRmAttr.c /main/13 1997/06/22 18:11:18 kaleb $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 150,155 ****
--- 150,156 ----
  	if (!(res = _XimGetResourceListRec(res_list, res_num, p->name))) {
  	    if (_XimCheckInnerICAttributes(ic, p, mode))
  		continue;
+ 	    *len = -1;
  	    return p->name;
  	}
  
***************
*** 157,162 ****
--- 158,164 ----
  	if(check == XIM_CHECK_INVALID)
  	    continue;
  	else if(check == XIM_CHECK_ERROR) {
+ 	    *len = -1;
  	    return p->name;
  	}
  
***************
*** 168,174 ****
  		if (name = _XimMakeICAttrIDList(ic, res_list, res_num,
  				(XIMArg *)p->value, buf, &new_len,
  				(mode | XIM_PREEDIT_ATTR))) {
! 		    *len += new_len;
  		    return name;
  		}
  	    } else if (res->xrm_name == sts_quark) {
--- 170,177 ----
  		if (name = _XimMakeICAttrIDList(ic, res_list, res_num,
  				(XIMArg *)p->value, buf, &new_len,
  				(mode | XIM_PREEDIT_ATTR))) {
! 		    if (new_len < 0) *len = -1;
! 		    else *len += new_len;
  		    return name;
  		}
  	    } else if (res->xrm_name == sts_quark) {
***************
*** 175,181 ****
  		if (name = _XimMakeICAttrIDList(ic, res_list, res_num,
  				(XIMArg *)p->value, buf, &new_len,
  				(mode | XIM_STATUS_ATTR))) {
! 		    *len += new_len;
  		    return name;
  		}
  	    }
--- 178,185 ----
  		if (name = _XimMakeICAttrIDList(ic, res_list, res_num,
  				(XIMArg *)p->value, buf, &new_len,
  				(mode | XIM_STATUS_ATTR))) {
! 		    if (new_len < 0) *len = -1;
! 		    else *len += new_len;
  		    return name;
  		}
  	    }
***************
*** 184,189 ****
--- 188,194 ----
  	    if (!(res = _XimGetNestedListSeparator(res_list, res_num))) {
  		p++;
  		if (p) {
+ 		    *len = -1;
  		    return p->name;
  		}
  		else {
*** xc/lib/X11/lcCT.c@@/PUBLIC-LATEST	Thu Dec  5 10:40:22 1996
--- xc/lib/X11/lcCT.c	Tue Feb 11 17:50:39 1997
***************
*** 1,4 ****
! /* $XConsortium: lcCT.c /main/9 1996/12/05 10:40:19 swick $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: lcCT.c /main/11 1997/02/11 17:48:39 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 91,96 ****
--- 91,97 ----
      /* Non-Standard Character Set Encodings */
      { "TIS620.2533-1:GR", "\033-T"},
  #endif
+     { "KOI8-R:GR", "\033%/1\200\210koi8-r\002"},
  } ; 
  
  #define XctC0		0x0000
*** xc/lib/X11/lcDB.c@@/PUBLIC-LATEST	Thu Dec  5 11:10:19 1996
--- xc/lib/X11/lcDB.c	Mon Jun  2 17:26:38 1997
***************
*** 1,4 ****
! /* $XConsortium: lcDB.c /main/11 1996/12/05 11:10:38 swick $ */
  /*
   *
   * Copyright IBM Corporation 1993
--- 1,4 ----
! /* $TOG: lcDB.c /main/12 1997/06/02 17:27:50 kaleb $ */
  /*
   *
   * Copyright IBM Corporation 1993
***************
*** 1202,1208 ****
      Database p, database = (Database)NULL;
      XlcDatabase lc_db = (XlcDatabase)NULL;
      XrmQuark name_q;
!     char pathname[256], *name;
      int i, n;
  
      name = _XlcFileName(lcd, "locale");
--- 1202,1208 ----
      Database p, database = (Database)NULL;
      XlcDatabase lc_db = (XlcDatabase)NULL;
      XrmQuark name_q;
!     char *name;
      int i, n;
  
      name = _XlcFileName(lcd, "locale");
***************
*** 1209,1227 ****
      if(name == NULL){
  	return (XPointer)NULL;
      }
-     strcpy(pathname, name);
-     Xfree(name);
  
!     name_q = XrmStringToQuark(pathname);
      for(list = _db_list; list; list = list->next){
  	if(name_q == list->name_q){
  	    list->ref_count++;
  	    return XLC_PUBLIC(lcd, xlocale_db) = (XPointer)list->lc_db;
  	}
      }
  
!     database = CreateDatabase(pathname);
      if(database == (Database)NULL){
  	return (XPointer)NULL;
      }
      n = CountDatabase(database);
--- 1209,1227 ----
      if(name == NULL){
  	return (XPointer)NULL;
      }
  
!     name_q = XrmStringToQuark(name);
      for(list = _db_list; list; list = list->next){
  	if(name_q == list->name_q){
  	    list->ref_count++;
+ 	    Xfree (name);
  	    return XLC_PUBLIC(lcd, xlocale_db) = (XPointer)list->lc_db;
  	}
      }
  
!     database = CreateDatabase(name);
      if(database == (Database)NULL){
+ 	Xfree (name);
  	return (XPointer)NULL;
      }
      n = CountDatabase(database);
***************
*** 1247,1259 ****
      new->next = _db_list;
      _db_list = new;
  
      return XLC_PUBLIC(lcd, xlocale_db) = (XPointer)lc_db;
  
!  err:;
      DestroyDatabase(database);
      if(lc_db != (XlcDatabase)NULL){
  	Xfree((char *)lc_db);
      }
      return (XPointer)NULL;
  }
  
--- 1247,1261 ----
      new->next = _db_list;
      _db_list = new;
  
+     Xfree (name);
      return XLC_PUBLIC(lcd, xlocale_db) = (XPointer)lc_db;
  
!  err:
      DestroyDatabase(database);
      if(lc_db != (XlcDatabase)NULL){
  	Xfree((char *)lc_db);
      }
+     Xfree (name);
      return (XPointer)NULL;
  }
  
*** xc/lib/X11/lcFile.c@@/PUBLIC-LATEST	Sat Sep 28 16:46:16 1996
--- xc/lib/X11/lcFile.c	Tue Jun  3 15:51:35 1997
***************
*** 1,4 ****
! /* $XConsortium: lcFile.c /main/6 1996/09/28 16:37:56 rws $ */
  /*
   *
   * Copyright IBM Corporation 1993
--- 1,4 ----
! /* $TOG: lcFile.c /main/9 1997/06/03 15:52:47 kaleb $ */
  /*
   *
   * Copyright IBM Corporation 1993
***************
*** 36,45 ****
  
  #define	iscomment(ch)	((ch) == '#' || (ch) == '\0')
  #define isreadable(f)	((access((f), R_OK) != -1) ? 1 : 0)
- /*
- #define	isspace(ch)	((ch) == ' ' || (ch) == '\t' || (ch) == '\n')
- */
  
  static int
  parse_line(line, argv, argsize)
      char *line;
--- 36,70 ----
  
  #define	iscomment(ch)	((ch) == '#' || (ch) == '\0')
  #define isreadable(f)	((access((f), R_OK) != -1) ? 1 : 0)
  
+ #define XLC_BUFSIZE 256
+ 
+ #ifndef X_NOT_POSIX
+ #ifdef _POSIX_SOURCE
+ #include <limits.h>
+ #else
+ #define _POSIX_SOURCE
+ #include <limits.h>
+ #undef _POSIX_SOURCE
+ #endif
+ #endif
+ #ifndef PATH_MAX
+ #ifdef WIN32
+ #define PATH_MAX 512
+ #else
+ #include <sys/param.h>
+ #endif
+ #ifndef PATH_MAX
+ #ifdef MAXPATHLEN
+ #define PATH_MAX MAXPATHLEN
+ #else
+ #define PATH_MAX 1024
+ #endif
+ #endif
+ #endif
+ 
+ #define NUM_LOCALEDIR	64
+ 
  static int
  parse_line(line, argv, argsize)
      char *line;
***************
*** 69,74 ****
--- 94,100 ----
      return argc;
  }
  
+ /* parse the colon separated list in path into argv */
  int
  _XlcParsePath(path, argv, argsize)
      char *path;
***************
*** 126,138 ****
  enum { LtoR, RtoL };
  
  static char *
! _XlcResolveName(lc_name, file_name, direction)
      char *lc_name;
      char *file_name;
      int direction;	/* mapping direction */
  {
      FILE *fp;
!     char buf[BUFSIZE], *name = NULL;
  
      fp = fopen(file_name, "r");
      if(fp == (FILE *)NULL){
--- 152,164 ----
  enum { LtoR, RtoL };
  
  static char *
! resolve_name(lc_name, file_name, direction)
      char *lc_name;
      char *file_name;
      int direction;	/* mapping direction */
  {
      FILE *fp;
!     char buf[XLC_BUFSIZE], *name = NULL;
  
      fp = fopen(file_name, "r");
      if(fp == (FILE *)NULL){
***************
*** 139,145 ****
  	return NULL;
      }
  
!     while(fgets(buf, BUFSIZE, fp) != NULL){
  	char *p = buf;
  	int n;
  	char *args[2], *from, *to;
--- 165,171 ----
  	return NULL;
      }
  
!     while(fgets(buf, XLC_BUFSIZE, fp) != NULL){
  	char *p = buf;
  	int n;
  	char *args[2], *from, *to;
***************
*** 196,205 ****
      XLCd lcd;
      char *category;
  {
!     char lc_name[BUFSIZE];
!     char cat[BUFSIZE], dir[BUFSIZE];
      int i, n;
!     char *args[256];
      char *file_name = NULL;
  
      if(lcd == (XLCd)NULL){
--- 222,231 ----
      XLCd lcd;
      char *category;
  {
!     char *siname;
!     char cat[XLC_BUFSIZE], dir[XLC_BUFSIZE];
      int i, n;
!     char *args[NUM_LOCALEDIR];
      char *file_name = NULL;
  
      if(lcd == (XLCd)NULL){
***************
*** 206,227 ****
  	return NULL;
      }
  
!     if(! _XlcResolveLocaleName(XLC_PUBLIC(lcd, siname), lc_name,
! 			       NULL, NULL, NULL)){
! 	return NULL;
!     }
  
      lowercase(cat, category);
!     xlocaledir(dir,BUFSIZE);
!     n = _XlcParsePath(dir, args, 256);
      for(i = 0; i < n; ++i){
! 	char buf[BUFSIZE], *name;
  
  	name = NULL;
  	if ((5 + (args[i] ? strlen (args[i]) : 0) +
! 	    (cat ? strlen (cat) : 0)) < BUFSIZE) {
  	    sprintf(buf, "%s/%s.dir", args[i], cat);
! 	    name = _XlcResolveName(lc_name, buf, RtoL);
  	}
  	if(name == NULL){
  	    continue;
--- 232,250 ----
  	return NULL;
      }
  
!     siname = XLC_PUBLIC(lcd, siname);
  
      lowercase(cat, category);
!     xlocaledir(dir,XLC_BUFSIZE);
!     n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
      for(i = 0; i < n; ++i){
! 	char buf[PATH_MAX], *name;
  
  	name = NULL;
  	if ((5 + (args[i] ? strlen (args[i]) : 0) +
! 	    (cat ? strlen (cat) : 0)) < PATH_MAX) {
  	    sprintf(buf, "%s/%s.dir", args[i], cat);
! 	    name = resolve_name(siname, buf, RtoL);
  	}
  	if(name == NULL){
  	    continue;
***************
*** 252,276 ****
  #endif
  
  int
! _XlcResolveLocaleName(lc_name, full_name, language, territory, codeset)
!     char *lc_name;
!     char *full_name;
!     char *language;
!     char *territory;
!     char *codeset;
  {
!     char dir[BUFSIZE], buf[BUFSIZE], *name = NULL;
!     int i, n;
!     char *args[256];
      static char locale_alias[] = LOCALE_ALIAS;
  
!     xlocaledir(dir,BUFSIZE);
!     n = _XlcParsePath(dir, args, 256);
      for(i = 0; i < n; ++i){
  	if ((2 + (args[i] ? strlen (args[i]) : 0) + 
! 	    strlen (locale_alias)) < BUFSIZE) {
! 	    sprintf(buf, "%s/%s", args[i], locale_alias);
! 	    name = _XlcResolveName(lc_name, buf, LtoR);
  	}
  	if(name != NULL){
  	    break;
--- 275,297 ----
  #endif
  
  int
! _XlcResolveLocaleName(lc_name, pub)
!     char* lc_name;
!     XLCdPublicPart* pub;
  {
!     char dir[PATH_MAX], buf[PATH_MAX], *name = NULL;
!     char *dst;
!     int i, n, len, sinamelen;
!     char *args[NUM_LOCALEDIR];
      static char locale_alias[] = LOCALE_ALIAS;
  
!     xlocaledir (dir, PATH_MAX);
!     n = _XlcParsePath(dir, args, NUM_LOCALEDIR);
      for(i = 0; i < n; ++i){
  	if ((2 + (args[i] ? strlen (args[i]) : 0) + 
! 	    strlen (locale_alias)) < PATH_MAX) {
! 	    sprintf (buf, "%s/%s", args[i], locale_alias);
! 	    name = resolve_name (lc_name, buf, LtoR);
  	}
  	if(name != NULL){
  	    break;
***************
*** 277,361 ****
  	}
      }
  
!     if(name != NULL){
! 	strcpy(buf, name);
! 	Xfree(name);
!     }else{
! 	strcpy(buf, lc_name);
      }
-     if(full_name != NULL){
- 	strcpy(full_name, buf);
-     }
  
!     if(language || territory || codeset){
! 	char *ptr, *name_p;
! 	/*
! 	 * Decompose locale name
! 	 */
! 	if(language) *language = '\0';
! 	if(territory) *territory = '\0';
! 	if(codeset) *codeset = '\0';
! 
! 	name_p = buf;
! 	ptr = language;
! 	while (1) {
! 	    if (*name_p == '_') {
! 		if (ptr)
! 		    *ptr = '\0';
! 		ptr = territory;
! 	    } else if (*name_p == '.') {
! 		if (ptr)
! 		    *ptr = '\0';
! 		ptr = codeset;
! 	    } else {
! 		if (ptr)
! 		    *ptr++ = *name_p;
! 		if (*name_p == '\0')
! 		    break;
! 	    }
! 	    name_p++;
! 	}
      }
  
!     return (buf[0] != '\0') ? 1 : 0;
! }
  
! /************************************************************************/
! #ifndef	LOCALE_DIR
! #define	LOCALE_DIR	"locale.dir"
! #endif
  
! int
! _XlcResolveDBName(lc_name, file_name)
!     char *lc_name;
!     char *file_name;
! {
!     char dir[BUFSIZE], buf[BUFSIZE], *name = NULL;
!     int i, n;
!     char *args[256];
!     static char locale_dir[] = LOCALE_DIR;
  
!     xlocaledir(dir,BUFSIZE);
!     n = _XlcParsePath(dir, args, 256);
!     for(i = 0; i < n; ++i){
! 	if ((2 + (args[i] ? strlen (args[i]) : 0) + 
! 	    strlen (locale_dir)) < BUFSIZE) {
! 	    sprintf(buf, "%s/%s", args[i], locale_dir);
! 	    name = _XlcResolveName(lc_name, buf, RtoL);
! 	}
! 	if(name != NULL){
! 	    break;
! 	}
      }
!     if(name == NULL){
! 	return 0;
!     }
!     strcpy(buf, name);
!     Xfree(name);
!     if(file_name != NULL){
! 	strcpy(file_name, buf);
!     }
!     return 1;
  }
  
  /************************************************************************/
--- 298,344 ----
  	}
      }
  
!     if (name == NULL) {
! 	/* vendor locale name == Xlocale name, no expansion of alias */
! 	pub->siname = Xmalloc (strlen (lc_name) + 1);
! 	strcpy (pub->siname, lc_name);
!     } else {
! 	pub->siname = name;
      }
  
!     sinamelen = strlen (pub->siname);
!     if (sinamelen == 1 && pub->siname[0] == 'C') {
! 	pub->language = pub->siname;
! 	pub->territory = pub->codeset = NULL;
! 	return 1;
      }
  
!     /* 
!      * pub->siname is in the format <lang>_<terr>.<codeset>, typical would
!      * be "en_US.ISO8859-1", "en_US.utf8", or "ru_RU.KOI-8"
!      */
!     pub->siname = Xrealloc (pub->siname, 2 * (sinamelen + 1));
  
!     /* language */
!     dst = &pub->siname[sinamelen + 1];
!     strcpy (dst, pub->siname);
!     pub->language = dst;
  
!     /* territory */
!     dst = strchr (dst, '_');
!     if (dst) {
! 	*dst = '\0';
! 	pub->territory = ++dst;
!     }
  
!     /* codeset */
!     dst = strchr (dst, '.');
!     if (dst) {
! 	*dst = '\0';
! 	pub->codeset = ++dst;
      }
! 
!     return (pub->siname[0] != '\0') ? 1 : 0;
  }
  
  /************************************************************************/
*** xc/lib/X11/lcGenConv.c@@/PUBLIC-LATEST	Thu Dec  5 10:40:30 1996
--- xc/lib/X11/lcGenConv.c	Tue May 20 15:07:51 1997
***************
*** 1,4 ****
! /* $XConsortium: lcGenConv.c /main/14 1996/12/05 10:40:27 swick $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: lcGenConv.c /main/15 1997/05/20 15:19:59 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 1313,1318 ****
--- 1313,1329 ----
  			inbufptr - 1, &state->charset, &ctr_seq_len) )
  		goto skip_the_seg;
  
+ 	    if (state->charset->side == XlcC0 || 
+ 		state->charset->side == XlcGL)
+ 	      {
+ 		state->GL_charset = state->charset;
+ 	      }
+ 	    else if (state->charset->side == XlcC1 || 
+ 		     state->charset->side == XlcGR)
+ 	      {
+ 		state->GR_charset = state->charset;
+ 	      }	
+ 
  	    if (*from_left < ctr_seq_len) {
  		inbufptr--;
  		(*from_left)++;
***************
*** 1327,1348 ****
              continue;
          } 
  
! 	/* check current state */
!         if (state->charset) {
! 	    if (state->charset->side == XlcC0 || 
! 			state->charset->side == XlcGL) {
! 		state->GL_charset = state->charset;
! 
!             } else if (state->charset->side == XlcC1 || 
! 		     	state->charset->side == XlcGR) {
! 		state->GR_charset = state->charset;
! 	    }	
! 	} else {
!             if (isleftside(ch))
! 	        state->charset = state->GL_charset;
!             else
! 	        state->charset = state->GR_charset;
!         }
  
  	gi_len = gi_len_left = state->charset->char_size;
  	glyph_index = 0;
--- 1338,1348 ----
              continue;
          } 
  
!  	/* check current state */
! 	if (isleftside(ch))
! 	  state->charset = state->GL_charset;
! 	else
! 	  state->charset = state->GR_charset;
  
  	gi_len = gi_len_left = state->charset->char_size;
  	glyph_index = 0;
*** xc/lib/X11/lcPublic.c@@/PUBLIC-LATEST	Fri Jan  5 11:23:43 1996
--- xc/lib/X11/lcPublic.c	Tue Jun  3 15:51:40 1997
***************
*** 1,4 ****
! /* $XConsortium: lcPublic.c /main/6 1996/01/05 11:22:44 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: lcPublic.c /main/8 1997/06/03 15:52:52 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 188,194 ****
      XLCdPublicMethodsPart *methods = XLC_PUBLIC_METHODS(lcd);
      XLCdPublicMethodsPart *pub_methods = &publicMethods.pub;
      XLCdPublicPart *pub = XLC_PUBLIC_PART(lcd);
-     char lang[128], terr[128], code[128], *str;
      char *name;
  #if !defined(X_NOT_STDC_ENV) && !defined(X_LOCALE)
      char siname[256];
--- 188,193 ----
***************
*** 205,232 ****
      name = _XlcMapOSLocaleName(name, siname);
  #endif
  	
!     if (_XlcResolveLocaleName(name, NULL, lang, terr, code) == 0)
  	return False;
- 
-     str = (char*) Xmalloc(strlen(name) + strlen(lang) + strlen(terr) +
- 			  strlen(code) + 4);
-     if (str == NULL)
- 	return False;
- 
-     strcpy(str, name);
-     pub->siname = str;
-     str += strlen(str) + 1;
- 
-     strcpy(str, lang);
-     pub->language = str;
-     str += strlen(str) + 1;
- 
-     strcpy(str, terr);
-     pub->territory = str;
-     str += strlen(str) + 1;
- 
-     strcpy(str, code);
-     pub->codeset = str;
  
      if (pub->default_string == NULL)
  	pub->default_string = "";
--- 204,211 ----
      name = _XlcMapOSLocaleName(name, siname);
  #endif
  	
!     if (_XlcResolveLocaleName(name, pub) == 0)
  	return False;
  
      if (pub->default_string == NULL)
  	pub->default_string = "";
*** xc/lib/X11/lcWrap.c@@/PUBLIC-LATEST	Sat Dec  9 12:03:58 1995
--- xc/lib/X11/lcWrap.c	Mon Jun  2 17:26:52 1997
***************
*** 1,4 ****
! /* $XConsortium: lcWrap.c /main/24 1995/12/09 12:03:14 gildea $ */
  /*
  
  Copyright (c) 1991  X Consortium
--- 1,4 ----
! /* $TOG: lcWrap.c /main/25 1997/06/02 17:28:04 kaleb $ */
  /*
  
  Copyright (c) 1991  X Consortium
*** xc/lib/X11/omDefault.c@@/PUBLIC-LATEST	Thu Dec  5 11:10:51 1996
--- xc/lib/X11/omDefault.c	Sun Jun 22 15:54:38 1997
***************
*** 1,4 ****
! /* $XConsortium: omDefault.c /main/5 1996/12/05 11:10:58 swick $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: omDefault.c /main/6 1997/06/22 15:53:43 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 200,211 ****
      XCharStruct *def, *cs, overall;
      Bool first = True;
  
-     *num_chars = length;
- 
      if (buf_size < length)
  	return 0;
  
      bzero((char *) &overall, sizeof(XCharStruct));
  
      CI_GET_DEFAULT_INFO_1D(font, def)
  
--- 200,210 ----
      XCharStruct *def, *cs, overall;
      Bool first = True;
  
      if (buf_size < length)
  	return 0;
  
      bzero((char *) &overall, sizeof(XCharStruct));
+     *num_chars = 0;
  
      CI_GET_DEFAULT_INFO_1D(font, def)
  
***************
*** 239,244 ****
--- 238,245 ----
  				   cs->rbearing);
  	    overall.width += cs->width;
  	}
+ 
+ 	(*num_chars)++;
      }
  
      if (overall_ink) {
*** xc/lib/X11/omGeneric.c@@/PUBLIC-LATEST	Thu Dec  5 10:40:43 1996
--- xc/lib/X11/omGeneric.c	Sat Jun 21 20:56:26 1997
***************
*** 1,4 ****
! /* $XConsortium: omGeneric.c /main/20 1996/12/05 10:40:40 swick $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $TOG: omGeneric.c /main/21 1997/06/21 20:56:05 kaleb $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 194,287 ****
      return (char *) NULL;
  }
  
- static FontData
- check_charset(font_set, font_name)
-     FontSet font_set;
-     char *font_name;
- {
-     FontData font_data;
-     char *last;
-     int count, length, name_len;
- 
-     name_len = strlen(font_name);
-     last = font_name + name_len;
- 
-     count = font_set->font_data_count;
-     font_data = font_set->font_data;
-     for ( ; count-- > 0; font_data++) {
- 	length = strlen(font_data->name);
- 	if (length > name_len)
- 	    continue;
- 	
- 	if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
- 	    return font_data;
-     }
- 
-     return (FontData) NULL;
- }
- 
- static int
- check_fontname(oc, name, found_num)
-     XOC oc;
-     char *name;
-     int found_num;
- {
-     Display *dpy = oc->core.om->core.display;
-     XOCGenericPart *gen = XOC_GENERIC(oc);
-     FontData data;
-     FontSet font_set;
-     XFontStruct *fs_list;
-     char **fn_list, *fname, *prop_fname = NULL;
-     int list_num, font_set_num, i;
-     int list2_num;
-     char **fn2_list = NULL;
- 
-     fn_list = XListFonts(dpy, name, MAXFONTS, &list_num);
-     if (fn_list == NULL)
- 	return found_num;
- 
-     for (i = 0; i < list_num; i++) {
- 	fname = fn_list[i];
- 
- 	font_set = gen->font_set;
- 	font_set_num = gen->font_set_num;
- 
- 	for ( ; font_set_num-- > 0; font_set++) {
- 	    if (font_set->font_name)
- 		continue;
- 
- 	    if ((data = check_charset(font_set, fname)) == NULL) {
- 		if ((fn2_list = XListFontsWithInfo(dpy, name, MAXFONTS,
- 					      &list2_num, &fs_list))
- 		    && (prop_fname = get_prop_name(dpy, fs_list))
- 		    && (data = check_charset(font_set, prop_fname)))
- 		    fname = prop_fname;
- 	    }
- 	    if (data) {
- 		font_set->side = data->side;
- 		font_set->font_name = (char *) Xmalloc(strlen(fname) + 1);
- 		if (font_set->font_name) {
- 		    strcpy(font_set->font_name, fname);
- 		    found_num++;
- 		}
- 	    }
- 	    if (fn2_list) {
- 		XFreeFontInfo(fn2_list, fs_list, list2_num);
- 		fn2_list = NULL;
- 		if (prop_fname) {
- 		    Xfree(prop_fname);
- 		    prop_fname = NULL;
- 		}
- 	    }
- 	    if (found_num == gen->font_set_num)
- 		break;
- 	}
-     }
-     XFreeFontNames(fn_list);
-     return found_num;
- }
- 
- 
  /* For VW/UDC start */
  
  static Bool
--- 194,199 ----
***************
*** 991,997 ****
      return True;
  }
  
! /* static */ int
  parse_fontname(oc)
      XOC oc;
  {
--- 903,909 ----
      return True;
  }
  
! static int
  parse_fontname(oc)
      XOC oc;
  {
*** xc/lib/Xext/Imakefile@@/PUBLIC-LATEST	Sat Sep 28 16:52:06 1996
--- xc/lib/Xext/Imakefile	Sun Jun  8 20:40:29 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/57 1996/09/28 16:43:46 rws $
  #define DoNormalLib NormalLibXext
  #define DoSharedLib SharedLibXext
  #define DoDebugLib DebugLibXext
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/58 1997/06/08 20:52:39 kaleb $
  #define DoNormalLib NormalLibXext
  #define DoSharedLib SharedLibXext
  #define DoDebugLib DebugLibXext
***************
*** 18,39 ****
        SHMOBJS = XShm.o
  #endif
  
- #if BuildLBX
-       LBXSRCS = XLbx.c
-       LBXOBJS = XLbx.o
- #endif
- 
  #if Malloc0ReturnsNull
! ALLOC_DEFINES = -DMALLOC_0_RETURNS_NULL
  #endif
  
        DEFINES = $(ALLOC_DEFINES)
       INCLUDES = -I$(XLIBSRC) -I$(EXTINCSRC)
           SRCS = globals.c extutil.c XMultibuf.c XShape.c $(SHMSRCS)  \
! 		MITMisc.c XTestExt1.c XSync.c Xdbe.c $(LBXSRCS) \
  		XSecurity.c XAppgroup.c
           OBJS = globals.o extutil.o XMultibuf.o XShape.o $(SHMOBJS) \
! 		MITMisc.o XTestExt1.o XSync.o Xdbe.o $(LBXOBJS) \
  		XSecurity.o XAppgroup.o
       LINTLIBS = $(LINTXLIB)
  
--- 18,34 ----
        SHMOBJS = XShm.o
  #endif
  
  #if Malloc0ReturnsNull
! ALLOC_DEFINES = Malloc0ReturnsNullDefines
  #endif
  
        DEFINES = $(ALLOC_DEFINES)
       INCLUDES = -I$(XLIBSRC) -I$(EXTINCSRC)
           SRCS = globals.c extutil.c XMultibuf.c XShape.c $(SHMSRCS)  \
! 		MITMisc.c XTestExt1.c XSync.c Xdbe.c XLbx.c \
  		XSecurity.c XAppgroup.c
           OBJS = globals.o extutil.o XMultibuf.o XShape.o $(SHMOBJS) \
! 		MITMisc.o XTestExt1.o XSync.o Xdbe.o XLbx.o \
  		XSecurity.o XAppgroup.o
       LINTLIBS = $(LINTXLIB)
  
*** xc/lib/Xext/Xext-def.cpp@@/PUBLIC-LATEST	Wed Nov 13 14:48:25 1996
--- xc/lib/Xext/Xext-def.cpp	Sun Jun  8 20:55:49 1997
***************
*** 89,92 ****
   XSecurityFreeXauth
   XSecurityGenerateAuthorization
   XSecurityRevokeAuthorization
! /* $XConsortium: Xext-def.cpp /main/6 1996/11/13 14:44:36 lehors $ */
--- 89,100 ----
   XSecurityFreeXauth
   XSecurityGenerateAuthorization
   XSecurityRevokeAuthorization
!  XagQueryVersion
!  XagCreateAssociation
!  XagCreateEmbeddedApplicationGroup
!  XagCreateNonembeddedApplicationGroup
!  XagDestroyApplicationGroup
!  XagDestroyAssociation
!  XagGetApplicationGroupAttributes
!  XagQueryApplicationGroup
! /* $TOG: Xext-def.cpp /main/7 1997/06/08 21:07:33 kaleb $ */
*** xc/lib/Xi/XExtInt.c@@/PUBLIC-LATEST	Sun Apr 17 20:17:59 1994
--- xc/lib/Xi/XExtInt.c	Fri Apr  4 10:10:56 1997
***************
*** 1,4 ****
! /* $XConsortium: XExtInt.c,v 1.35 94/04/17 20:17:59 rws Exp $ */
  
  /************************************************************
  
--- 1,4 ----
! /* $TOG: XExtInt.c /main/32 1997/04/04 10:06:55 barstow $ */
  
  /************************************************************
  
***************
*** 100,105 ****
--- 100,106 ----
  	"BadDevice, invalid or uninitialized input device", /* BadDevice */
  	"BadEvent, invalid event type",			    /* BadEvent	*/	
  	"BadMode, invalid mode parameter",		    /* BadMode	*/
+ 	"DeviceBusy, device is busy",			    /* DeviceBusy */
  	"BadClass, invalid event class",		    /* BadClass	*/	
  };
  
*** xc/lib/Xp/XpContext.c@@/PUBLIC-LATEST	Sat Nov 16 15:32:26 1996
--- xc/lib/Xp/XpContext.c	Wed May 28 11:29:40 1997
***************
*** 1,4 ****
! /* $XConsortium: XpContext.c /main/2 1996/11/16 15:20:54 rws $ */
  /******************************************************************************
   ******************************************************************************
   **
--- 1,4 ----
! /* $TOG: XpContext.c /main/3 1997/05/28 11:41:13 kaleb $ */
  /******************************************************************************
   ******************************************************************************
   **
***************
*** 40,47 ****
  #include "Printstr.h"
  #include "Xlibint.h"
  #include "extutil.h"
- 
- #include <locale.h>
  
  #define _XpPadOut(len) (((len) + 3) & ~3)
  
--- 40,45 ----
*** xc/lib/Xp/XpLocale.c@@/PUBLIC-LATEST	Sat Nov 16 15:33:08 1996
--- xc/lib/Xp/XpLocale.c	Wed May 28 11:30:48 1997
***************
*** 1,4 ****
! /* $XConsortium: XpLocale.c /main/2 1996/11/16 15:21:36 rws $ */
  /******************************************************************************
   ******************************************************************************
   **
--- 1,4 ----
! /* $TOG: XpLocale.c /main/3 1997/05/28 11:41:34 kaleb $ */
  /******************************************************************************
   ******************************************************************************
   **
***************
*** 39,45 ****
  #include "Xlibint.h"
  #include "extutil.h"
  
! #include <locale.h>
  
  
  /*
--- 39,45 ----
  #include "Xlibint.h"
  #include "extutil.h"
  
! #include <X11/Xlocale.h>
  
  
  /*
*** xc/lib/Xp/XpNotifyPdm.c@@/PUBLIC-LATEST	Sat Nov 16 15:33:13 1996
--- xc/lib/Xp/XpNotifyPdm.c	Wed May 28 11:31:00 1997
***************
*** 1,4 ****
! /* $XConsortium: XpNotifyPdm.c /main/3 1996/11/16 15:21:41 rws $ */
  /******************************************************************************
   ******************************************************************************
   **
--- 1,4 ----
! /* $TOG: XpNotifyPdm.c /main/4 1997/05/28 11:41:41 kaleb $ */
  /******************************************************************************
   ******************************************************************************
   **
***************
*** 48,54 ****
  #include "X11/Xatom.h"
  #include "X11/Xauth.h"
  #include <stdlib.h>
- #include <locale.h>
  #include <X11/Xos.h>
  
  /*
--- 48,53 ----
*** xc/lib/Xp/XpPrinter.c@@/PUBLIC-LATEST	Fri Dec 27 16:29:11 1996
--- xc/lib/Xp/XpPrinter.c	Wed May 28 11:31:05 1997
***************
*** 1,4 ****
! /* $XConsortium: XpPrinter.c /main/3 1996/12/27 16:21:53 kaleb $ */
  /******************************************************************************
   ******************************************************************************
   **
--- 1,4 ----
! /* $TOG: XpPrinter.c /main/4 1997/05/28 11:41:47 kaleb $ */
  /******************************************************************************
   ******************************************************************************
   **
***************
*** 40,47 ****
  #include "Printstr.h"
  #include "Xlibint.h"
  #include "extutil.h"
- 
- #include <locale.h>
  
  #define _XpPadOut(len) (((len) + 3) & ~3)
  
--- 40,45 ----
*** xc/lib/Xt/Alloc.c@@/PUBLIC-LATEST	Mon Oct 10 18:57:48 1994
--- xc/lib/Xt/Alloc.c	Tue May 20 10:03:12 1997
***************
*** 1,4 ****
! /* $XConsortium: Alloc.c,v 1.55 94/10/10 18:57:48 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Alloc.c /main/47 1997/05/20 10:06:27 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 75,89 ****
  char *malloc(), *realloc(), *calloc();
  #endif
  
- #ifdef MALLOC_0_RETURNS_NULL
- #define Xmalloc(size) malloc(((size) > 0 ? (size) : 1))
- #define Xrealloc(ptr, size) realloc((ptr), ((size) > 0 ? (size) : 1))
- #define Xcalloc(nelem, elsize) calloc(((nelem) > 0 ? (nelem) : 1), (elsize))
- #else
  #define Xmalloc(size) malloc((size))
  #define Xrealloc(ptr, size) realloc((ptr), (size))
  #define Xcalloc(nelem, elsize) calloc((nelem), (elsize))
- #endif
  #define Xfree(ptr) free(ptr)
  
  #ifdef _XNEEDBCOPYFUNC
--- 75,83 ----
***************
*** 125,130 ****
--- 119,129 ----
      unsigned size;
  {
      char *ptr;
+ 
+ #if defined (MALLOC_0_RETURNS_NULL) && defined(XTMALLOC_BC)
+     /* preserve this (broken) behavior until everyone fixes their apps */
+     if (!size) size = 1;
+ #endif
      if ((ptr = Xmalloc(size)) == NULL)
          _XtAllocError("malloc");
  
***************
*** 135,142 ****
      char     *ptr;
      unsigned size;
  {
!    if (ptr == NULL) return(XtMalloc(size));
!    else if ((ptr = Xrealloc(ptr, size)) == NULL)
  	_XtAllocError("realloc");
  
     return(ptr);
--- 134,149 ----
      char     *ptr;
      unsigned size;
  {
!    if (ptr == NULL) {
! #if MALLOC_0_RETURNS_NULL
! 	if (!size) size = 1;
! #endif
! 	return(XtMalloc(size));
!    } else if ((ptr = Xrealloc(ptr, size)) == NULL
! #if MALLOC_0_RETURNS_NULL
! 		&& size
! #endif
! 	)
  	_XtAllocError("realloc");
  
     return(ptr);
***************
*** 147,155 ****
  {
      char *ptr;
  
! #ifdef MALLOC_0_RETURNS_NULL
!     if (!size)
! 	num = size = 1;
  #endif
      if ((ptr = Xcalloc(num, size)) == NULL)
  	_XtAllocError("calloc");
--- 154,162 ----
  {
      char *ptr;
  
! #if defined (MALLOC_0_RETURNS_NULL) && defined(XTMALLOC_BC)
!     /* preserve this (broken) behavior until everyone fixes their apps */
!     if (!size) num = size = 1;
  #endif
      if ((ptr = Xcalloc(num, size)) == NULL)
  	_XtAllocError("calloc");
***************
*** 160,166 ****
  void XtFree(ptr)
      char *ptr;
  {
!    if (ptr != NULL) Xfree(ptr);
  }
  
  #ifndef HEAP_SEGMENT_SIZE
--- 167,191 ----
  void XtFree(ptr)
      char *ptr;
  {
!     if (ptr != NULL) Xfree(ptr);
! }
! 
! char* __XtMalloc(size)
!     unsigned size;
! {
! #ifdef MALLOC_0_RETURNS_NULL
!     if (!size) size = 1;
! #endif
!     return XtMalloc (size);
! }
! 
! char* __XtCalloc(num, size)
!     unsigned num, size;
! {
! #ifdef MALLOC_0_RETURNS_NULL
!     if (!size) num = size = 1;
! #endif
!     return XtCalloc(num, size);
  }
  
  #ifndef HEAP_SEGMENT_SIZE
*** xc/lib/Xt/ArgList.c@@/PUBLIC-LATEST	Sun Apr 17 20:13:37 1994
--- xc/lib/Xt/ArgList.c	Thu May 15 17:24:54 1997
***************
*** 1,4 ****
! /* $XConsortium: ArgList.c,v 1.21 94/04/17 20:13:37 gildea Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $TOG: ArgList.c /main/17 1997/05/15 17:28:09 kaleb $ */
  
  /***********************************************************
  
***************
*** 63,69 ****
  {
      ArgList result, args;
  
!     result = (ArgList) XtCalloc((unsigned) num_args1 + num_args2,
  				(unsigned) sizeof(Arg));
  
      for (args = result; num_args1 != 0; num_args1--)
--- 63,69 ----
  {
      ArgList result, args;
  
!     result = (ArgList) __XtCalloc((unsigned) num_args1 + num_args2,
  				(unsigned) sizeof(Arg));
  
      for (args = result; num_args1 != 0; num_args1--)
*** xc/lib/Xt/Callback.c@@/PUBLIC-LATEST	Sun Apr 17 20:13:38 1994
--- xc/lib/Xt/Callback.c	Thu May 15 17:25:00 1997
***************
*** 1,4 ****
! /* $XConsortium: Callback.c,v 1.45 94/04/17 20:13:38 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Callback.c /main/46 1997/05/15 17:28:16 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 111,117 ****
      if (icl && icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
  	icl = (InternalCallbackList)
! 	    XtMalloc(sizeof(InternalCallbackRec) +
  		     sizeof(XtCallbackRec) * (count + 1));
  	(void) memmove((char *)ToList(icl), (char *)ToList(*callbacks),
  		       sizeof(XtCallbackRec) * count);
--- 111,117 ----
      if (icl && icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
  	icl = (InternalCallbackList)
! 	    __XtMalloc(sizeof(InternalCallbackRec) +
  		     sizeof(XtCallbackRec) * (count + 1));
  	(void) memmove((char *)ToList(icl), (char *)ToList(*callbacks),
  		       sizeof(XtCallbackRec) * count);
***************
*** 205,211 ****
      for (j=0, cl = newcallbacks; cl->callback; cl++, j++);
      if (icl && icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
! 	icl = (InternalCallbackList) XtMalloc(sizeof(InternalCallbackRec) +
  					      sizeof(XtCallbackRec) * (i+j));
  	(void) memmove((char *)ToList(*callbacks), (char *)ToList(icl), 
  		       sizeof(XtCallbackRec) * i);
--- 205,211 ----
      for (j=0, cl = newcallbacks; cl->callback; cl++, j++);
      if (icl && icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
! 	icl = (InternalCallbackList) __XtMalloc(sizeof(InternalCallbackRec) +
  					      sizeof(XtCallbackRec) * (i+j));
  	(void) memmove((char *)ToList(*callbacks), (char *)ToList(icl), 
  		       sizeof(XtCallbackRec) * i);
***************
*** 288,294 ****
  		    j = icl->count - i - 1;
  		    ocl = ToList(icl);
  		    icl = (InternalCallbackList)
! 			XtMalloc(sizeof(InternalCallbackRec) +
  				 sizeof(XtCallbackRec) * (i + j));
  		    icl->count = i + j;
  		    icl->is_padded = 0;
--- 288,294 ----
  		    j = icl->count - i - 1;
  		    ocl = ToList(icl);
  		    icl = (InternalCallbackList)
! 			__XtMalloc(sizeof(InternalCallbackRec) +
  				 sizeof(XtCallbackRec) * (i + j));
  		    icl->count = i + j;
  		    icl->is_padded = 0;
***************
*** 405,411 ****
      cl = ToList(icl);
      if (icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
! 	icl = (InternalCallbackList)XtMalloc(sizeof(InternalCallbackRec) +
  					     sizeof(XtCallbackRec) * i);
  	icl->count = i;
  	icl->call_state = 0;
--- 405,411 ----
      cl = ToList(icl);
      if (icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
! 	icl = (InternalCallbackList)__XtMalloc(sizeof(InternalCallbackRec) +
  					     sizeof(XtCallbackRec) * i);
  	icl->count = i;
  	icl->call_state = 0;
***************
*** 510,516 ****
      for (n=0, xtcl=xtcallbacks; xtcl->callback; n++, xtcl++) {};
      if (n == 0) return (InternalCallbackList) NULL;
  
!     callbacks = (InternalCallbackList) XtMalloc(sizeof(InternalCallbackRec) +
  						sizeof(XtCallbackRec) * n);
      callbacks->count = n;
      callbacks->is_padded = 0;
--- 510,516 ----
      for (n=0, xtcl=xtcallbacks; xtcl->callback; n++, xtcl++) {};
      if (n == 0) return (InternalCallbackList) NULL;
  
!     callbacks = (InternalCallbackList) __XtMalloc(sizeof(InternalCallbackRec) +
  						sizeof(XtCallbackRec) * n);
      callbacks->count = n;
      callbacks->is_padded = 0;
***************
*** 540,546 ****
      if (icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
  	ocl = ToList(icl);
! 	icl = (InternalCallbackList) XtMalloc(sizeof(InternalCallbackRec) +
  					      sizeof(XtCallbackRec) * (i+1));
  	icl->count = i;
  	icl->call_state = 0;
--- 540,546 ----
      if (icl->call_state) {
  	icl->call_state |= _XtCBFreeAfterCalling;
  	ocl = ToList(icl);
! 	icl = (InternalCallbackList) __XtMalloc(sizeof(InternalCallbackRec) +
  					      sizeof(XtCallbackRec) * (i+1));
  	icl->count = i;
  	icl->call_state = 0;
*** xc/lib/Xt/Composite.c@@/PUBLIC-LATEST	Sun Apr 17 20:13:41 1994
--- xc/lib/Xt/Composite.c	Thu May 15 17:25:08 1997
***************
*** 1,4 ****
! /* $XConsortium: Composite.c,v 1.23 94/04/17 20:13:41 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Composite.c /main/24 1997/05/15 17:28:24 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 150,156 ****
  	super_ext->allows_change_managed_set) {
  
  	new_ext = (CompositeClassExtension) 
! 	    XtCalloc(1, sizeof(CompositeClassExtensionRec));
  
  	/* Be careful to inherit only what is appropriate */
  	new_ext->next_extension = cc->composite_class.extension;
--- 150,156 ----
  	super_ext->allows_change_managed_set) {
  
  	new_ext = (CompositeClassExtension) 
! 	    __XtCalloc(1, sizeof(CompositeClassExtensionRec));
  
  	/* Be careful to inherit only what is appropriate */
  	new_ext->next_extension = cc->composite_class.extension;
*** xc/lib/Xt/Convert.c@@/PUBLIC-LATEST	Sun Apr 17 20:13:48 1994
--- xc/lib/Xt/Convert.c	Thu May 15 17:25:15 1997
***************
*** 1,4 ****
! /* $XConsortium: Convert.c,v 1.74 94/04/17 20:13:48 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Convert.c /main/75 1997/05/15 17:28:31 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 96,102 ****
      globalConverterTable = _XtGetProcessContext()->globalConverterTable;
  
      *table = (ConverterTable)
! 	XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      _XtAddDefaultConverters(*table);
  
      if (globalConverterTable) {
--- 96,102 ----
      globalConverterTable = _XtGetProcessContext()->globalConverterTable;
  
      *table = (ConverterTable)
! 	__XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      _XtAddDefaultConverters(*table);
  
      if (globalConverterTable) {
***************
*** 209,215 ****
  	XtFree((char *)p);
      }
  
!     p = (ConverterPtr) XtMalloc(sizeof(ConverterRec) +
  				sizeof(XtConvertArgRec) * num_args);
      p->next	    = *pp;
      *pp = p;
--- 209,215 ----
  	XtFree((char *)p);
      }
  
!     p = (ConverterPtr) __XtMalloc(sizeof(ConverterRec) +
  				sizeof(XtConvertArgRec) * num_args);
      p->next	    = *pp;
      *pp = p;
***************
*** 266,272 ****
  
      if (!process->globalConverterTable) {
  	process->globalConverterTable = (ConverterTable)
! 	    XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      }
      _XtTableAddConverter(process->globalConverterTable, from, to,
  			 converter, convert_args,
--- 266,272 ----
  
      if (!process->globalConverterTable) {
  	process->globalConverterTable = (ConverterTable)
! 	    __XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      }
      _XtTableAddConverter(process->globalConverterTable, from, to,
  			 converter, convert_args,
***************
*** 341,347 ****
  
      if (!process->globalConverterTable) {
  	process->globalConverterTable = (ConverterTable)
! 	    XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      }
      _XtTableAddConverter(process->globalConverterTable, from, to,
  			 (XtTypeConverter)converter, convert_args, num_args,
--- 341,347 ----
  
      if (!process->globalConverterTable) {
  	process->globalConverterTable = (ConverterTable)
! 	    __XtCalloc(CONVERTHASHSIZE, (unsigned)sizeof(ConverterPtr));
      }
      _XtTableAddConverter(process->globalConverterTable, from, to,
  			 (XtTypeConverter)converter, convert_args, num_args,
*** xc/lib/Xt/Converters.c@@/PUBLIC-LATEST	Thu Jun  8 23:20:39 1995
--- xc/lib/Xt/Converters.c	Thu May 15 17:25:24 1997
***************
*** 1,4 ****
! /* $XConsortium: Converters.c,v 1.101 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Converters.c /main/102 1997/05/15 17:28:39 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 1616,1622 ****
              (String *)NULL, (Cardinal *)NULL);
  
      src = src_str = fromVal->addr;
!     dst = dst_str = XtMalloc((unsigned) strlen(src) + 1);
      tokens = 0;
  
      while (*src != '\0') {
--- 1616,1622 ----
              (String *)NULL, (Cardinal *)NULL);
  
      src = src_str = fromVal->addr;
!     dst = dst_str = __XtMalloc((unsigned) strlen(src) + 1);
      tokens = 0;
  
      while (*src != '\0') {
***************
*** 1657,1663 ****
  	    dst++;
      }
  
!     ptr = strarray = (String*) XtMalloc((Cardinal)(tokens+1) * sizeof(String));
      src = dst_str;
      while (--tokens >= 0) {
  	*ptr = src;
--- 1657,1663 ----
  	    dst++;
      }
  
!     ptr = strarray = (String*) __XtMalloc((Cardinal)(tokens+1) * sizeof(String));
      src = dst_str;
      while (--tokens >= 0) {
  	*ptr = src;
*** xc/lib/Xt/Create.c@@/PUBLIC-LATEST	Sun Apr 17 20:13:54 1994
--- xc/lib/Xt/Create.c	Thu May 15 17:25:33 1997
***************
*** 1,4 ****
! /* $XConsortium: Create.c,v 1.105 94/04/17 20:13:54 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Create.c /main/81 1997/05/15 17:28:48 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 287,293 ****
  		    wsize = (wsize + sizeof(double) - 1) & ~(sizeof(double)-1);
  	    }
  	}
! 	widget = (Widget) XtMalloc((unsigned)(wsize + csize));
  	widget->core.constraints =
  	    (csize ? (XtPointer)((char *)widget + wsize) : NULL);
      }
--- 287,293 ----
  		    wsize = (wsize + sizeof(double) - 1) & ~(sizeof(double)-1);
  	    }
  	}
! 	widget = (Widget) __XtMalloc((unsigned)(wsize + csize));
  	widget->core.constraints =
  	    (csize ? (XtPointer)((char *)widget + wsize) : NULL);
      }
*** xc/lib/Xt/Display.c@@/PUBLIC-LATEST	Wed Aug 21 11:36:11 1996
--- xc/lib/Xt/Display.c	Thu May 15 17:25:41 1997
***************
*** 1,4 ****
! /* $XConsortium: Display.c /main/113 1996/08/21 11:37:33 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Display.c /main/114 1997/05/15 17:28:57 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 206,212 ****
      pd->pdi.keyboard.grabType = XtNoServerGrab;
      pd->pdi.pointer.grabType  = XtNoServerGrab;
      _XtAllocWWTable(pd);
!     pd->per_screen_db = (XrmDatabase *)XtCalloc(ScreenCount(dpy),
  						sizeof(XrmDatabase));
      pd->cmd_db = (XrmDatabase)NULL;
      pd->server_db = (XrmDatabase)NULL;
--- 206,212 ----
      pd->pdi.keyboard.grabType = XtNoServerGrab;
      pd->pdi.pointer.grabType  = XtNoServerGrab;
      _XtAllocWWTable(pd);
!     pd->per_screen_db = (XrmDatabase *)__XtCalloc(ScreenCount(dpy),
  						sizeof(XrmDatabase));
      pd->cmd_db = (XrmDatabase)NULL;
      pd->server_db = (XrmDatabase)NULL;
***************
*** 281,287 ****
  	    int len;
  	    displayName = XDisplayName(displayName);
  	    len = strlen (displayName);
! 	    app->display_name_tried = (String) XtMalloc (len + 1);
  	    strncpy ((char*) app->display_name_tried, displayName, len + 1);
  	    app->display_name_tried[len] = '\0';
  	}
--- 281,287 ----
  	    int len;
  	    displayName = XDisplayName(displayName);
  	    len = strlen (displayName);
! 	    app->display_name_tried = (String) __XtMalloc (len + 1);
  	    strncpy ((char*) app->display_name_tried, displayName, len + 1);
  	    app->display_name_tried[len] = '\0';
  	}
***************
*** 309,315 ****
   */
      
      saved_argv = (String *)
! 	XtMalloc( (Cardinal)((*argc_in_out + 1) * sizeof(String)) );
  
      for (i = 0 ; i < *argc_in_out ; i++) saved_argv[i] = (*argv_in_out)[i];
      saved_argv[i] = NULL;	/* NULL terminate that sucker. */
--- 309,315 ----
   */
      
      saved_argv = (String *)
! 	__XtMalloc( (Cardinal)((*argc_in_out + 1) * sizeof(String)) );
  
      for (i = 0 ; i < *argc_in_out ; i++) saved_argv[i] = (*argv_in_out)[i];
      saved_argv[i] = NULL;	/* NULL terminate that sucker. */
***************
*** 811,817 ****
      int ii;
      LOCK_APP(app_context);
      *num_dpy_return = app_context->count;
!     *dpy_return = (Display**)XtMalloc(app_context->count * sizeof(Display*));
      for (ii = 0; ii < app_context->count; ii++)
  	*dpy_return[ii] = app_context->list[ii];
      UNLOCK_APP(app_context);
--- 811,817 ----
      int ii;
      LOCK_APP(app_context);
      *num_dpy_return = app_context->count;
!     *dpy_return = (Display**)__XtMalloc(app_context->count * sizeof(Display*));
      for (ii = 0; ii < app_context->count; ii++)
  	*dpy_return[ii] = app_context->list[ii];
      UNLOCK_APP(app_context);
*** xc/lib/Xt/Error.c@@/PUBLIC-LATEST	Wed Nov 13 14:48:51 1996
--- xc/lib/Xt/Error.c	Sat Jun 21 07:45:20 1997
***************
*** 1,4 ****
! /* $XConsortium: Error.c /main/37 1996/11/13 14:45:02 lehors $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Error.c /main/41 1997/06/21 07:43:23 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 244,249 ****
--- 244,253 ----
      else if ((getuid () != geteuid ()) || getuid() == 0) {
  	if ((error && errorHandler == _XtDefaultError) ||
  	    (!error && warningHandler == _XtDefaultWarning)) {
+ 	    /*
+ 	     * if it's just going to go to stderr anyway, then we'll 
+ 	     * fprintf to stderr ourselves and skip the insecure sprintf.
+ 	     */
  	    int i = *num_params;
  	    String par[10];
  	    if (i > 10) i = 10;
***************
*** 257,292 ****
  			    par[5], par[6], par[7], par[8], par[9]);
  	    (void) fprintf (stderr, "%c", '\n');
  	    if (i != *num_params)
! 		XtWarning( "some arguments in previous message were lost" );
  	} else {
! 	    (*fn)(buffer);
! 	    (*fn)("This program is an suid root program or is being run\n\
! by the root user; the full text of the error or warning message cannot\n\
! be safely formatted in this environment. You may get a more descriptive\n\
! message by running the program as a non-root user or by removing the\n\
! suid bit on the executable.");
  	}
      } else
  #endif
      {
  	int i = *num_params;
  	String par[10];
  	if (i > 10) i = 10;
  	(void) memmove((char*)par, (char*)params, i * sizeof(String) );
  	bzero( &par[i], (10-i) * sizeof(String) );
  	/* 
! 	 * resist any temptation you might have to make message
  	 * local buffer on the stack. Doing so is a security hole 
  	 * in programs executing as root. Error and Warning
  	 * messages shouldn't be called frequently enough for this
  	 * to be a performance issue.
  	 */
! 	if ((message = XtMalloc (BIGBUF))) {
! 	    /* 
! 	     * it may be desireable to initialize  the last few bytes of 
! 	     * message ... 
! 	     */
  #ifndef USE_SNPRINTF
  	    (void) sprintf (message, buffer, 
  #else
  	    (void) snprintf (message, BIGBUF, buffer,
--- 261,305 ----
  			    par[5], par[6], par[7], par[8], par[9]);
  	    (void) fprintf (stderr, "%c", '\n');
  	    if (i != *num_params)
! 		(*fn) ( "Some arguments in previous message were lost" );
! 	    else if (error) exit (1);
  	} else {
! 	    /*
! 	     * can't tell what it might do, so we'll play it safe
! 	     */
! 	    XtWarning ("\
! This program is an suid-root program or is being run by the root user.\n\
! The full text of the error or warning message cannot be safely formatted\n\
! in this environment. You may get a more descriptive message by running the\n\
! program as a non-root user or by removing the suid bit on the executable.");
! 	    (*fn)(buffer); /* if *fn is an ErrorHandler it should exit */
  	}
      } else
  #endif
      {
+ 	/*
+ 	 * If you have snprintf the worst thing that could happen is you'd
+ 	 * lose some information. Without snprintf you're probably going to 
+ 	 * scramble your heap and perhaps SEGV -- sooner or later.
+ 	 * If it hurts when you go like this then don't go like this! :-)
+ 	 */
  	int i = *num_params;
  	String par[10];
  	if (i > 10) i = 10;
  	(void) memmove((char*)par, (char*)params, i * sizeof(String) );
  	bzero( &par[i], (10-i) * sizeof(String) );
+ 	if (i != *num_params)
+ 	    XtWarning( "Some arguments in following message were lost" );
  	/* 
! 	 * resist any temptation you might have to make `message' a
  	 * local buffer on the stack. Doing so is a security hole 
  	 * in programs executing as root. Error and Warning
  	 * messages shouldn't be called frequently enough for this
  	 * to be a performance issue.
  	 */
! 	if ((message = __XtMalloc (BIGBUF))) {
  #ifndef USE_SNPRINTF
+ 	    message[BIGBUF-1] = 0;
  	    (void) sprintf (message, buffer, 
  #else
  	    (void) snprintf (message, BIGBUF, buffer,
***************
*** 293,309 ****
  #endif
  			    par[0], par[1], par[2], par[3], par[4], 
  			    par[5], par[6], par[7], par[8], par[9]);
! 	    /* 
! 	     * ... and check their value after the sprintf. If they've 
! 	     * been altered then it might be wise to exit now, while 
! 	     * you can still do it gracefully.
! 	     */
  	    (*fn)(message);
  	    XtFree(message);
! 	} else
  	    (*fn)(buffer);
! 	if (i != *num_params)
! 	    XtWarning( "some arguments in previous message were lost" );
      }
  }
  
--- 306,321 ----
  #endif
  			    par[0], par[1], par[2], par[3], par[4], 
  			    par[5], par[6], par[7], par[8], par[9]);
! #ifndef USE_SNPRINTF
! 	    if (message[BIGBUF-1] != '\0')
! 		XtWarning ("Possible heap corruption in Xt{Error,Warning}MsgHandler");
! #endif
  	    (*fn)(message);
  	    XtFree(message);
! 	} else {
! 	    XtWarning ("Memory allocation failed, arguments in the following message were lost");
  	    (*fn)(buffer);
! 	}
      }
  }
  
***************
*** 520,528 ****
  void _XtDefaultError(message)
      String message;
  {
!     extern void exit();
! 
!     (void)fprintf(stderr, "%sError: %s\n", XTERROR_PREFIX, message);
      exit(1);
  }
  
--- 532,539 ----
  void _XtDefaultError(message)
      String message;
  {
!     if (message && *message)
! 	(void)fprintf(stderr, "%sError: %s\n", XTERROR_PREFIX, message);
      exit(1);
  }
  
*** xc/lib/Xt/Event.c@@/PUBLIC-LATEST	Fri Dec  8 18:21:21 1995
--- xc/lib/Xt/Event.c	Thu May 15 17:25:56 1997
***************
*** 1,4 ****
! /* $XConsortium: Event.c /main/151 1995/12/08 18:21:53 converse $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Event.c /main/152 1997/05/15 17:29:12 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 290,296 ****
  
      if (!p) {		                /* New proc to add to list */
  	if (has_type_specifier) {
! 	    p = (XtEventRec*) XtMalloc(sizeof(XtEventRec) + 
  				       sizeof(XtEventRecExt));
  	    EXT_TYPE(p) = type;
  	    EXT_SELECT_DATA(p,0) = select_data;
--- 290,296 ----
  
      if (!p) {		                /* New proc to add to list */
  	if (has_type_specifier) {
! 	    p = (XtEventRec*) __XtMalloc(sizeof(XtEventRec) + 
  				       sizeof(XtEventRecExt));
  	    EXT_TYPE(p) = type;
  	    EXT_SELECT_DATA(p,0) = select_data;
***************
*** 297,303 ****
  	    p->mask = 1;
  	    p->has_type_specifier = True;
  	} else {
! 	    p = (XtEventRec*) XtMalloc(sizeof(XtEventRec));
  	    p->mask = eventMask;
  	    p->has_type_specifier = False;
  	}
--- 297,303 ----
  	    p->mask = 1;
  	    p->has_type_specifier = True;
  	} else {
! 	    p = (XtEventRec*) __XtMalloc(sizeof(XtEventRec));
  	    p->mask = eventMask;
  	    p->has_type_specifier = False;
  	}
***************
*** 704,710 ****
  	tab->mask = (tab->mask << 1) + 1;
  	tab->rehash = tab->mask - 2;
      }
!     entries = tab->entries = (Widget *) XtCalloc(tab->mask+1, sizeof(Widget));
      for (oldidx = 0; oldidx <= oldmask; oldidx++) {
  	if ((entry = oldentries[oldidx]) && entry != &WWfake) {
  	    newidx = WWHASH(tab, XtWindow(entry));
--- 704,710 ----
  	tab->mask = (tab->mask << 1) + 1;
  	tab->rehash = tab->mask - 2;
      }
!     entries = tab->entries = (Widget *) __XtCalloc(tab->mask+1, sizeof(Widget));
      for (oldidx = 0; oldidx <= oldmask; oldidx++) {
  	if ((entry = oldentries[oldidx]) && entry != &WWfake) {
  	    newidx = WWHASH(tab, XtWindow(entry));
***************
*** 766,775 ****
  {
      register WWTable tab;
  
!     tab = (WWTable) XtMalloc(sizeof(struct _WWTable));
      tab->mask = 0x7f;
      tab->rehash = tab->mask - 2;
!     tab->entries = (Widget *) XtCalloc(tab->mask+1, sizeof(Widget));
      tab->occupied = 0;
      tab->fakes = 0;
      tab->pairs = NULL;
--- 766,775 ----
  {
      register WWTable tab;
  
!     tab = (WWTable) __XtMalloc(sizeof(struct _WWTable));
      tab->mask = 0x7f;
      tab->rehash = tab->mask - 2;
!     tab->entries = (Widget *) __XtCalloc(tab->mask+1, sizeof(Widget));
      tab->occupied = 0;
      tab->fakes = 0;
      tab->pairs = NULL;
***************
*** 814,820 ****
  	    numprocs++;
      }
      if (numprocs > EHMAXSIZE) {
! 	proc = (XtEventHandler *)XtMalloc(numprocs * (sizeof(XtEventHandler) +
  						      sizeof(XtPointer)));
  	closure = (XtPointer *)(proc + numprocs);
      } else {
--- 814,820 ----
  	    numprocs++;
      }
      if (numprocs > EHMAXSIZE) {
! 	proc = (XtEventHandler *)__XtMalloc(numprocs * (sizeof(XtEventHandler) +
  						      sizeof(XtPointer)));
  	closure = (XtPointer *)(proc + numprocs);
      } else {
***************
*** 1720,1726 ****
  static XtEventDispatchProc* NewDispatcherList()
  {
      XtEventDispatchProc* l =
! 	(XtEventDispatchProc*) XtCalloc((Cardinal) 128,
  					(Cardinal)sizeof(XtEventDispatchProc));
      return l;
  }
--- 1720,1726 ----
  static XtEventDispatchProc* NewDispatcherList()
  {
      XtEventDispatchProc* l =
! 	(XtEventDispatchProc*) __XtCalloc((Cardinal) 128,
  					(Cardinal)sizeof(XtEventDispatchProc));
      return l;
  }
*** xc/lib/Xt/EventUtil.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:04 1994
--- xc/lib/Xt/EventUtil.c	Thu May 15 17:26:06 1997
***************
*** 1,4 ****
! /* $XConsortium: EventUtil.c,v 1.12 94/04/17 20:14:04 kaleb Exp $ */
  
  /********************************************************
  
--- 1,4 ----
! /* $TOG: EventUtil.c /main/13 1997/05/15 17:29:22 kaleb $ */
  
  /********************************************************
  
***************
*** 109,115 ****
  	create) 
        {
  	  pwi = (XtPerWidgetInput) 
! 	    XtMalloc((unsigned) sizeof(XtPerWidgetInputRec));
  	  
  	  pwi->focusKid = NULL;
  	  pwi->queryEventDescendant = NULL;
--- 109,115 ----
  	create) 
        {
  	  pwi = (XtPerWidgetInput) 
! 	    __XtMalloc((unsigned) sizeof(XtPerWidgetInputRec));
  	  
  	  pwi->focusKid = NULL;
  	  pwi->queryEventDescendant = NULL;
***************
*** 148,154 ****
      /* First time in, allocate the ancestor list */
      if (trace == NULL) 
        {
! 	  trace = (Widget *) XtMalloc(CACHESIZE * sizeof(Widget));
  	  *maxElemsPtr = CACHESIZE;
        }	
      /* First fill in the ancestor list */
--- 148,154 ----
      /* First time in, allocate the ancestor list */
      if (trace == NULL) 
        {
! 	  trace = (Widget *) __XtMalloc(CACHESIZE * sizeof(Widget));
  	  *maxElemsPtr = CACHESIZE;
        }	
      /* First fill in the ancestor list */
*** xc/lib/Xt/Functions.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:05 1994
--- xc/lib/Xt/Functions.c	Thu May 15 17:26:14 1997
***************
*** 1,4 ****
! /* $XConsortium: Functions.c,v 1.12 94/04/17 20:14:05 kaleb Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: Functions.c /main/13 1997/05/15 17:29:29 kaleb $ */
  
  /*
  
***************
*** 225,229 ****
      if (str == NULL)
  	return NULL;
      else
! 	return strcpy(XtMalloc((unsigned)strlen(str) + 1), str);
  }
--- 225,229 ----
      if (str == NULL)
  	return NULL;
      else
! 	return strcpy(__XtMalloc((unsigned)strlen(str) + 1), str);
  }
*** xc/lib/Xt/GCManager.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:05 1994
--- xc/lib/Xt/GCManager.c	Thu May 15 17:26:21 1997
***************
*** 1,4 ****
! /* $XConsortium: GCManager.c,v 1.48 94/04/17 20:14:05 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: GCManager.c /main/39 1997/05/15 17:29:36 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 239,245 ****
      if (!drawable) {
  	if (!pd->pixmap_tab) {
  	    int n;
! 	    pd->pixmap_tab = (Drawable **)XtMalloc((unsigned)ScreenCount(dpy) *
  						   sizeof(Drawable *));
  	    for (n = 0; n < ScreenCount(dpy); n++)
  		pd->pixmap_tab[n] = NULL;
--- 239,245 ----
      if (!drawable) {
  	if (!pd->pixmap_tab) {
  	    int n;
! 	    pd->pixmap_tab = (Drawable **)__XtMalloc((unsigned)ScreenCount(dpy) *
  						   sizeof(Drawable *));
  	    for (n = 0; n < ScreenCount(dpy); n++)
  		pd->pixmap_tab[n] = NULL;
***************
*** 255,261 ****
  		    max = depths[n];
  	    }
  	    XFree((char *)depths);
! 	    pixmaps = (Drawable *)XtCalloc((unsigned)max, sizeof(Drawable));
  	    pd->pixmap_tab[cur->screen] = pixmaps;
  	}
  	drawable = pixmaps[cur->depth - 1];
--- 255,261 ----
  		    max = depths[n];
  	    }
  	    XFree((char *)depths);
! 	    pixmaps = (Drawable *)__XtCalloc((unsigned)max, sizeof(Drawable));
  	    pd->pixmap_tab[cur->screen] = pixmaps;
  	}
  	drawable = pixmaps[cur->depth - 1];
*** xc/lib/Xt/GetResList.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:08 1994
--- xc/lib/Xt/GetResList.c	Thu May 15 17:26:28 1997
***************
*** 1,4 ****
! /* $XConsortium: GetResList.c,v 1.7 94/04/17 20:14:08 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: GetResList.c /main/8 1997/05/15 17:29:43 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 77,83 ****
  
  	LOCK_PROCESS;
  	size = widget_class->core_class.num_resources * sizeof(XtResource);
! 	*resources = (XtResourceList) XtMalloc((unsigned) size);
  
  	if (!widget_class->core_class.class_inited) {
  	    /* Easy case */
--- 77,83 ----
  
  	LOCK_PROCESS;
  	size = widget_class->core_class.num_resources * sizeof(XtResource);
! 	*resources = (XtResourceList) __XtMalloc((unsigned) size);
  
  	if (!widget_class->core_class.class_inited) {
  	    /* Easy case */
***************
*** 149,155 ****
  	}
  
  	size = class->constraint_class.num_resources * sizeof(XtResource);
! 	*resources = (XtResourceList) XtMalloc((unsigned) size);
  
  	if (!class->core_class.class_inited) {
  	    /* Easy case */
--- 149,155 ----
  	}
  
  	size = class->constraint_class.num_resources * sizeof(XtResource);
! 	*resources = (XtResourceList) __XtMalloc((unsigned) size);
  
  	if (!class->core_class.class_inited) {
  	    /* Easy case */
*** xc/lib/Xt/Imakefile@@/PUBLIC-LATEST	Sat Sep 28 16:54:24 1996
--- xc/lib/Xt/Imakefile	Tue May 20 10:03:05 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/118 1996/09/28 16:46:04 rws $
  #define DoNormalLib NormalLibXt
  #define DoSharedLib SharedLibXt
  #define DoDebugLib DebugLibXt
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/119 1997/05/20 10:06:20 kaleb $
  #define DoNormalLib NormalLibXt
  #define DoSharedLib SharedLibXt
  #define DoDebugLib DebugLibXt
***************
*** 50,56 ****
  
     SRCH_DEFINES = -DXFILESEARCHPATHDEFAULT=\"$(XFILESEARCHPATHDEFAULT)\"
  #if Malloc0ReturnsNull
!   ALLOC_DEFINES = -DMALLOC_0_RETURNS_NULL
  #endif
  #if MotifBC
       BC_DEFINES = -DMOTIFBC
--- 50,56 ----
  
     SRCH_DEFINES = -DXFILESEARCHPATHDEFAULT=\"$(XFILESEARCHPATHDEFAULT)\"
  #if Malloc0ReturnsNull
!   ALLOC_DEFINES = XtMalloc0ReturnsNullDefines
  #endif
  #if MotifBC
       BC_DEFINES = -DMOTIFBC
*** xc/lib/Xt/Initialize.c@@/PUBLIC-LATEST	Wed Dec  4 10:25:29 1996
--- xc/lib/Xt/Initialize.c	Thu May 15 17:26:35 1997
***************
*** 1,4 ****
! /* $XConsortium: Initialize.c /main/209 1996/12/04 10:22:31 lehors $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Initialize.c /main/210 1997/05/15 17:29:50 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 563,569 ****
      enum {Check, NotSorted, IsSorted} sort_order = Check;
  
      *dst = table = (XrmOptionDescRec*)
! 	XtMalloc( sizeof(XrmOptionDescRec) * (num_src1 + num_src2) );
  
      (void) memmove(table, src1, sizeof(XrmOptionDescRec) * num_src1 );
      if (num_src2 == 0) {
--- 563,569 ----
      enum {Check, NotSorted, IsSorted} sort_order = Check;
  
      *dst = table = (XrmOptionDescRec*)
! 	__XtMalloc( sizeof(XrmOptionDescRec) * (num_src1 + num_src2) );
  
      (void) memmove(table, src1, sizeof(XrmOptionDescRec) * num_src1 );
      if (num_src2 == 0) {
***************
*** 672,678 ****
      String *targv;
      int targc = argc;
  
!     targv = (String *) XtMalloc(sizeof(char *) * argc);
      (void) memmove(targv, argv, sizeof(char *) * argc);
      _MergeOptionTables(opTable, XtNumber(opTable), urlist, num_urs,
  		       &options, &num_options);
--- 672,678 ----
      String *targv;
      int targc = argc;
  
!     targv = (String *) __XtMalloc(sizeof(char *) * argc);
      (void) memmove(targv, argv, sizeof(char *) * argc);
      _MergeOptionTables(opTable, XtNumber(opTable), urlist, num_urs,
  		       &options, &num_options);
***************
*** 760,766 ****
      XtAppContext app = XtDisplayToApplicationContext(dpy);
  
      if (opening) {
! 	iptr = (XtInputId *) XtMalloc(sizeof(XtInputId));
  	*iptr = XtAppAddInput(app, fd, (XtPointer) XtInputReadMask,
  			      ProcessInternalConnection, client_data);
  	*watch_data = (XPointer) iptr;
--- 760,766 ----
      XtAppContext app = XtDisplayToApplicationContext(dpy);
  
      if (opening) {
! 	iptr = (XtInputId *) __XtMalloc(sizeof(XtInputId));
  	*iptr = XtAppAddInput(app, fd, (XtPointer) XtInputReadMask,
  			      ProcessInternalConnection, client_data);
  	*watch_data = (XPointer) iptr;
*** xc/lib/Xt/Intrinsic.c@@/PUBLIC-LATEST	Sat Sep 28 16:54:39 1996
--- xc/lib/Xt/Intrinsic.c	Thu May 15 17:26:44 1997
***************
*** 1,4 ****
! /* $XConsortium: Intrinsic.c /main/149 1996/09/28 16:46:19 rws $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Intrinsic.c /main/150 1997/05/15 17:29:59 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 350,356 ****
  
  	len_nm = widget->core.name ? strlen(widget->core.name) : 0;
  	len_cl = strlen(class_name);
! 	s = XtMalloc((unsigned) (len_nm + len_cl + 2));
  	s[0] = '\0';
  	if (len_nm)
  	    strcpy(s, widget->core.name);
--- 350,356 ----
  
  	len_nm = widget->core.name ? strlen(widget->core.name) : 0;
  	len_cl = strlen(class_name);
! 	s = __XtMalloc((unsigned) (len_nm + len_cl + 2));
  	s[0] = '\0';
  	if (len_nm)
  	    strcpy(s, widget->core.name);
***************
*** 995,1002 ****
      int len;
      Boolean firstTime = TRUE;
  
!     buf = buf1 = XtMalloc((unsigned)PATH_MAX);
!     buf2 = XtMalloc((unsigned)PATH_MAX);
  
      if (predicate == NULL) predicate = TestFile;
  
--- 995,1002 ----
      int len;
      Boolean firstTime = TRUE;
  
!     buf = buf1 = __XtMalloc((unsigned)PATH_MAX);
!     buf2 = __XtMalloc((unsigned)PATH_MAX);
  
      if (predicate == NULL) predicate = TestFile;
  
***************
*** 1181,1187 ****
  
      len = strlen(string) + 1;
      subs[0].substitution = string;
!     p1 = subs[1].substitution = XtMalloc((Cardinal) 3*len);
      p2 = subs[2].substitution = subs[1].substitution + len;
      p3 = subs[3].substitution = subs[2].substitution + len;
  
--- 1181,1187 ----
  
      len = strlen(string) + 1;
      subs[0].substitution = string;
!     p1 = subs[1].substitution = __XtMalloc((Cardinal) 3*len);
      p2 = subs[2].substitution = subs[1].substitution + len;
      p3 = subs[3].substitution = subs[2].substitution + len;
  
***************
*** 1327,1333 ****
  	    int bytesUsed = bytesAllocd - bytesLeft;
  	    char *new;
  	    bytesAllocd +=1000;
! 	    new = XtMalloc((Cardinal) bytesAllocd);
  	    strncpy( new, massagedPath, bytesUsed );
  	    ch = new + bytesUsed;
  	    if (pathMallocd)
--- 1327,1333 ----
  	    int bytesUsed = bytesAllocd - bytesLeft;
  	    char *new;
  	    bytesAllocd +=1000;
! 	    new = __XtMalloc((Cardinal) bytesAllocd);
  	    strncpy( new, massagedPath, bytesUsed );
  	    ch = new + bytesUsed;
  	    if (pathMallocd)
*** xc/lib/Xt/IntrinsicI.h@@/PUBLIC-LATEST	Sat Sep 28 16:54:49 1996
--- xc/lib/Xt/IntrinsicI.h	Thu May 15 17:26:53 1997
***************
*** 1,4 ****
! /* $XConsortium: IntrinsicI.h /main/46 1996/09/28 16:46:29 rws $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $TOG: IntrinsicI.h /main/47 1997/05/15 17:30:09 kaleb $ */
  
  /***********************************************************
  
***************
*** 253,258 ****
--- 253,278 ----
  #define CALLGEOTAT(f) 
  
  #endif /* XT_GEO_TATTLER */
+ 
+ #ifndef XTTRACEMEMORY
+ 
+ extern char* __XtMalloc (
+ #if NeedFunctionPrototypes
+     unsigned	/* size */
+ #endif
+ );
+ extern char* __XtCalloc (
+ #if NeedFunctionPrototypes
+     unsigned	/* num */,
+     unsigned	/* size */
+ #endif
+ );
+ 
+ #else
+ 
+ #define __XtMalloc XtMalloc
+ #define __XtCalloc XtCalloc
+ #endif
  
  #endif /* _XtintrinsicI_h */
  /* DON'T ADD STUFF AFTER THIS #endif */
*** xc/lib/Xt/Manage.c@@/PUBLIC-LATEST	Sat Sep 28 16:54:56 1996
--- xc/lib/Xt/Manage.c	Thu May 15 17:27:00 1997
***************
*** 1,4 ****
! /* $XConsortium: Manage.c /main/35 1996/09/28 16:46:36 rws $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Manage.c /main/36 1997/05/15 17:30:16 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 222,228 ****
      if (num_children <= MAXCHILDREN) {
  	unique_children = cache;
      } else {
! 	unique_children = (WidgetList) XtMalloc(num_children * sizeof(Widget));
      }
      num_unique_children = 0;
      for (i = 0; i < num_children; i++) {
--- 222,228 ----
      if (num_children <= MAXCHILDREN) {
  	unique_children = cache;
      } else {
! 	unique_children = (WidgetList) __XtMalloc(num_children * sizeof(Widget));
      }
      num_unique_children = 0;
      for (i = 0; i < num_children; i++) {
*** xc/lib/Xt/Object.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:30 1994
--- xc/lib/Xt/Object.c	Thu May 15 17:27:08 1997
***************
*** 1,4 ****
! /* $XConsortium: Object.c,v 1.26 94/04/17 20:14:30 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Object.c /main/26 1997/05/15 17:30:23 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 162,168 ****
       * offsets so that resource overrides work.
       */
      newTable = (CallbackTable)
! 	XtMalloc(sizeof(XrmResource *) * (tableSize + 1));
  	
      newTable[0] = (XrmResource *) tableSize;
  
--- 162,168 ----
       * offsets so that resource overrides work.
       */
      newTable = (CallbackTable)
! 	__XtMalloc(sizeof(XrmResource *) * (tableSize + 1));
  	
      newTable[0] = (XrmResource *) tableSize;
  
***************
*** 209,215 ****
      } else if (super_ext) {
  	/* Be careful to inherit only what is appropriate */
  	ext = (ObjectClassExtension) 
! 	    XtCalloc(1, sizeof(ObjectClassExtensionRec));
  	ext->next_extension = oc->object_class.extension;
  	ext->record_type = NULLQUARK;
  	ext->version = XtObjectExtensionVersion;
--- 209,215 ----
      } else if (super_ext) {
  	/* Be careful to inherit only what is appropriate */
  	ext = (ObjectClassExtension) 
! 	    __XtCalloc(1, sizeof(ObjectClassExtensionRec));
  	ext->next_extension = oc->object_class.extension;
  	ext->record_type = NULLQUARK;
  	ext->version = XtObjectExtensionVersion;
*** xc/lib/Xt/PassivGrab.c@@/PUBLIC-LATEST	Fri Jan 26 17:33:56 1996
--- xc/lib/Xt/PassivGrab.c	Thu May 15 17:27:15 1997
***************
*** 1,4 ****
! /* $XConsortium: PassivGrab.c /main/28 1996/01/26 17:34:47 converse $ */
  
  /********************************************************
  
--- 1,4 ----
! /* $TOG: PassivGrab.c /main/29 1997/05/15 17:30:30 kaleb $ */
  
  /********************************************************
  
***************
*** 95,101 ****
  
      if (!pDetailMask) {
  	int i;
! 	pDetailMask = (Mask *)XtMalloc(sizeof(Mask) * MasksPerDetailMask);
  	for (i = MasksPerDetailMask; --i >= 0; )
  	    pDetailMask[i] = ~0;
  	*ppDetailMask = pDetailMask;
--- 95,101 ----
  
      if (!pDetailMask) {
  	int i;
! 	pDetailMask = (Mask *)__XtMalloc(sizeof(Mask) * MasksPerDetailMask);
  	for (i = MasksPerDetailMask; --i >= 0; )
  	    pDetailMask[i] = ~0;
  	*ppDetailMask = pDetailMask;
***************
*** 117,123 ****
      if (!pOriginalDetailMask)
  	return NULL;
      
!     pTempMask = (Mask *)XtMalloc(sizeof(Mask) * MasksPerDetailMask);
      
      for ( i = 0; i < MasksPerDetailMask; i++)
        pTempMask[i]= pOriginalDetailMask[i];
--- 117,123 ----
      if (!pOriginalDetailMask)
  	return NULL;
      
!     pTempMask = (Mask *)__XtMalloc(sizeof(Mask) * MasksPerDetailMask);
      
      for ( i = 0; i < MasksPerDetailMask; i++)
        pTempMask[i]= pOriginalDetailMask[i];
***************
*** 148,154 ****
      
      if (confine_to || cursor)
  	need_ext = True;
!     grab = (XtServerGrabPtr)XtMalloc(sizeof(XtServerGrabRec) +
  				     (need_ext ? sizeof(XtServerGrabExtRec)
  				      : 0));
      grab->next = NULL;
--- 148,154 ----
      
      if (confine_to || cursor)
  	need_ext = True;
!     grab = (XtServerGrabPtr)__XtMalloc(sizeof(XtServerGrabRec) +
  				     (need_ext ? sizeof(XtServerGrabExtRec)
  				      : 0));
      grab->next = NULL;
*** xc/lib/Xt/Resources.c@@/PUBLIC-LATEST	Thu Feb  1 16:26:00 1996
--- xc/lib/Xt/Resources.c	Thu May 15 17:27:23 1997
***************
*** 1,4 ****
! /* $XConsortium: Resources.c /main/111 1996/02/01 16:32:22 converse $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Resources.c /main/112 1997/05/15 17:30:38 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 453,459 ****
  
      /* Allocate and initialize new_res with superclass resource pointers */
      new_num_res = super_num_res + class_num_res;
!     new_res = (XrmResourceList *) XtMalloc(new_num_res*sizeof(XrmResourceList));
      if (super_num_res > 0)
  	XtMemmove(new_res, super_res, super_num_res * sizeof(XrmResourceList));
      
--- 453,459 ----
  
      /* Allocate and initialize new_res with superclass resource pointers */
      new_num_res = super_num_res + class_num_res;
!     new_res = (XrmResourceList *) __XtMalloc(new_num_res*sizeof(XrmResourceList));
      if (super_num_res > 0)
  	XtMemmove(new_res, super_res, super_num_res * sizeof(XrmResourceList));
      
***************
*** 542,548 ****
      register int idx;
      XrmResourceList* table;
  
!     table = (XrmResourceList*)XtMalloc(num_resources * sizeof(XrmResourceList));
      for (idx = 0; idx < num_resources; idx++)
          table[idx] = (XrmResourceList)(&(resources[idx]));
      return table;
--- 542,548 ----
      register int idx;
      XrmResourceList* table;
  
!     table = (XrmResourceList*)__XtMalloc(num_resources * sizeof(XrmResourceList));
      for (idx = 0; idx < num_resources; idx++)
          table[idx] = (XrmResourceList)(&(resources[idx]));
      return table;
***************
*** 818,824 ****
  		     */
  
  		    if(rx->xrm_size > sizeof(XtArgVal)) {
! 			arg->value = (XtArgVal) XtMalloc(rx->xrm_size);
  			arg->size = -(arg->size);
  		    } else { /* will fit - copy directly into value field */
  			arg->value = (XtArgVal) NULL;
--- 818,824 ----
  		     */
  
  		    if(rx->xrm_size > sizeof(XtArgVal)) {
! 			arg->value = (XtArgVal) __XtMalloc(rx->xrm_size);
  			arg->size = -(arg->size);
  		    } else { /* will fit - copy directly into value field */
  			arg->value = (XtArgVal) NULL;
***************
*** 972,978 ****
      if (cache_ptr && cache_ptr != cache_ref) {
  	int cache_ref_size = cache_ptr - cache_ref;
  	XtCacheRef *refs = (XtCacheRef*)
! 	    XtMalloc((unsigned)sizeof(XtCacheRef)*(cache_ref_size + 1));
  	(void) memmove(refs, cache_ref, sizeof(XtCacheRef)*cache_ref_size );
  	refs[cache_ref_size] = NULL;
  	return refs;
--- 972,978 ----
      if (cache_ptr && cache_ptr != cache_ref) {
  	int cache_ref_size = cache_ptr - cache_ref;
  	XtCacheRef *refs = (XtCacheRef*)
! 	    __XtMalloc((unsigned)sizeof(XtCacheRef)*(cache_ref_size + 1));
  	(void) memmove(refs, cache_ref, sizeof(XtCacheRef)*cache_ref_size );
  	refs[cache_ref_size] = NULL;
  	return refs;
***************
*** 999,1005 ****
      count = (args != NULL) ? num_args : num_typed_args;
  
      if (num_quarks < count) {
! 	quarks = (XrmQuarkList) XtMalloc(count * sizeof(XrmQuark));
      } else {
  	quarks = quark_cache;
      }
--- 999,1005 ----
      count = (args != NULL) ? num_args : num_typed_args;
  
      if (num_quarks < count) {
! 	quarks = (XrmQuarkList) __XtMalloc(count * sizeof(XrmQuark));
      } else {
  	quarks = quark_cache;
      }
*** xc/lib/Xt/Selection.c@@/PUBLIC-LATEST	Wed Dec  4 10:25:39 1996
--- xc/lib/Xt/Selection.c	Thu May 15 17:27:31 1997
***************
*** 1,4 ****
! /* $XConsortium: Selection.c /main/97 1996/12/04 10:22:41 lehors $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: Selection.c /main/98 1997/05/15 17:30:47 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 174,180 ****
      if (XFindContext(dpy, DefaultRootWindow(dpy), selectPropertyContext,
  		     (XPointer *)&sarray)) {
  	XtPerDisplay pd = _XtGetPerDisplay(dpy);
! 	sarray = (PropList) XtMalloc((unsigned) sizeof(PropListRec));
  	sarray->dpy = dpy;
  	XInternAtoms(dpy, names, 4, FALSE, atoms);
  	sarray->incr_atom = atoms[0];
--- 174,180 ----
      if (XFindContext(dpy, DefaultRootWindow(dpy), selectPropertyContext,
  		     (XPointer *)&sarray)) {
  	XtPerDisplay pd = _XtGetPerDisplay(dpy);
! 	sarray = (PropList) __XtMalloc((unsigned) sizeof(PropListRec));
  	sarray->dpy = dpy;
  	XInternAtoms(dpy, names, 4, FALSE, atoms);
  	sarray->incr_atom = atoms[0];
***************
*** 182,188 ****
  	sarray->timestamp_atom = atoms[2];
  	sarray->propCount = 1;
  	sarray->list = 
! 	    (SelectionProp)XtMalloc((unsigned) sizeof(SelectionPropRec));
  	sarray->list[0].prop = atoms[3];
  	sarray->list[0].avail = TRUE;
  	(void) XSaveContext(dpy, DefaultRootWindow(dpy), selectPropertyContext,
--- 182,188 ----
  	sarray->timestamp_atom = atoms[2];
  	sarray->propCount = 1;
  	sarray->list = 
! 	    (SelectionProp)__XtMalloc((unsigned) sizeof(SelectionPropRec));
  	sarray->list[0].prop = atoms[3];
  	sarray->list[0].avail = TRUE;
  	(void) XSaveContext(dpy, DefaultRootWindow(dpy), selectPropertyContext,
***************
*** 267,277 ****
  
  	info->ctx = ctx;
  	info->callbacks = (XtSelectionCallbackProc *)
! 	    XtMalloc((unsigned) (count * sizeof(XtSelectionCallbackProc)));
  	(void) memmove((char*)info->callbacks, (char*)callbacks, 
  		       count * sizeof(XtSelectionCallbackProc));
  	info->req_closure =
! 	    (XtPointer*)XtMalloc((unsigned) (count * sizeof(XtPointer)));
  	(void) memmove((char*)info->req_closure, (char*)closures, 
  		       count * sizeof(XtPointer));
  	if (count == 1 && properties != NULL && properties[0] != None)
--- 267,277 ----
  
  	info->ctx = ctx;
  	info->callbacks = (XtSelectionCallbackProc *)
! 	    __XtMalloc((unsigned) (count * sizeof(XtSelectionCallbackProc)));
  	(void) memmove((char*)info->callbacks, (char*)callbacks, 
  		       count * sizeof(XtSelectionCallbackProc));
  	info->req_closure =
! 	    (XtPointer*)__XtMalloc((unsigned) (count * sizeof(XtPointer)));
  	(void) memmove((char*)info->req_closure, (char*)closures, 
  		       count * sizeof(XtPointer));
  	if (count == 1 && properties != NULL && properties[0] != None)
***************
*** 284,290 ****
  	info->proc = HandleSelectionReplies;
  	info->widget = widget;
  	info->time = time;
! 	info->incremental = (Boolean*) XtMalloc(count * sizeof(Boolean));
  	(void) memmove((char*)info->incremental, (char*) incremental,
  		       count * sizeof(Boolean));
  	info->current = 0;
--- 284,290 ----
  	info->proc = HandleSelectionReplies;
  	info->widget = widget;
  	info->time = time;
! 	info->incremental = (Boolean*) __XtMalloc(count * sizeof(Boolean));
  	(void) memmove((char*)info->incremental, (char*) incremental,
  		       count * sizeof(Boolean));
  	info->current = 0;
***************
*** 714,720 ****
      req->requestor = event->requestor;
  
      if (timestamp_target) {
! 	value = XtMalloc(sizeof(long));
  	*(long*)value = ctx->time;
  	targetType = XA_INTEGER;
  	length = 1;
--- 714,720 ----
      req->requestor = event->requestor;
  
      if (timestamp_target) {
! 	value = __XtMalloc(sizeof(long));
  	*(long*)value = ctx->time;
  	targetType = XA_INTEGER;
  	length = 1;
***************
*** 1191,1197 ****
        if (info->incremental[n]) {
  #ifdef XT_COPY_SELECTION
  	  int size = BYTELENGTH(length, info->format) + 1;
! 	  char *tmp = XtMalloc((Cardinal) size);
  	  (void) memmove(tmp, value, size);
  	  XFree(value);
  	  value = tmp;
--- 1191,1197 ----
        if (info->incremental[n]) {
  #ifdef XT_COPY_SELECTION
  	  int size = BYTELENGTH(length, info->format) + 1;
! 	  char *tmp = __XtMalloc((Cardinal) size);
  	  (void) memmove(tmp, value, size);
  	  XFree(value);
  	  value = tmp;
***************
*** 1287,1293 ****
  	    ninfo = MakeInfo(info->ctx, &info->callbacks[number], 
  			     &info->req_closure[number], 1, widget, 
  			     info->time, &info->incremental[number], &property);
! 	    ninfo->target = (Atom *) XtMalloc((unsigned) sizeof(Atom));
  	    *ninfo->target = info->target[number + 1];
  	    info = ninfo;
  	}
--- 1287,1293 ----
  	    ninfo = MakeInfo(info->ctx, &info->callbacks[number], 
  			     &info->req_closure[number], 1, widget, 
  			     info->time, &info->incremental[number], &property);
! 	    ninfo->target = (Atom *) __XtMalloc((unsigned) sizeof(Atom));
  	    *ninfo->target = info->target[number + 1];
  	    info = ninfo;
  	}
***************
*** 1299,1305 ****
  #ifdef XT_COPY_SELECTION
      if (value) {   /* it could have been deleted after the SelectionNotify */
  	int size = BYTELENGTH(length, info->format) + 1;
! 	char *tmp = XtMalloc((Cardinal) size);
  	(void) memmove(tmp, value, size);
  	XFree(value);
  	value = (unsigned char *) tmp;
--- 1299,1305 ----
  #ifdef XT_COPY_SELECTION
      if (value) {   /* it could have been deleted after the SelectionNotify */
  	int size = BYTELENGTH(length, info->format) + 1;
! 	char *tmp = __XtMalloc((Cardinal) size);
  	(void) memmove(tmp, value, size);
  	XFree(value);
  	value = (unsigned char *) tmp;
***************
*** 1310,1316 ****
  
      if (info->incremental[number]) {
  	/* let requestor know the whole thing has been received */
! 	value = (unsigned char*)XtMalloc((unsigned)1);
  	length = 0;
  	(*info->callbacks[number])(widget, closure, &selection,
  				   &type, (XtPointer)value, &length, &format);
--- 1310,1316 ----
  
      if (info->incremental[number]) {
  	/* let requestor know the whole thing has been received */
! 	value = (unsigned char*)__XtMalloc((unsigned)1);
  	length = 0;
  	(*info->callbacks[number])(widget, closure, &selection,
  				   &type, (XtPointer)value, &length, &format);
***************
*** 1336,1342 ****
      if (info->incremental[info->current]) /* requestor wants incremental too */
  	info->value = NULL;	/* so no need for buffer to assemble value */
      else
! 	info->value = (char *) XtMalloc((unsigned) info->bytelength);
      info->offset = 0;
  
      /* reset the timer */
--- 1336,1342 ----
      if (info->incremental[info->current]) /* requestor wants incremental too */
  	info->value = NULL;	/* so no need for buffer to assemble value */
      else
! 	info->value = (char *) __XtMalloc((unsigned) info->bytelength);
      info->offset = 0;
  
      /* reset the timer */
***************
*** 1449,1455 ****
  	    	      if (ctx->notify && (value != NULL)) {
                	        int bytelength = BYTELENGTH(length,format);
  	                /* both sides think they own this storage */
! 	                temp = XtMalloc((unsigned)bytelength);
  	                (void) memmove(temp, value, bytelength);
  	                value = temp;
  	              }
--- 1449,1455 ----
  	    	      if (ctx->notify && (value != NULL)) {
                	        int bytelength = BYTELENGTH(length,format);
  	                /* both sides think they own this storage */
! 	                temp = __XtMalloc((unsigned)bytelength);
  	                (void) memmove(temp, value, bytelength);
  	                value = temp;
  	              }
***************
*** 1456,1462 ****
  		      /* use care; older clients were never warned that
  		       * they must return a value even if length==0
  		       */
! 		     if (value == NULL) value = XtMalloc((unsigned)1);
  		     (*callback)(widget, closure, &selection, 
  			&resulttype, value, &length, &format);
  		     if (length) {
--- 1456,1462 ----
  		      /* use care; older clients were never warned that
  		       * they must return a value even if length==0
  		       */
! 		     if (value == NULL) value = __XtMalloc((unsigned)1);
  		     (*callback)(widget, closure, &selection, 
  			&resulttype, value, &length, &format);
  		     if (length) {
***************
*** 1484,1490 ****
  			    &resulttype, &value, &length, &format,
  			    &size, ctx->owner_closure, (XtRequestId*)&req);
  		  }
! 		  if (total == NULL) total = XtMalloc(1);
  		  totallength = NUMELEM(totallength, format); 
  		  (*callback)(widget, closure, &selection, &resulttype, 
  		    total,  &totallength, &format);
--- 1484,1490 ----
  			    &resulttype, &value, &length, &format,
  			    &size, ctx->owner_closure, (XtRequestId*)&req);
  		  }
! 		  if (total == NULL) total = __XtMalloc(1);
  		  totallength = NUMELEM(totallength, format); 
  		  (*callback)(widget, closure, &selection, &resulttype, 
  		    total,  &totallength, &format);
***************
*** 1503,1513 ****
  	      if (ctx->notify && (value != NULL)) {
                  int bytelength = BYTELENGTH(length,format);
  	        /* both sides think they own this storage; better copy */
! 	        temp = XtMalloc((unsigned)bytelength);
  	        (void) memmove(temp, value, bytelength);
  	        value = temp;
  	      }
! 	      if (value == NULL) value = XtMalloc((unsigned)1);
  	      (*callback)(widget, closure, &selection, &resulttype, 
  			  value, &length, &format);
  	      if (ctx->notify)
--- 1503,1513 ----
  	      if (ctx->notify && (value != NULL)) {
                  int bytelength = BYTELENGTH(length,format);
  	        /* both sides think they own this storage; better copy */
! 	        temp = __XtMalloc((unsigned)bytelength);
  	        (void) memmove(temp, value, bytelength);
  	        value = temp;
  	      }
! 	      if (value == NULL) value = __XtMalloc((unsigned)1);
  	      (*callback)(widget, closure, &selection, &resulttype, 
  			  value, &length, &format);
  	      if (ctx->notify)
***************
*** 1550,1556 ****
      else {
  	info = MakeInfo(ctx, &callback, &closure, 1, widget,
  			time, &incremental, properties);
! 	info->target = (Atom *)XtMalloc((unsigned) sizeof(Atom));
  	 *(info->target) = target;
  	RequestSelectionValue(info, selection, target);
      }
--- 1550,1556 ----
      else {
  	info = MakeInfo(ctx, &callback, &closure, 1, widget,
  			time, &incremental, properties);
! 	info->target = (Atom *)__XtMalloc((unsigned) sizeof(Atom));
  	 *(info->target) = target;
  	RequestSelectionValue(info, selection, target);
      }
***************
*** 1673,1683 ****
  			time, incremental, properties);
  	XtStackFree((XtPointer) passed_callbacks, stack_cbs);
  	  
! 	info->target = (Atom *)XtMalloc((unsigned) ((count+1) * sizeof(Atom)));
          (*info->target) = ctx->prop_list->indirect_atom;
  	(void) memmove((char *) info->target+sizeof(Atom), (char *) targets, 
  		       count * sizeof(Atom));
! 	pairs = (IndirectPair*)XtMalloc((unsigned)(count*sizeof(IndirectPair)));
  	for (p = &pairs[count-1], t = &targets[count-1], i = count - 1;
  	     p >= pairs;  p--, t--, i--) {
  	   p->target = *t;
--- 1673,1683 ----
  			time, incremental, properties);
  	XtStackFree((XtPointer) passed_callbacks, stack_cbs);
  	  
! 	info->target = (Atom *)__XtMalloc((unsigned) ((count+1) * sizeof(Atom)));
          (*info->target) = ctx->prop_list->indirect_atom;
  	(void) memmove((char *) info->target+sizeof(Atom), (char *) targets, 
  		       count * sizeof(Atom));
! 	pairs = (IndirectPair*)__XtMalloc((unsigned)(count*sizeof(IndirectPair)));
  	for (p = &pairs[count-1], t = &targets[count-1], i = count - 1;
  	     p >= pairs;  p--, t--, i--) {
  	   p->target = *t;
***************
*** 1883,1889 ****
  				     sizeof(QueuedRequest));
      while(i < count) {
        QueuedRequest newreq = (QueuedRequest) 
! 	XtMalloc(sizeof(QueuedRequestRec));
        newreq->selection = sel;
        newreq->target = targets[i];
        if (properties != NULL)
--- 1883,1889 ----
  				     sizeof(QueuedRequest));
      while(i < count) {
        QueuedRequest newreq = (QueuedRequest) 
! 	__XtMalloc(sizeof(QueuedRequestRec));
        newreq->selection = sel;
        newreq->target = targets[i];
        if (properties != NULL)
***************
*** 2003,2014 ****
      CleanupRequest(dpy, queueInfo, selection);
    else {
      /* Create it */
!     queueInfo = (QueuedRequestInfo) XtMalloc(sizeof(QueuedRequestInfoRec));
      queueInfo->count = 0;
!     queueInfo->selections = (Atom*) XtMalloc(sizeof(Atom) * 2);
      queueInfo->selections[0] = None;
      queueInfo->requests = (QueuedRequest *)
!       XtMalloc(sizeof(QueuedRequest));
    }
  
    /* Append this selection to list */
--- 2003,2014 ----
      CleanupRequest(dpy, queueInfo, selection);
    else {
      /* Create it */
!     queueInfo = (QueuedRequestInfo) __XtMalloc(sizeof(QueuedRequestInfoRec));
      queueInfo->count = 0;
!     queueInfo->selections = (Atom*) __XtMalloc(sizeof(Atom) * 2);
      queueInfo->selections[0] = None;
      queueInfo->requests = (QueuedRequest *)
!       __XtMalloc(sizeof(QueuedRequest));
    }
  
    /* Append this selection to list */
***************
*** 2191,2197 ****
  #ifdef XT_COPY_SELECTION
  	if (*value_return) {
  	    int size = BYTELENGTH(*length_return, *format_return) + 1;
! 	    char *tmp = XtMalloc((Cardinal) size);
  	    (void) memmove(tmp, *value_return, size);
  	    XFree(*value_return);
  	    *value_return = tmp;
--- 2191,2197 ----
  #ifdef XT_COPY_SELECTION
  	if (*value_return) {
  	    int size = BYTELENGTH(*length_return, *format_return) + 1;
! 	    char *tmp = __XtMalloc((Cardinal) size);
  	    (void) memmove(tmp, *value_return, size);
  	    XFree(*value_return);
  	    *value_return = tmp;
***************
*** 2222,2228 ****
  
      if (XFindContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
  		     (XPointer *) &pinfo)) {
! 	pinfo = (ParamInfo) XtMalloc(sizeof(ParamInfoRec));
  	pinfo->count = 1;
  	pinfo->paramlist = XtNew(ParamRec);
  	p = pinfo->paramlist;
--- 2222,2228 ----
  
      if (XFindContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
  		     (XPointer *) &pinfo)) {
! 	pinfo = (ParamInfo) __XtMalloc(sizeof(ParamInfoRec));
  	pinfo->count = 1;
  	pinfo->paramlist = XtNew(ParamRec);
  	p = pinfo->paramlist;
*** xc/lib/Xt/SetWMCW.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:46 1994
--- xc/lib/Xt/SetWMCW.c	Thu May 15 17:27:41 1997
***************
*** 1,4 ****
! /* $XConsortium: SetWMCW.c,v 1.9 94/04/17 20:14:46 kaleb Exp $ */
  
  /*
   * Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
--- 1,4 ----
! /* $TOG: SetWMCW.c /main/10 1997/05/15 17:30:56 kaleb $ */
  
  /*
   * Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
***************
*** 78,84 ****
  	return;
      }
  
!     top = checked = (Widget *) XtMalloc( (Cardinal) sizeof(Widget) * count);
  
  
  /*
--- 78,84 ----
  	return;
      }
  
!     top = checked = (Widget *) __XtMalloc( (Cardinal) sizeof(Widget) * count);
  
  
  /*
***************
*** 122,128 ****
   * windows and set the property.
   */
  
!     data = (Window *) XtMalloc( (Cardinal) sizeof(Window) * checked_count);
  
      for ( i = 0 ; i < checked_count ; i++)
  	data[i] = XtWindow(top[i]);
--- 122,128 ----
   * windows and set the property.
   */
  
!     data = (Window *) __XtMalloc( (Cardinal) sizeof(Window) * checked_count);
  
      for ( i = 0 ; i < checked_count ; i++)
  	data[i] = XtWindow(top[i]);
*** xc/lib/Xt/Shell.c@@/PUBLIC-LATEST	Sat Sep 28 16:55:11 1996
--- xc/lib/Xt/Shell.c	Thu May 15 17:27:48 1997
***************
*** 1,4 ****
! /* $XConsortium: Shell.c /main/175 1996/09/28 16:46:51 rws $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: Shell.c /main/177 1997/05/15 17:31:03 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 1604,1609 ****
--- 1604,1615 ----
  	        }
  		return;
  
+               case MapNotify:
+                 if (XtIsTopLevelShell(wid)) {
+                     ((TopLevelShellWidget)wid)->topLevel.iconic = FALSE;
+                 }
+                 return;
+ 
  	      case UnmapNotify:
  		{
  		    XtPerDisplayInput	pdi;
***************
*** 1610,1615 ****
--- 1616,1624 ----
  		    XtDevice		device;
  		    Widget		p;
  
+                     if (XtIsTopLevelShell(wid))
+                         ((TopLevelShellWidget)wid)->topLevel.iconic = TRUE;
+   
  		    pdi = _XtGetPerDisplayInput(event->xunmap.display);
  
  		    device = &pdi->pointer;
***************
*** 2473,2479 ****
  	nbytes++;
      }
      num = (count+1) * sizeof(String);
!     new = newarray = (String *) XtMalloc(num + nbytes);
      sptr = ((char *) new) + num;
  
      for (str = strarray; count--; str++) {
--- 2482,2488 ----
  	nbytes++;
      }
      num = (count+1) * sizeof(String);
!     new = newarray = (String *) __XtMalloc(num + nbytes);
      sptr = ((char *) new) + num;
  
      for (str = strarray; count--; str++) {
***************
*** 2842,2848 ****
  	nbytes++;
      }
      num = (num + 1) * sizeof(String);
!     new = newarray = (String *) XtMalloc(num + nbytes);
      sptr = ((char *) new) + num;
  
      for (str = strarray; *str; str++) {
--- 2851,2857 ----
  	nbytes++;
      }
      num = (num + 1) * sizeof(String);
!     new = newarray = (String *) __XtMalloc(num + nbytes);
      sptr = ((char *) new) + num;
  
      for (str = strarray; *str; str++) {
***************
*** 2871,2877 ****
      unsigned char *prop = (unsigned char *) closure;
      SmProp *p;
  
!     p = (SmProp *) XtMalloc(sizeof(SmProp) + sizeof(SmPropValue));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = 1;
      p->type = SmCARD8;
--- 2880,2886 ----
      unsigned char *prop = (unsigned char *) closure;
      SmProp *p;
  
!     p = (SmProp *) __XtMalloc(sizeof(SmProp) + sizeof(SmPropValue));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = 1;
      p->type = SmCARD8;
***************
*** 2888,2894 ****
      String prop = *(String *) closure;
      SmProp *p;
  
!     p = (SmProp *) XtMalloc(sizeof(SmProp) + sizeof(SmPropValue));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = 1;
      p->type = SmARRAY8;
--- 2897,2903 ----
      String prop = *(String *) closure;
      SmProp *p;
  
!     p = (SmProp *) __XtMalloc(sizeof(SmProp) + sizeof(SmPropValue));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = 1;
      p->type = SmARRAY8;
***************
*** 2910,2916 ****
  
      for (ptr = prop; *ptr; ptr++)
  	n++;
!     p = (SmProp*) XtMalloc(sizeof(SmProp) + (Cardinal)(n*sizeof(SmPropValue)));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = n;
      p->type = SmLISTofARRAY8;
--- 2919,2925 ----
  
      for (ptr = prop; *ptr; ptr++)
  	n++;
!     p = (SmProp*) __XtMalloc(sizeof(SmProp) + (Cardinal)(n*sizeof(SmPropValue)));
      p->vals = (SmPropValue *) (((char *) p) + sizeof(SmProp));
      p->num_vals = n;
      p->type = SmLISTofARRAY8;
***************
*** 3209,3215 ****
      else 
  	return (XtCheckpointToken) NULL;
  
!     token = (XtCheckpointToken) XtMalloc(sizeof(XtCheckpointTokenRec));
      token->save_type = save->save_type;
      token->interact_style = save->interact_style;
      token->shutdown = save->shutdown;
--- 3218,3224 ----
      else 
  	return (XtCheckpointToken) NULL;
  
!     token = (XtCheckpointToken) __XtMalloc(sizeof(XtCheckpointTokenRec));
      token->save_type = save->save_type;
      token->interact_style = save->interact_style;
      token->shutdown = save->shutdown;
***************
*** 3378,3384 ****
  	count++;
  
      if (want) {
! 	s = new = (String *) XtMalloc((Cardinal)(count+3) * sizeof(String*));
  	*s = *sarray;		s++; sarray++;
  	*s = "-xtsessionID";	s++;
  	*s = str;		s++;
--- 3387,3393 ----
  	count++;
  
      if (want) {
! 	s = new = (String *) __XtMalloc((Cardinal)(count+3) * sizeof(String*));
  	*s = *sarray;		s++; sarray++;
  	*s = "-xtsessionID";	s++;
  	*s = str;		s++;
***************
*** 3388,3394 ****
      } else {
  	if (count < 3)
  	    return NewStringArray(sarray);
! 	s = new = (String *) XtMalloc((Cardinal)(count-1) * sizeof(String*));
  	for (; --count >= 0; sarray++) {
  	    if (strcmp(*sarray, "-xtsessionID") == 0) {
  		sarray++;
--- 3397,3403 ----
      } else {
  	if (count < 3)
  	    return NewStringArray(sarray);
! 	s = new = (String *) __XtMalloc((Cardinal)(count-1) * sizeof(String*));
  	for (; --count >= 0; sarray++) {
  	    if (strcmp(*sarray, "-xtsessionID") == 0) {
  		sarray++;
*** xc/lib/Xt/TMaction.c@@/PUBLIC-LATEST	Wed Jun 28 16:03:40 1995
--- xc/lib/Xt/TMaction.c	Thu May 15 17:27:59 1997
***************
*** 1,4 ****
! /* $XConsortium: TMaction.c,v 1.27 95/06/28 16:03:40 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $TOG: TMaction.c /main/28 1997/05/15 17:31:14 kaleb $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 105,111 ****
  
      if (! stat) {
  	cTableHold = cActions = (CompiledActionTable)
! 	    XtMalloc(count * sizeof(CompiledAction));
  
  	for (i=count; --i >= 0; cActions++, actions++) {
  	    cActions->proc = actions->proc;
--- 105,111 ----
  
      if (! stat) {
  	cTableHold = cActions = (CompiledActionTable)
! 	    __XtMalloc(count * sizeof(CompiledAction));
  
  	for (i=count; --i >= 0; cActions++, actions++) {
  	    cActions->proc = actions->proc;
***************
*** 437,443 ****
        {
  	  *bindCachePtr = 
  	    bindCache = (TMBindCache)
! 	      XtMalloc(sizeof(TMBindCacheRec) + 
  		       (procsSize - sizeof(XtActionProc)));
  	  bindCache->next = NULL;
  	  bindCache->status = *bindStatus;
--- 437,443 ----
        {
  	  *bindCachePtr = 
  	    bindCache = (TMBindCache)
! 	      __XtMalloc(sizeof(TMBindCacheRec) + 
  		       (procsSize - sizeof(XtActionProc)));
  	  bindCache->next = NULL;
  	  bindCache->status = *bindStatus;
***************
*** 775,781 ****
      *num_actions_return = widget_class->core_class.num_actions;
      if (*num_actions_return) {
  	list = *actions_return = (XtActionList) 
! 	    XtMalloc(*num_actions_return * sizeof(XtActionsRec));
  	table = GetClassActions(widget_class);
  	for (i= (*num_actions_return); --i >= 0; list++, table++) {
  	    list->string = XrmQuarkToString(table->signature);
--- 775,781 ----
      *num_actions_return = widget_class->core_class.num_actions;
      if (*num_actions_return) {
  	list = *actions_return = (XtActionList) 
! 	    __XtMalloc(*num_actions_return * sizeof(XtActionsRec));
  	table = GetClassActions(widget_class);
  	for (i= (*num_actions_return); --i >= 0; list++, table++) {
  	    list->string = XrmQuarkToString(table->signature);
*** xc/lib/Xt/TMkey.c@@/PUBLIC-LATEST	Thu Nov 30 19:05:58 1995
--- xc/lib/Xt/TMkey.c	Thu May 15 17:28:06 1997
***************
*** 1,4 ****
! /* $XConsortium: TMkey.c /main/30 1995/11/30 19:05:20 kaleb $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $TOG: TMkey.c /main/32 1997/05/15 17:31:22 kaleb $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 426,436 ****
  	XtFree((char *)pd->modKeysyms);
      if (pd->modsToKeysyms)
  	XtFree((char *)pd->modsToKeysyms);
!     pd->modKeysyms = (KeySym*)XtMalloc((Cardinal)KeysymTableSize*sizeof(KeySym));
      maxCount = KeysymTableSize;
      tempCount = 0;
  
!     table = (ModToKeysymTable*)XtMalloc((Cardinal)8*sizeof(ModToKeysymTable));
      pd->modsToKeysyms = table;
  
      table[0].mask = ShiftMask;
--- 426,436 ----
  	XtFree((char *)pd->modKeysyms);
      if (pd->modsToKeysyms)
  	XtFree((char *)pd->modsToKeysyms);
!     pd->modKeysyms = (KeySym*)__XtMalloc((Cardinal)KeysymTableSize*sizeof(KeySym));
      maxCount = KeysymTableSize;
      tempCount = 0;
  
!     table = (ModToKeysymTable*)__XtMalloc((Cardinal)8*sizeof(ModToKeysymTable));
      pd->modsToKeysyms = table;
  
      table[0].mask = ShiftMask;
***************
*** 634,640 ****
      LOCK_APP(app);
      pd = _XtGetPerDisplay(dpy);
  
!     ptr = (CaseConverterPtr) XtMalloc(sizeof(CaseConverterRec));
      ptr->start = start;
      ptr->stop = stop;
      ptr->proc = proc;
--- 634,640 ----
      LOCK_APP(app);
      pd = _XtGetPerDisplay(dpy);
  
!     ptr = (CaseConverterPtr) __XtMalloc(sizeof(CaseConverterRec));
      ptr->start = start;
      ptr->stop = stop;
      ptr->proc = proc;
***************
*** 720,726 ****
  	    if (ncodes == maxcodes) {
  		KeyCode *old = keycodes;
  		maxcodes += KEYCODE_ARRAY_SIZE;
! 		keycodes = (KeyCode*)XtMalloc(maxcodes*sizeof(KeyCode));
  		if (ncodes) {
  		    (void) memmove((char *)keycodes, (char *)old, 
  				   ncodes*sizeof(KeyCode) );
--- 720,726 ----
  	    if (ncodes == maxcodes) {
  		KeyCode *old = keycodes;
  		maxcodes += KEYCODE_ARRAY_SIZE;
! 		keycodes = (KeyCode*)__XtMalloc(maxcodes*sizeof(KeyCode));
  		if (ncodes) {
  		    (void) memmove((char *)keycodes, (char *)old, 
  				   ncodes*sizeof(KeyCode) );
*** xc/lib/Xt/TMparse.c@@/PUBLIC-LATEST	Fri Jun  3 16:27:01 1994
--- xc/lib/Xt/TMparse.c	Thu May 15 17:28:14 1997
***************
*** 1,4 ****
! /* $XConsortium: TMparse.c,v 1.142 94/06/03 16:27:01 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: TMparse.c /main/119 1997/05/15 17:31:29 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 1647,1653 ****
  		&& *str != ')'
                  && *str != '\n'
  		&& *str != '\0') str++;
! 	*strP = XtMalloc((unsigned)(str-start+1));
  	(void) memmove(*strP, start, str-start);
  	(*strP)[str-start] = '\0';
      }
--- 1647,1653 ----
  		&& *str != ')'
                  && *str != '\n'
  		&& *str != '\0') str++;
! 	*strP = __XtMalloc((unsigned)(str-start+1));
  	(void) memmove(*strP, start, str-start);
  	(*strP)[str-start] = '\0';
      }
***************
*** 1692,1698 ****
  
      if (num_params != 0) {
  	String *paramP = (String *)
! 		XtMalloc( (unsigned)(num_params+1) * sizeof(String) );
  	*paramSeqP = paramP;
  	*paramNumP = num_params;
  	paramP += num_params; /* list is LIFO right now */
--- 1692,1698 ----
  
      if (num_params != 0) {
  	String *paramP = (String *)
! 		__XtMalloc( (unsigned)(num_params+1) * sizeof(String) );
  	*paramSeqP = paramP;
  	*paramNumP = num_params;
  	paramP += num_params; /* list is LIFO right now */
*** xc/lib/Xt/TMprint.c@@/PUBLIC-LATEST	Sun Apr 17 20:14:55 1994
--- xc/lib/Xt/TMprint.c	Thu May 15 17:28:23 1997
***************
*** 1,4 ****
! /* $XConsortium: TMprint.c,v 1.14 94/04/17 20:14:55 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $TOG: TMprint.c /main/15 1997/05/15 17:31:38 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 686,692 ****
  #endif /* TRACE_TM */
      if (xlations == NULL) return NULL;
  
!     sb->current = sb->start = XtMalloc((Cardinal)1000);
      sb->max = 1000;
      maxPrints = 0;
      for (i = 0; i < xlations->numStateTrees; i++)
--- 686,692 ----
  #endif /* TRACE_TM */
      if (xlations == NULL) return NULL;
  
!     sb->current = sb->start = __XtMalloc((Cardinal)1000);
      sb->max = 1000;
      maxPrints = 0;
      for (i = 0; i < xlations->numStateTrees; i++)
***************
*** 783,789 ****
  	(bindData->simple.isComplex == False))
        return;
  
!     sb->current = sb->start = XtMalloc((Cardinal)1000);
      sb->start[0] = '\0';
      sb->max = 1000;
      maxPrints = 0;
--- 783,789 ----
  	(bindData->simple.isComplex == False))
        return;
  
!     sb->current = sb->start = __XtMalloc((Cardinal)1000);
      sb->start[0] = '\0';
      sb->max = 1000;
      maxPrints = 0;
***************
*** 829,835 ****
      TMStringBufRec	sbRec, *sb = &sbRec;
   
      sb->max = 1000;
!     sb->current = sb->start = XtMalloc((Cardinal)1000);
      PrintActions(sb, 
  		 actions,
  		 quarkTbl,
--- 829,835 ----
      TMStringBufRec	sbRec, *sb = &sbRec;
   
      sb->max = 1000;
!     sb->current = sb->start = __XtMalloc((Cardinal)1000);
      PrintActions(sb, 
  		 actions,
  		 quarkTbl,
***************
*** 843,849 ****
  {
      TMStringBufRec	sbRec, *sb = &sbRec;
  
!     sb->current = sb->start = XtMalloc((Cardinal)1000);
      sb->max = 1000;
      PrintState(sb, stateTree, branchHead,
  	       True, (Widget)NULL, (Display *)NULL);
--- 843,849 ----
  {
      TMStringBufRec	sbRec, *sb = &sbRec;
  
!     sb->current = sb->start = __XtMalloc((Cardinal)1000);
      sb->max = 1000;
      PrintState(sb, stateTree, branchHead,
  	       True, (Widget)NULL, (Display *)NULL);
***************
*** 863,869 ****
      TMShortCard		i, j;
      Boolean		cycle = False;
  
!     sb->current = sb->start = XtMalloc((Cardinal)1000);
      sb->max = 1000;
      for (i = 0;
  	 i < MAXSEQS && eventSeq != NULL && !cycle;
--- 863,869 ----
      TMShortCard		i, j;
      Boolean		cycle = False;
  
!     sb->current = sb->start = __XtMalloc((Cardinal)1000);
      sb->max = 1000;
      for (i = 0;
  	 i < MAXSEQS && eventSeq != NULL && !cycle;
*** xc/lib/Xt/TMstate.c@@/PUBLIC-LATEST	Thu Jun 22 17:19:25 1995
--- xc/lib/Xt/TMstate.c	Thu May 15 17:28:30 1997
***************
*** 1,4 ****
! /* $XConsortium: TMstate.c,v 1.176 95/06/22 17:19:25 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $TOG: TMstate.c /main/152 1997/05/15 17:31:46 kaleb $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 122,128 ****
  	  newSize = (parseTree->branchHeadTblSize * sizeof(TMBranchHeadRec));
  	  if (parseTree->isStackBranchHeads) {
  	      TMBranchHead	oldBranchHeadTbl = parseTree->branchHeadTbl;
! 	      parseTree->branchHeadTbl = (TMBranchHead) XtMalloc(newSize);
  	      XtMemmove(parseTree->branchHeadTbl, oldBranchHeadTbl, newSize);
  	      parseTree->isStackBranchHeads = False;
  	  }
--- 122,128 ----
  	  newSize = (parseTree->branchHeadTblSize * sizeof(TMBranchHeadRec));
  	  if (parseTree->isStackBranchHeads) {
  	      TMBranchHead	oldBranchHeadTbl = parseTree->branchHeadTbl;
! 	      parseTree->branchHeadTbl = (TMBranchHead) __XtMalloc(newSize);
  	      XtMemmove(parseTree->branchHeadTbl, oldBranchHeadTbl, newSize);
  	      parseTree->isStackBranchHeads = False;
  	  }
***************
*** 175,181 ****
  
  		if (parseTree->isStackQuarks) {
  		    XrmQuark	*oldquarkTbl = parseTree->quarkTbl;
! 		    parseTree->quarkTbl = (XrmQuark *) XtMalloc(newSize);
  		    XtMemmove(parseTree->quarkTbl, oldquarkTbl, newSize);
  		    parseTree->isStackQuarks = False;
  		}
--- 175,181 ----
  
  		if (parseTree->isStackQuarks) {
  		    XrmQuark	*oldquarkTbl = parseTree->quarkTbl;
! 		    parseTree->quarkTbl = (XrmQuark *) __XtMalloc(newSize);
  		    XtMemmove(parseTree->quarkTbl, oldquarkTbl, newSize);
  		    parseTree->isStackQuarks = False;
  		}
***************
*** 217,223 ****
  	if (parseTree->isStackComplexBranchHeads) {
  	    StatePtr *oldcomplexBranchHeadTbl 
  	      = parseTree->complexBranchHeadTbl;
! 	    parseTree->complexBranchHeadTbl = (StatePtr *) XtMalloc(newSize);
  	    XtMemmove(parseTree->complexBranchHeadTbl, 
  		      oldcomplexBranchHeadTbl, newSize);
  	    parseTree->isStackComplexBranchHeads = False;
--- 217,223 ----
  	if (parseTree->isStackComplexBranchHeads) {
  	    StatePtr *oldcomplexBranchHeadTbl 
  	      = parseTree->complexBranchHeadTbl;
! 	    parseTree->complexBranchHeadTbl = (StatePtr *) __XtMalloc(newSize);
  	    XtMemmove(parseTree->complexBranchHeadTbl, 
  		      oldcomplexBranchHeadTbl, newSize);
  	    parseTree->isStackComplexBranchHeads = False;
***************
*** 268,274 ****
  	}
  	_XtGlobalTM.typeMatchSegmentTbl[_XtGlobalTM.numTypeMatchSegments++] = 
  	  segment = (TMTypeMatch)
! 	    XtMalloc(TM_TYPE_SEGMENT_SIZE * sizeof(TMTypeMatchRec));
  	j = 0;
      }
      typeMatch = &segment[j];
--- 268,274 ----
  	}
  	_XtGlobalTM.typeMatchSegmentTbl[_XtGlobalTM.numTypeMatchSegments++] = 
  	  segment = (TMTypeMatch)
! 	    __XtMalloc(TM_TYPE_SEGMENT_SIZE * sizeof(TMTypeMatchRec));
  	j = 0;
      }
      typeMatch = &segment[j];
***************
*** 362,368 ****
  	}
  	_XtGlobalTM.modMatchSegmentTbl[_XtGlobalTM.numModMatchSegments++] = 
  	  segment = (TMModifierMatch)
! 	    XtMalloc(TM_MOD_SEGMENT_SIZE * sizeof(TMModifierMatchRec));
  	j = 0;
      }
      modMatch = &segment[j];
--- 362,368 ----
  	}
  	_XtGlobalTM.modMatchSegmentTbl[_XtGlobalTM.numModMatchSegments++] = 
  	  segment = (TMModifierMatch)
! 	    __XtMalloc(TM_MOD_SEGMENT_SIZE * sizeof(TMModifierMatchRec));
  	j = 0;
      }
      modMatch = &segment[j];
***************
*** 1399,1405 ****
      TMShortCard i;
  
      xlations = (XtTranslations)
!       XtMalloc(sizeof(TranslationData) +
  	       (numStateTrees-1) * sizeof(TMStateTree));
  #ifdef TRACE_TM
      LOCK_PROCESS;
--- 1399,1405 ----
      TMShortCard i;
  
      xlations = (XtTranslations)
!       __XtMalloc(sizeof(TranslationData) +
  	       (numStateTrees-1) * sizeof(TMStateTree));
  #ifdef TRACE_TM
      LOCK_PROCESS;
***************
*** 1441,1447 ****
  	complexTree->isSimple = False;
  	tableSize = parseTree->numComplexBranchHeads * sizeof(StatePtr); 
  	complexTree->complexBranchHeadTbl = (StatePtr *)
! 	  XtMalloc(tableSize);
  	XtMemmove(complexTree->complexBranchHeadTbl,
  		  parseTree->complexBranchHeadTbl, tableSize);
  	complexTree->numComplexBranchHeads = 
--- 1441,1447 ----
  	complexTree->isSimple = False;
  	tableSize = parseTree->numComplexBranchHeads * sizeof(StatePtr); 
  	complexTree->complexBranchHeadTbl = (StatePtr *)
! 	  __XtMalloc(tableSize);
  	XtMemmove(complexTree->complexBranchHeadTbl,
  		  parseTree->complexBranchHeadTbl, tableSize);
  	complexTree->numComplexBranchHeads = 
***************
*** 1458,1469 ****
  
      tableSize = parseTree->numBranchHeads * sizeof(TMBranchHeadRec);
      simpleTree->branchHeadTbl = (TMBranchHead)
!       XtMalloc(tableSize);
      XtMemmove(simpleTree->branchHeadTbl, parseTree->branchHeadTbl, tableSize);
      simpleTree->numBranchHeads = parseTree->numBranchHeads;
  
      tableSize = parseTree->numQuarks * sizeof(XrmQuark);
!     simpleTree->quarkTbl = (XrmQuark *) XtMalloc(tableSize);
      XtMemmove(simpleTree->quarkTbl, parseTree->quarkTbl, tableSize);
      simpleTree->numQuarks = parseTree->numQuarks;
  
--- 1458,1469 ----
  
      tableSize = parseTree->numBranchHeads * sizeof(TMBranchHeadRec);
      simpleTree->branchHeadTbl = (TMBranchHead)
!       __XtMalloc(tableSize);
      XtMemmove(simpleTree->branchHeadTbl, parseTree->branchHeadTbl, tableSize);
      simpleTree->numBranchHeads = parseTree->numBranchHeads;
  
      tableSize = parseTree->numQuarks * sizeof(XrmQuark);
!     simpleTree->quarkTbl = (XrmQuark *) __XtMalloc(tableSize);
      XtMemmove(simpleTree->quarkTbl, parseTree->quarkTbl, tableSize);
      simpleTree->numQuarks = parseTree->numQuarks;
  
***************
*** 1882,1888 ****
  	       ((numBindings - 1) * 
  		sizeof(TMSimpleBindProcsRec)));
  
!     bindData = (TMBindData) XtCalloc(sizeof(char), bytes);
      bindData->simple.isComplex = isComplex;
      if (isComplex) {
  	TMComplexBindData cBindData = (TMComplexBindData)bindData;
--- 1882,1888 ----
  	       ((numBindings - 1) * 
  		sizeof(TMSimpleBindProcsRec)));
  
!     bindData = (TMBindData) __XtCalloc(sizeof(char), bytes);
      bindData->simple.isComplex = isComplex;
      if (isComplex) {
  	TMComplexBindData cBindData = (TMComplexBindData)bindData;
***************
*** 2079,2085 ****
  	Cardinal	numBindings = xlations->numStateTrees;
  
  	(*aXlationsPtr) = aXlations = (ATranslations)
! 	    XtMalloc(sizeof(ATranslationData) + 
  		     (numBindings - 1) * sizeof(TMComplexBindProcsRec));
  
  	aXlations->hasBindings = True;
--- 2079,2085 ----
  	Cardinal	numBindings = xlations->numStateTrees;
  
  	(*aXlationsPtr) = aXlations = (ATranslations)
! 	    __XtMalloc(sizeof(ATranslationData) + 
  		     (numBindings - 1) * sizeof(TMComplexBindProcsRec));
  
  	aXlations->hasBindings = True;
*** xc/lib/Xt/Threads.c@@/PUBLIC-LATEST	Sat Sep 28 16:55:33 1996
--- xc/lib/Xt/Threads.c	Thu May 15 17:28:41 1997
***************
*** 1,4 ****
! /* $XConsortium: Threads.c /main/17 1996/09/28 16:47:13 rws $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
--- 1,4 ----
! /* $TOG: Threads.c /main/18 1997/05/15 17:31:57 kaleb $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
***************
*** 59,65 ****
  
  #ifdef XTHREADS
  
! #define xmalloc XtMalloc
  #define xfree XtFree
  #include <X11/Xthreads.h>
  
--- 59,65 ----
  
  #ifdef XTHREADS
  
! #define xmalloc __XtMalloc
  #define xfree XtFree
  #include <X11/Xthreads.h>
  
***************
*** 401,407 ****
      app_lock->stack.size = STACK_INCR;
      app_lock->stack.sp = -1;
      app_lock->stack.st = 
! 	(struct _Tstack *)XtMalloc(sizeof(struct _Tstack)*STACK_INCR);
      for (ii = 0; ii < STACK_INCR; ii++) {
  	app_lock->stack.st[ii].c = xcondition_malloc();
  	xcondition_init(app_lock->stack.st[ii].c);
--- 401,407 ----
      app_lock->stack.size = STACK_INCR;
      app_lock->stack.sp = -1;
      app_lock->stack.st = 
! 	(struct _Tstack *)__XtMalloc(sizeof(struct _Tstack)*STACK_INCR);
      for (ii = 0; ii < STACK_INCR; ii++) {
  	app_lock->stack.st[ii].c = xcondition_malloc();
  	xcondition_init(app_lock->stack.st[ii].c);
*** xc/lib/Xt/VarCreate.c@@/PUBLIC-LATEST	Wed Jun  7 19:12:49 1995
--- xc/lib/Xt/VarCreate.c	Thu May 15 17:28:49 1997
***************
*** 1,4 ****
! /* $XConsortium: VarCreate.c,v 1.32 95/06/07 19:12:49 converse Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: VarCreate.c /main/33 1997/05/15 17:32:05 kaleb $ */
  
  /*
  
***************
*** 358,364 ****
      dpy = _XtAppInit(&app_con, (String)application_class, options, num_options,
  		     argc_in_out, &argv_in_out, fallback_resources);
  
!     typed_args = (XtTypedArgList) XtMalloc((unsigned) sizeof(XtTypedArg));
      attr = va_arg (var_args, String);
      for(; attr != NULL; attr = va_arg (var_args, String)) {
          if (strcmp(attr, XtVaTypedArg) == 0) {
--- 358,364 ----
      dpy = _XtAppInit(&app_con, (String)application_class, options, num_options,
  		     argc_in_out, &argv_in_out, fallback_resources);
  
!     typed_args = (XtTypedArgList) __XtMalloc((unsigned) sizeof(XtTypedArg));
      attr = va_arg (var_args, String);
      for(; attr != NULL; attr = va_arg (var_args, String)) {
          if (strcmp(attr, XtVaTypedArg) == 0) {
*** xc/lib/Xt/VarGet.c@@/PUBLIC-LATEST	Sun Apr 17 20:15:02 1994
--- xc/lib/Xt/VarGet.c	Thu May 15 17:28:57 1997
***************
*** 1,4 ****
! /* $XConsortium: VarGet.c,v 1.20 94/04/17 20:15:02 kaleb Exp $ */
  /*
  
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
--- 1,4 ----
! /* $TOG: VarGet.c /main/21 1997/05/15 17:32:13 kaleb $ */
  /*
  
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
***************
*** 268,274 ****
      _XtCountVaList(var, &total_count, &typed_count);
  
      if (total_count != typed_count) {
!         args = (ArgList)XtMalloc((unsigned)((total_count - typed_count) 
  				* sizeof(Arg)));
      }
      else args = NULL;		/* for lint; really unused */
--- 268,274 ----
      _XtCountVaList(var, &total_count, &typed_count);
  
      if (total_count != typed_count) {
!         args = (ArgList)__XtMalloc((unsigned)((total_count - typed_count) 
  				* sizeof(Arg)));
      }
      else args = NULL;		/* for lint; really unused */
*** xc/lib/Xt/Varargs.c@@/PUBLIC-LATEST	Thu Dec  7 14:25:49 1995
--- xc/lib/Xt/Varargs.c	Thu May 15 17:29:04 1997
***************
*** 1,4 ****
! /* $XConsortium: Varargs.c /main/31 1995/12/07 14:26:13 converse $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: Varargs.c /main/32 1997/05/15 17:32:20 kaleb $ */
  
  /*
  
***************
*** 160,166 ****
      XtTypedArgList  avlist;
  
      avlist = (XtTypedArgList)
! 		XtCalloc((int)count + 1, (unsigned)sizeof(XtTypedArg));
  
      for(attr = va_arg(var, String), count = 0; attr != NULL; 
  		attr = va_arg(var, String)) {
--- 160,166 ----
      XtTypedArgList  avlist;
  
      avlist = (XtTypedArgList)
! 		__XtCalloc((int)count + 1, (unsigned)sizeof(XtTypedArg));
  
      for(attr = va_arg(var, String), count = 0; attr != NULL; 
  		attr = va_arg(var, String)) {
***************
*** 264,270 ****
  	else if (to_val.size == sizeof(XtArgVal))
  	    arg_return->value = *(XtArgVal *)to_val.addr;
  	else if (to_val.size > sizeof(XtArgVal)) {
! 	    arg_return->value = (XtArgVal) XtMalloc(to_val.size);
  	    memory_return->value = (XtArgVal)
  		memcpy((void *)arg_return->value, to_val.addr, to_val.size);
  	}
--- 264,270 ----
  	else if (to_val.size == sizeof(XtArgVal))
  	    arg_return->value = *(XtArgVal *)to_val.addr;
  	else if (to_val.size > sizeof(XtArgVal)) {
! 	    arg_return->value = (XtArgVal) __XtMalloc(to_val.size);
  	    memory_return->value = (XtArgVal)
  		memcpy((void *)arg_return->value, to_val.addr, to_val.size);
  	}
***************
*** 399,405 ****
      }
  
      max_count *= 2;
!     args = (ArgList)XtMalloc((unsigned)(max_count * sizeof(Arg)));
      for (count = max_count; --count >= 0; )
  	args[count].value = (XtArgVal) NULL;
      max_count /= 2;
--- 399,405 ----
      }
  
      max_count *= 2;
!     args = (ArgList)__XtMalloc((unsigned)(max_count * sizeof(Arg)));
      for (count = max_count; --count >= 0; )
  	args[count].value = (XtArgVal) NULL;
      max_count /= 2;
***************
*** 539,545 ****
      int			count;
  
      args = (XtTypedArgList)
! 	XtMalloc((unsigned)(max_count * sizeof(XtTypedArg))); 
  
      for(attr = va_arg(var, String), count = 0 ; attr != NULL;
  		    attr = va_arg(var, String)) {
--- 539,545 ----
      int			count;
  
      args = (XtTypedArgList)
! 	__XtMalloc((unsigned)(max_count * sizeof(XtTypedArg))); 
  
      for(attr = va_arg(var, String), count = 0 ; attr != NULL;
  		    attr = va_arg(var, String)) {
*** xc/lib/font/Speedo/spfile.c@@/PUBLIC-LATEST	Sun Apr 17 20:17:47 1994
--- xc/lib/font/Speedo/spfile.c	Mon Jun  9 09:40:44 1997
***************
*** 1,4 ****
! /* $XConsortium: spfile.c,v 1.12 94/04/17 20:17:47 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
--- 1,4 ----
! /* $TOG: spfile.c /main/13 1997/06/09 09:38:27 barstow $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
***************
*** 200,205 ****
--- 200,207 ----
  
      /* open font */
      spmf->fname = (char *) xalloc(strlen(filename) + 1);
+     if (!spmf->fname)
+ 	return AllocError;
      fp = fopen(filename, "r");
      if (!fp) {
  	ret = BadFontName;
*** xc/lib/font/Speedo/spfont.c@@/PUBLIC-LATEST	Mon Jul 25 13:48:35 1994
--- xc/lib/font/Speedo/spfont.c	Mon Jun  9 09:40:36 1997
***************
*** 1,4 ****
! /* $XConsortium: spfont.c,v 1.23 94/07/25 13:48:35 kaleb Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
--- 1,4 ----
! /* $TOG: spfont.c /main/24 1997/06/09 09:38:19 barstow $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
***************
*** 346,356 ****
      esize = sizeof(CharInfoRec) * (spmf->max_id - spmf->first_char_id + 1);
  
      spf->encoding = (CharInfoPtr) xalloc(esize);
-     bzero((char *) spf->encoding, esize);
      if (!spf->encoding) {
  	sp_close_font(spf);
  	return AllocError;
      }
      sp_fp_cur = spf;
  
      sp_make_header(spf, &pfont->info);
--- 346,357 ----
      esize = sizeof(CharInfoRec) * (spmf->max_id - spmf->first_char_id + 1);
  
      spf->encoding = (CharInfoPtr) xalloc(esize);
      if (!spf->encoding) {
  	sp_close_font(spf);
  	return AllocError;
      }
+     bzero((char *) spf->encoding, esize);
+ 
      sp_fp_cur = spf;
  
      sp_make_header(spf, &pfont->info);
*** xc/lib/font/Speedo/spinfo.c@@/PUBLIC-LATEST	Sun Apr 17 20:17:50 1994
--- xc/lib/font/Speedo/spinfo.c	Mon Jun  9 14:21:43 1997
***************
*** 1,4 ****
! /* $XConsortium: spinfo.c,v 1.15 94/04/17 20:17:50 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
--- 1,4 ----
! /* $TOG: spinfo.c /main/17 1997/06/09 14:19:24 barstow $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
***************
*** 93,100 ****
  static fontProp extraProps[] = {
      "FONT", 0, 0,
      "COPYRIGHT", 0, 0,
!     "RAW_PIXELSIZE", 0, 0,
!     "RAW_POINTSIZE", 0, 0,
      "RAW_ASCENT", 0, 0,
      "RAW_DESCENT", 0, 0,
      "RAW_AVERAGE_WIDTH", 0, 0,
--- 93,100 ----
  static fontProp extraProps[] = {
      "FONT", 0, 0,
      "COPYRIGHT", 0, 0,
!     "RAW_PIXEL_SIZE", 0, 0,
!     "RAW_POINT_SIZE", 0, 0,
      "RAW_ASCENT", 0, 0,
      "RAW_DESCENT", 0, 0,
      "RAW_AVERAGE_WIDTH", 0, 0,
***************
*** 210,216 ****
                  index,
  		maxOverlap,
  		overlap,
! 		total_width;
      xCharInfo   minchar,
                  maxchar,
                  tmpchar;
--- 210,216 ----
                  index,
  		maxOverlap,
  		overlap,
! 		total_width = 0;
      xCharInfo   minchar,
                  maxchar,
                  tmpchar;
*** xc/lib/font/Type1/scanfont.c@@/PUBLIC-LATEST	Sun Feb  6 16:23:17 1994
--- xc/lib/font/Type1/scanfont.c	Mon Jun  9 13:29:35 1997
***************
*** 1,4 ****
! /* $XConsortium: scanfont.c,v 1.10 94/02/06 16:23:17 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $TOG: scanfont.c /main/11 1997/06/09 13:27:16 barstow $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 921,927 ****
    objFormatBoolean(&(Private[FORCEBOLD].value),DEFAULTFORCEBOLD);
    objFormatName(&(Private[LANGUAGEGROUP].key),13,"LanguageGroup");
    objFormatInteger(&(Private[LANGUAGEGROUP].value),DEFAULTLANGUAGEGROUP);
!   objFormatName(&(Private[LENIV].key),5,"LenIV");
    objFormatInteger(&(Private[LENIV].value),DEFAULTLENIV);
    objFormatName(&(Private[RNDSTEMUP].key),9,"RndStemUp");
    objFormatBoolean(&(Private[RNDSTEMUP].value),DEFAULTRNDSTEMUP);
--- 921,927 ----
    objFormatBoolean(&(Private[FORCEBOLD].value),DEFAULTFORCEBOLD);
    objFormatName(&(Private[LANGUAGEGROUP].key),13,"LanguageGroup");
    objFormatInteger(&(Private[LANGUAGEGROUP].value),DEFAULTLANGUAGEGROUP);
!   objFormatName(&(Private[LENIV].key),5,"lenIV");
    objFormatInteger(&(Private[LENIV].value),DEFAULTLENIV);
    objFormatName(&(Private[RNDSTEMUP].key),9,"RndStemUp");
    objFormatBoolean(&(Private[RNDSTEMUP].value),DEFAULTRNDSTEMUP);
*** xc/lib/font/Type1/t1funcs.c@@/PUBLIC-LATEST	Sat Sep 28 16:56:06 1996
--- xc/lib/font/Type1/t1funcs.c	Mon Jun  9 14:58:03 1997
***************
*** 1,4 ****
! /* $XConsortium: t1funcs.c /main/22 1996/09/28 16:47:46 rws $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $TOG: t1funcs.c /main/23 1997/06/09 14:55:44 barstow $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 211,216 ****
--- 211,218 ----
         /* load font if not already loaded */
         if (!fontfcnA(fileName, &rc)) {
           delmemory();
+ 	 xfree(type1);
+ 	 xfree(pFont);
           xfree(pool);
           return Type1ReturnCodeToXReturnCode(rc);
         }
*** xc/lib/font/Type1/t1info.c@@/PUBLIC-LATEST	Sun Apr 17 20:17:23 1994
--- xc/lib/font/Type1/t1info.c	Mon Jun  9 11:24:12 1997
***************
*** 1,4 ****
! /* $XConsortium: t1info.c,v 1.19 94/04/17 20:17:23 dpw Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $TOG: t1info.c /main/20 1997/06/09 11:21:53 barstow $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 128,135 ****
  static fontProp extraProps[] = {
      "FONT", 0, 0,
      "COPYRIGHT", 0, 0,
!     "RAW_PIXELSIZE", 0, 0,
!     "RAW_POINTSIZE", 0, 0,
      "RAW_ASCENT", 0, 0,
      "RAW_DESCENT", 0, 0,
      "RAW_AVERAGE_WIDTH", 0, 0,
--- 128,135 ----
  static fontProp extraProps[] = {
      "FONT", 0, 0,
      "COPYRIGHT", 0, 0,
!     "RAW_PIXEL_SIZE", 0, 0,
!     "RAW_POINT_SIZE", 0, 0,
      "RAW_ASCENT", 0, 0,
      "RAW_DESCENT", 0, 0,
      "RAW_AVERAGE_WIDTH", 0, 0,
*** xc/lib/font/bitmap/bitscale.c@@/PUBLIC-LATEST	Sat Sep 28 16:56:40 1996
--- xc/lib/font/bitmap/bitscale.c	Mon Jun  9 11:24:04 1997
***************
*** 1,4 ****
! /* $XConsortium: bitscale.c /main/30 1996/09/28 16:48:20 rws $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: bitscale.c /main/31 1997/06/09 11:21:46 barstow $ */
  
  /*
  
***************
*** 116,123 ****
      "FONT", 0, fontname,
      "RAW_ASCENT", 0, raw_ascent,
      "RAW_DESCENT", 0, raw_descent,
!     "RAW_PIXELSIZE", 0, raw_pixelsize,
!     "RAW_POINTSIZE", 0, raw_pointsize,
      "RAW_AVERAGE_WIDTH", 0, raw_average_width
  };
  
--- 116,123 ----
      "FONT", 0, fontname,
      "RAW_ASCENT", 0, raw_ascent,
      "RAW_DESCENT", 0, raw_descent,
!     "RAW_PIXEL_SIZE", 0, raw_pixelsize,
!     "RAW_POINT_SIZE", 0, raw_pointsize,
      "RAW_AVERAGE_WIDTH", 0, raw_average_width
  };
  
*** xc/lib/font/fc/fserve.c@@/PUBLIC-LATEST	Sat Sep 28 16:57:01 1996
--- xc/lib/font/fc/fserve.c	Tue Jun 10 11:26:15 1997
***************
*** 1,4 ****
! /* $XConsortium: fserve.c /main/46 1996/09/28 16:48:41 rws $ */
  /*
  
  Copyright (c) 1990  X Consortium
--- 1,4 ----
! /* $TOG: fserve.c /main/49 1997/06/10 11:23:56 barstow $ */
  /*
  
  Copyright (c) 1990  X Consortium
***************
*** 337,347 ****
  
      /* XXX - hack.  The right fix is to remember that the font server
         has gone away when we first discovered it. */
!     if (!conn->trans_conn)
! 	return;
  
-     (void) _FontTransClose (conn->trans_conn);
- 
      FD_CLR(conn->fs_fd, &_fs_fd_mask);
  
      for (client = conn->clients; client; client = nclient) 
--- 337,345 ----
  
      /* XXX - hack.  The right fix is to remember that the font server
         has gone away when we first discovered it. */
!     if (conn->trans_conn)
!         (void) _FontTransClose (conn->trans_conn);
  
      FD_CLR(conn->fs_fd, &_fs_fd_mask);
  
      for (client = conn->clients; client; client = nclient) 
***************
*** 1227,1233 ****
  
      /* see if there's any data to be read */
  
!     /* ### Workaround disappearing fontservers */
      if (conn->fs_fd == -1)
  	return FALSE;
  
--- 1225,1234 ----
  
      /* see if there's any data to be read */
  
!     /* 
!      * Don't continue if the fd is -1 (which will be true when the
!      * font server terminates
!      */
      if (conn->fs_fd == -1)
  	return FALSE;
  
***************
*** 1251,1257 ****
  	/* find the matching block record */
  
  	for (br = (FSBlockDataPtr) conn->blocked_requests; br; br = br->next) {
! 	    if (br->sequence_number == (rep.sequenceNumber - 1))
  		break;
  	}
  	if (!br) {
--- 1252,1259 ----
  	/* find the matching block record */
  
  	for (br = (FSBlockDataPtr) conn->blocked_requests; br; br = br->next) {
! 	    if ((CARD16)(br->sequence_number & 0xffff) ==
! 		(CARD16)(rep.sequenceNumber - 1))
  		break;
  	}
  	if (!br) {
*** xc/lib/font/fontfile/fontfile.c@@/PUBLIC-LATEST	Tue Feb 21 14:17:19 1995
--- xc/lib/font/fontfile/fontfile.c	Fri May 23 16:39:09 1997
***************
*** 1,4 ****
! /* $XConsortium: fontfile.c,v 1.28 95/02/21 14:17:19 mor Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: fontfile.c /main/29 1997/05/23 16:36:56 barstow $ */
  
  /*
  
***************
*** 83,89 ****
  	/* can't do it, so tell the caller to close and re-open */
  	return FPEResetFailed;	
      }
!     return Successful;
  }
  
  int
--- 83,97 ----
  	/* can't do it, so tell the caller to close and re-open */
  	return FPEResetFailed;	
      }
!     else 
!     {
! 	if (dir->nonScalable.used > 0)
! 	    if (!FontFileRegisterBitmapSource (fpe))
! 	    {
! 	        return FPEResetFailed;	
! 	    }
!         return Successful;
!     }
  }
  
  int
*** xc/lib/font/include/fontmisc.h@@/PUBLIC-LATEST	Sun Apr 17 20:17:29 1994
--- xc/lib/font/include/fontmisc.h	Tue Jun 10 14:16:29 1997
***************
*** 1,4 ****
! /* $XConsortium: fontmisc.h,v 1.6 94/04/17 20:17:29 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: fontmisc.h /main/7 1997/06/10 14:11:11 barstow $ */
  
  /*
  
***************
*** 38,47 ****
--- 38,55 ----
  
  typedef unsigned char	*pointer;
  typedef int		Bool;
+ 
  #ifndef X_PROTOCOL
+ #ifndef _XSERVER64
  typedef unsigned long	Atom;
  typedef unsigned long	XID;
+ #else
+ #include <X11/Xmd.h>
+ typedef CARD32 XID;
+ typedef CARD32 Atom;
+ #endif 
  #endif
+ 
  #ifndef LSBFirst
  #define LSBFirst	0
  #define MSBFirst	1
*** xc/lib/font/util/patcache.c@@/PUBLIC-LATEST	Sun Apr 17 20:17:37 1994
--- xc/lib/font/util/patcache.c	Thu Jun 12 11:54:07 1997
***************
*** 1,4 ****
! /* $XConsortium: patcache.c,v 1.7 94/04/17 20:17:37 gildea Exp $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: patcache.c /main/8 1997/06/12 11:51:59 barstow $ */
  
  /*
  
***************
*** 115,121 ****
      
      for (i = 0; i < NBUCKETS; i++)
  	cache->buckets[i] = 0;
!     for (i = 0; i < NENTRIES - 1; i++)
      {
  	cache->entries[i].next = &cache->entries[i+1];
  	cache->entries[i].prev = 0;
--- 115,121 ----
      
      for (i = 0; i < NBUCKETS; i++)
  	cache->buckets[i] = 0;
!     for (i = 0; i < NENTRIES; i++)
      {
  	cache->entries[i].next = &cache->entries[i+1];
  	cache->entries[i].prev = 0;
***************
*** 125,131 ****
  	cache->entries[i].patlen = 0;
      }
      cache->free = &cache->entries[0];
!     cache->entries[i].next = 0;
  }
  
  /* add entry */
--- 125,131 ----
  	cache->entries[i].patlen = 0;
      }
      cache->free = &cache->entries[0];
!     cache->entries[NENTRIES - 1].next = 0;
  }
  
  /* add entry */
*** xc/lib/xkbfile/cout.c@@/PUBLIC-LATEST	Sat Aug 31 12:48:57 1996
--- xc/lib/xkbfile/cout.c	Tue Jun 10 07:03:00 1997
***************
*** 1,4 ****
! /* $XConsortium: cout.c /main/4 1996/08/31 12:45:09 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: cout.c /main/5 1997/06/10 06:53:31 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 445,451 ****
  	else fprintf(file,"{    0,    0 }");
      }
      fprintf(file,"\n};\n");
!     fprintf(file,"static unsigned char explicit[NUM_KEYS]= {\n");
      for (i=0;i<=xkb->max_key_code;i++) {
  	if (i==0)		fprintf(file,"    ");
  	else if ((i&0x7)==0)	fprintf(file,",\n    ");
--- 445,451 ----
  	else fprintf(file,"{    0,    0 }");
      }
      fprintf(file,"\n};\n");
!     fprintf(file,"static unsigned char explicit_parts[NUM_KEYS]= {\n");
      for (i=0;i<=xkb->max_key_code;i++) {
  	if (i==0)		fprintf(file,"    ");
  	else if ((i&0x7)==0)	fprintf(file,",\n    ");
***************
*** 468,474 ****
      fprintf(file,"static XkbServerMapRec serverMap= {\n");
      fprintf(file,"    %d, %d, (XkbAction *)actionCache,\n",
  				xkb->server->num_acts,xkb->server->num_acts);
!     fprintf(file,"    behaviors, keyActions, explicit,\n");
      for (i=0;i<XkbNumVirtualMods;i++) {
  	if (i==0)	fprintf(file,"    { ");
  	else if (i==8)	fprintf(file,",\n      ");
--- 468,474 ----
      fprintf(file,"static XkbServerMapRec serverMap= {\n");
      fprintf(file,"    %d, %d, (XkbAction *)actionCache,\n",
  				xkb->server->num_acts,xkb->server->num_acts);
!     fprintf(file,"    behaviors, keyActions, explicit_parts,\n");
      for (i=0;i<XkbNumVirtualMods;i++) {
  	if (i==0)	fprintf(file,"    { ");
  	else if (i==8)	fprintf(file,",\n      ");
*** xc/lib/xkbfile/maprules.c@@/PUBLIC-LATEST	Thu Dec  5 10:26:29 1996
--- xc/lib/xkbfile/maprules.c	Tue Jun 10 07:03:04 1997
***************
*** 1,4 ****
! /* $XConsortium: maprules.c /main/11 1996/12/05 10:21:52 kaleb $ */
  /************************************************************
   Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: maprules.c /main/12 1997/06/10 06:53:35 kaleb $ */
  /************************************************************
   Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 361,367 ****
      char *	vals_defined;
  #endif
  {
! char *str,*next;
  
      for (str=vals_defined,next=NULL;str!=NULL;str=next) {
  	int len;
--- 361,368 ----
      char *	vals_defined;
  #endif
  {
! char	*str,*next;
! int	want_len= strlen(wanted);
  
      for (str=vals_defined,next=NULL;str!=NULL;str=next) {
  	int len;
***************
*** 373,379 ****
  	else {
  	    len= strlen(str);
  	}
! 	if (strncmp(wanted,str,len)==0)
  	    return True;
      }
      return False;
--- 374,380 ----
  	else {
  	    len= strlen(str);
  	}
! 	if ((len==want_len)&&(strncmp(wanted,str,len)==0))
  	    return True;
      }
      return False;
***************
*** 1252,1258 ****
  Atom		rules_atom,actual_type;
  int		fmt,len;
  unsigned long	nitems,bytes_after;
! unsigned char *	data,*out;
  Status		rtrn;
  
      rules_atom= XInternAtom(dpy,_XKB_RF_NAMES_PROP_ATOM,True);
--- 1253,1259 ----
  Atom		rules_atom,actual_type;
  int		fmt,len;
  unsigned long	nitems,bytes_after;
! char            *data,*out;
  Status		rtrn;
  
      rules_atom= XInternAtom(dpy,_XKB_RF_NAMES_PROP_ATOM,True);
***************
*** 1259,1267 ****
      if (rules_atom==None)	/* property cannot exist */
  	return False; 
      rtrn= XGetWindowProperty(dpy,DefaultRootWindow(dpy),rules_atom,
! 				0L,_XKB_RF_NAMES_PROP_MAXLEN,False,
! 				XA_STRING,&actual_type,
! 				&fmt,&nitems,&bytes_after,&data);
      if (rtrn!=Success)
  	return False;
      if (rf_rtrn)
--- 1260,1269 ----
      if (rules_atom==None)	/* property cannot exist */
  	return False; 
      rtrn= XGetWindowProperty(dpy,DefaultRootWindow(dpy),rules_atom,
!                                 0L,_XKB_RF_NAMES_PROP_MAXLEN,False,
!                                 XA_STRING,&actual_type,
!                                 &fmt,&nitems,&bytes_after,
!                                 (unsigned char **)&data);
      if (rtrn!=Success)
  	return False;
      if (rf_rtrn)
***************
*** 1372,1378 ****
      }
  
      XChangeProperty(dpy,DefaultRootWindow(dpy),name,XA_STRING,8,PropModeReplace,
!                                                 		pval,len);
      free(pval);
      return True;
  }
--- 1374,1380 ----
      }
  
      XChangeProperty(dpy,DefaultRootWindow(dpy),name,XA_STRING,8,PropModeReplace,
!                                                 (unsigned char *)pval,len);
      free(pval);
      return True;
  }
*** xc/lib/xkbfile/xkbout.c@@/PUBLIC-LATEST	Fri Dec 27 20:58:29 1996
--- xc/lib/xkbfile/xkbout.c	Fri Jun 13 06:02:45 1997
***************
*** 1,4 ****
! /* $XConsortium: xkbout.c /main/6 1996/12/27 20:53:20 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkbout.c /main/8 1997/06/13 05:59:04 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 59,72 ****
  
  #endif
  
  static Bool
  #if NeedFunctionPrototypes
! WriteXKBVModDecl(FILE *file,Display *dpy,XkbDescPtr xkb)
  #else
! WriteXKBVModDecl(file,dpy,xkb)
      FILE *	file;
      Display *	dpy;
      XkbDescPtr	xkb;
  #endif
  {
  register int 	i,nMods;
--- 59,77 ----
  
  #endif
  
+ #define	VMOD_HIDE_VALUE	0
+ #define	VMOD_SHOW_VALUE	1
+ #define	VMOD_COMMENT_VALUE 2
+ 
  static Bool
  #if NeedFunctionPrototypes
! WriteXKBVModDecl(FILE *file,Display *dpy,XkbDescPtr xkb,int showValue)
  #else
! WriteXKBVModDecl(file,dpy,xkb,showValue)
      FILE *	file;
      Display *	dpy;
      XkbDescPtr	xkb;
+     int		showValue;
  #endif
  {
  register int 	i,nMods;
***************
*** 83,88 ****
--- 88,104 ----
  	    if (nMods==0)	fprintf(file,"    virtual_modifiers ");
  	    else		fprintf(file,",");
  	    fprintf(file,"%s",XkbAtomText(dpy,vmodNames[i],XkbXKBFile));
+ 	    if ((showValue!=VMOD_HIDE_VALUE)&&
+ 		(xkb->server)&&(xkb->server->vmods[i]!=XkbNoModifierMask)) {
+ 		if (showValue==VMOD_COMMENT_VALUE) {
+ 		    fprintf(file,"/* = %s */",
+ 			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
+ 		}
+ 		else  {
+ 		    fprintf(file,"= %s",
+ 			XkbModMaskText(xkb->server->vmods[i],XkbXKBFile));
+ 		}
+ 	    }
  	    nMods++;
  	}
      }
***************
*** 136,141 ****
--- 152,158 ----
  register unsigned 	i;
  XkbDescPtr		xkb;
  Display *		dpy;
+ char *			alternate;
  
      xkb= result->xkb;
      dpy= xkb->dpy;
***************
*** 152,158 ****
      fprintf(file,"    maximum = %d;\n",xkb->max_key_code);
      for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
  	if (xkb->names->keys[i].name[0]!='\0') {
! 	    fprintf(file,"    %6s = %d;\n",
  			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile),
  			i);
  	}
--- 169,178 ----
      fprintf(file,"    maximum = %d;\n",xkb->max_key_code);
      for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
  	if (xkb->names->keys[i].name[0]!='\0') {
! 	    if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,True)!=i)
! 		 alternate= "alternate ";
! 	    else alternate= "";
! 	    fprintf(file,"    %s%6s = %d;\n",alternate,
  			XkbKeyNameText(xkb->names->keys[i].name,XkbXKBFile),
  			i);
  	}
***************
*** 222,228 ****
  	 fprintf(file,"xkb_types {\n\n");
      else fprintf(file,"xkb_types \"%s\" {\n\n",
  			XkbAtomText(dpy,xkb->names->types,XkbXKBFile));
!     WriteXKBVModDecl(file,dpy,xkb);
  
      type= xkb->map->types;
      for (i=0;i<xkb->map->num_types;i++,type++) {
--- 242,249 ----
  	 fprintf(file,"xkb_types {\n\n");
      else fprintf(file,"xkb_types \"%s\" {\n\n",
  			XkbAtomText(dpy,xkb->names->types,XkbXKBFile));
!     WriteXKBVModDecl(file,dpy,xkb,
! 			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));
  
      type= xkb->map->types;
      for (i=0;i<xkb->map->num_types;i++,type++) {
***************
*** 349,355 ****
  	 fprintf(file,"xkb_compatibility {\n\n");
      else fprintf(file,"xkb_compatibility \"%s\" {\n\n",
  			XkbAtomText(dpy,xkb->names->compat,XkbXKBFile));
!     WriteXKBVModDecl(file,dpy,xkb);
  
      fprintf(file,"    interpret.useModMapMods= AnyLevel;\n");
      fprintf(file,"    interpret.repeat= False;\n");
--- 370,377 ----
  	 fprintf(file,"xkb_compatibility {\n\n");
      else fprintf(file,"xkb_compatibility \"%s\" {\n\n",
  			XkbAtomText(dpy,xkb->names->compat,XkbXKBFile));
!     WriteXKBVModDecl(file,dpy,xkb,
! 			(showImplicit?VMOD_COMMENT_VALUE:VMOD_HIDE_VALUE));
  
      fprintf(file,"    interpret.useModMapMods= AnyLevel;\n");
      fprintf(file,"    interpret.repeat= False;\n");
***************
*** 457,462 ****
--- 479,486 ----
      for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
  	Bool	simple;
  	if ((int)XkbKeyNumSyms(xkb,i)<1)
+ 	    continue;
+ 	if (XkbFindKeycodeByName(xkb,xkb->names->keys[i].name,True)!=i)
  	    continue;
  	simple= True;
  	fprintf(file,"    key %6s {",
*** xc/lib/zlib/README@@/PUBLIC-LATEST	Thu Mar  7 13:54:42 1996
--- xc/lib/zlib/README	Wed Feb 26 17:39:21 1997
***************
*** 1,9 ****
! /* $XConsortium: README /main/2 1996/03/07 13:52:47 mor $ */
  
! zlib 1.0 is a general purpose data compression library.  All the code
  is reentrant (thread safe).  The data format used by the zlib library
! is described in the files zlib-3.3.doc, deflate-1.3.doc and
! gzip-4.3.doc, available in ftp://ftp.uu.net/pub/archiving/zip/doc/
  
  All functions of the compression library are documented in the file
  zlib.h. A usage example of the library is given in the file example.c
--- 1,11 ----
! /* $TOG: README /main/3 1997/02/26 17:42:11 kaleb $ */
  
! zlib 1.0.4 is a general purpose data compression library.  All the code
  is reentrant (thread safe).  The data format used by the zlib library
! is described by RFCs (Request for Comments) 1950 to 1952 in the files 
! ftp://ds.internic.net/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate
! format) and rfc1952.txt (gzip format). These documents are also available in
! other formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
  
  All functions of the compression library are documented in the file
  zlib.h. A usage example of the library is given in the file example.c
***************
*** 18,48 ****
  
  Questions about zlib should be sent to <zlib@quest.jpl.nasa.gov> or,
  if this fails, to the addresses given below in the Copyright section.
  
! The changes made in version 1.0 are documented in the file ChangeLog.
! The main changes since 0.95 are:
! - allow preset dictionary shared between compressor and decompressor
! - allow compression level 0 (no compression)
! - add deflateParams in zlib.h: allow dynamic change of compression level
!   and compression strategy.
! - test large buffers and deflateParams in example.c
! - add optional "configure" to build zlib as a shared library
! - suppress Makefile.qnx, use configure instead
! - fixes for 64-bit systems (needed for Alpha and Cray)
! - declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)
! - always return Z_BUF_ERROR when deflate() has nothing to do
! - deflateInit and inflateInit are now macros to allow version checking
! - prefix all global functions and types with z_ with -DZ_PREFIX
! - fix some very unlikely race conditions in multi-threaded environment
! - several minor fixes for better portability
! - free in reverse order of allocation to help memory manager
! - use zlib-1.0/* instead of zlib/* inside the tar.gz
! - make zlib warning-free with "gcc -O3 -Wall -Wwrite-strings -Wpointer-arith
!   -Wconversion -Wstrict-prototypes -Wmissing-prototypes"
! - allow gzread on concatenated .gz files
! - deflateEnd now returns Z_DATA_ERROR if it was premature
! - deflate is finally (?) fully deterministic
  
  Notes for some targets:
  
  - For Turbo C the small model is supported only with reduced performance to
--- 20,42 ----
  
  Questions about zlib should be sent to <zlib@quest.jpl.nasa.gov> or,
  if this fails, to the addresses given below in the Copyright section.
+ The zlib home page is http://quest.jpl.nasa.gov/zlib/
  
! The changes made in version 1.0.4 are documented in the file ChangeLog.
! The main changes since 1.0.3 are:
  
+ - In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF
+   bit, so the decompressor could decompress all the correct data but went
+   on to attempt decompressing extra garbage data. This affected minigzip too.
+ - zlibVersion and gzerror return const char* (needed for DLL)
+ - port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)
+ 
+ 
+ A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>
+ is in the CPAN (Comprehensive Perl Archive Network) sites, such as:
+ ftp://ftp.cis.ufl.edu/pub/perl/CPAN/modules/by-module/Compress/Compress-Zlib*
+ 
+ 
  Notes for some targets:
  
  - For Turbo C the small model is supported only with reduced performance to
***************
*** 49,56 ****
    avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
  
  - For 64-bit Iris, deflate.c must be compiled without any optimization.
!   With -O, one libpng test fails. The test works in 32 bit mode (with the
!   -32 compiler flag).
  
  - zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   
    it works when compiled with cc.
--- 43,50 ----
    avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
  
  - For 64-bit Iris, deflate.c must be compiled without any optimization.
!   With -O, one libpng test fails. The test works in 32 bit mode (with
!   the -32 compiler flag). The compiler bug has been reported to SGI.
  
  - zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   
    it works when compiled with cc.
***************
*** 58,66 ****
  - zlib doesn't work on HP-UX 9.05 with one cc compiler (the one not
    accepting the -O option). It works with the other cc compiler.
  
! A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>
! is in the CPAN (Comprehensive Perl Archive Network) sites, such as:
! ftp://ftp.cis.ufl.edu/pub/perl/CPAN/modules/by-module/Compress/Compress-Zlib*
  
  Acknowledgments:
  
--- 52,65 ----
  - zlib doesn't work on HP-UX 9.05 with one cc compiler (the one not
    accepting the -O option). It works with the other cc compiler.
  
! - To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc
!   and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL
!   For help on building a zlib DLL, contact Alessandro Iacopetti
!   <iaco@email.alessandria.alpcom.it>  http://lisa.unial.it/iaco ,
!   or contact Brad Clarke <bclarke@cyberus.ca>.
! 
! - gzdopen is not supported on RISCOS
! 
  
  Acknowledgments:
  
*** xc/lib/zlib/adler32.c@@/PUBLIC-LATEST	Thu Mar  7 13:54:49 1996
--- xc/lib/zlib/adler32.c	Wed Feb 26 17:39:33 1997
***************
*** 1,4 ****
! /* $XConsortium: adler32.c /main/2 1996/03/07 13:52:52 mor $ */
  
  /* adler32.c -- compute the Adler-32 checksum of a data stream
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: adler32.c /main/3 1997/02/26 17:42:20 kaleb $ */
  
  /* adler32.c -- compute the Adler-32 checksum of a data stream
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 5,11 ****
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: adler32.c /main/2 1996/03/07 13:52:52 mor $ */
  
  #include "zlib.h"
  
--- 5,11 ----
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: adler32.c /main/3 1997/02/26 17:42:20 kaleb $ */
  
  #include "zlib.h"
  
***************
*** 13,23 ****
  #define NMAX 5552
  /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
  
! #define DO1(buf)  {s1 += *buf++; s2 += s1;}
! #define DO2(buf)  DO1(buf); DO1(buf);
! #define DO4(buf)  DO2(buf); DO2(buf);
! #define DO8(buf)  DO4(buf); DO4(buf);
! #define DO16(buf) DO8(buf); DO8(buf);
  
  /* ========================================================================= */
  uLong adler32(adler, buf, len)
--- 13,23 ----
  #define NMAX 5552
  /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
  
! #define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
! #define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
! #define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
! #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
! #define DO16(buf)   DO8(buf,0); DO8(buf,8);
  
  /* ========================================================================= */
  uLong adler32(adler, buf, len)
***************
*** 36,45 ****
          len -= k;
          while (k >= 16) {
              DO16(buf);
              k -= 16;
          }
          if (k != 0) do {
!             DO1(buf);
          } while (--k);
          s1 %= BASE;
          s2 %= BASE;
--- 36,47 ----
          len -= k;
          while (k >= 16) {
              DO16(buf);
+ 	    buf += 16;
              k -= 16;
          }
          if (k != 0) do {
!             s1 += *buf++;
! 	    s2 += s1;
          } while (--k);
          s1 %= BASE;
          s2 %= BASE;
*** xc/lib/zlib/deflate.c@@/PUBLIC-LATEST	Thu Mar  7 13:54:56 1996
--- xc/lib/zlib/deflate.c	Wed Feb 26 17:39:39 1997
***************
*** 1,4 ****
! /* $XConsortium: deflate.c /main/2 1996/03/07 13:52:59 mor $ */
  
  /* deflate.c -- compress data using the deflation algorithm
   * Copyright (C) 1995-1996 Jean-loup Gailly.
--- 1,4 ----
! /* $TOG: deflate.c /main/3 1997/02/26 17:42:26 kaleb $ */
  
  /* deflate.c -- compress data using the deflation algorithm
   * Copyright (C) 1995-1996 Jean-loup Gailly.
***************
*** 49,59 ****
   *
   */
  
! /* $Id: deflate.c /main/2 1996/03/07 13:52:59 mor $ */
  
  #include "deflate.h"
  
! char deflate_copyright[] = " deflate 1.0 Copyright 1995-1996 Jean-loup Gailly ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
--- 49,59 ----
   *
   */
  
! /* $Id: deflate.c /main/3 1997/02/26 17:42:26 kaleb $ */
  
  #include "deflate.h"
  
! char deflate_copyright[] = " deflate 1.0.4 Copyright 1995-1996 Jean-loup Gailly ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
***************
*** 64,78 ****
  /* ===========================================================================
   *  Function prototypes.
   */
  local void fill_window    OF((deflate_state *s));
! local int  deflate_stored OF((deflate_state *s, int flush));
! local int  deflate_fast   OF((deflate_state *s, int flush));
! local int  deflate_slow   OF((deflate_state *s, int flush));
  local void lm_init        OF((deflate_state *s));
! local int longest_match   OF((deflate_state *s, IPos cur_match));
  local void putShortMSB    OF((deflate_state *s, uInt b));
! local void flush_pending  OF((z_stream *strm));
! local int read_buf        OF((z_stream *strm, charf *buf, unsigned size));
  #ifdef ASMV
        void match_init OF((void)); /* asm code initialization */
  #endif
--- 64,88 ----
  /* ===========================================================================
   *  Function prototypes.
   */
+ typedef enum {
+     need_more,      /* block not completed, need more input or more output */
+     block_done,     /* block flush performed */
+     finish_started, /* finish started, need only more output at next deflate */
+     finish_done     /* finish done, accept no more input or output */
+ } block_state;
+ 
+ typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+ /* Compression function. Returns the block state after the call. */
+ 
  local void fill_window    OF((deflate_state *s));
! local block_state deflate_stored OF((deflate_state *s, int flush));
! local block_state deflate_fast   OF((deflate_state *s, int flush));
! local block_state deflate_slow   OF((deflate_state *s, int flush));
  local void lm_init        OF((deflate_state *s));
! local uInt longest_match  OF((deflate_state *s, IPos cur_match));
  local void putShortMSB    OF((deflate_state *s, uInt b));
! local void flush_pending  OF((z_streamp strm));
! local int read_buf        OF((z_streamp strm, charf *buf, unsigned size));
  #ifdef ASMV
        void match_init OF((void)); /* asm code initialization */
  #endif
***************
*** 99,107 ****
   * See deflate.c for comments about the MIN_MATCH+1.
   */
  
- typedef int (*compress_func) OF((deflate_state *s, int flush));
- /* Compressing function */
- 
  /* Values for max_lazy_match, good_match and max_chain_length, depending on
   * the desired pack level (0..9). The values given below have been tuned to
   * exclude worst case performance for pathological files. Better values may be
--- 109,114 ----
***************
*** 159,165 ****
  #define INSERT_STRING(s, str, match_head) \
     (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
      s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
!     s->head[s->ins_h] = (str))
  
  /* ===========================================================================
   * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
--- 166,172 ----
  #define INSERT_STRING(s, str, match_head) \
     (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
      s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
!     s->head[s->ins_h] = (Pos)(str))
  
  /* ===========================================================================
   * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
***************
*** 171,177 ****
  
  /* ========================================================================= */
  int deflateInit_(strm, level, version, stream_size)
!     z_stream *strm;
      int level;
      const char *version;
      int stream_size;
--- 178,184 ----
  
  /* ========================================================================= */
  int deflateInit_(strm, level, version, stream_size)
!     z_streamp strm;
      int level;
      const char *version;
      int stream_size;
***************
*** 184,190 ****
  /* ========================================================================= */
  int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
  		  version, stream_size)
!     z_stream *strm;
      int  level;
      int  method;
      int  windowBits;
--- 191,197 ----
  /* ========================================================================= */
  int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
  		  version, stream_size)
!     z_streamp strm;
      int  level;
      int  method;
      int  windowBits;
***************
*** 196,201 ****
--- 203,213 ----
      deflate_state *s;
      int noheader = 0;
  
+     ushf *overlay;
+     /* We overlay pending_buf and d_buf+l_buf. This works since the average
+      * output size for (length,distance) codes is <= 24 bits.
+      */
+ 
      if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
          stream_size != sizeof(z_stream)) {
  	return Z_VERSION_ERROR;
***************
*** 241,260 ****
  
      s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
  
!     s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 2*sizeof(ush));
  
      if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
          s->pending_buf == Z_NULL) {
!         strm->msg = ERR_MSG(Z_MEM_ERROR);
          deflateEnd (strm);
          return Z_MEM_ERROR;
      }
!     s->l_buf = (uchf *) &(s->pending_buf[s->lit_bufsize]);
!     s->d_buf = (ushf *) &(s->pending_buf[2*s->lit_bufsize]);
!     /* We overlay pending_buf and d_buf+l_buf. This works since the average
!      * output size for (length,distance) codes is <= 32 bits (worst case
!      * is 15+15+13=33). d_buf is put last in case sizeof(short)>2.
!      */
  
      s->level = level;
      s->strategy = strategy;
--- 253,269 ----
  
      s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
  
!     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
!     s->pending_buf = (uchf *) overlay;
  
      if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
          s->pending_buf == Z_NULL) {
!         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
          deflateEnd (strm);
          return Z_MEM_ERROR;
      }
!     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
!     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  
      s->level = level;
      s->strategy = strategy;
***************
*** 265,271 ****
  
  /* ========================================================================= */
  int deflateSetDictionary (strm, dictionary, dictLength)
!     z_stream *strm;
      const Bytef *dictionary;
      uInt  dictLength;
  {
--- 274,280 ----
  
  /* ========================================================================= */
  int deflateSetDictionary (strm, dictionary, dictLength)
!     z_streamp strm;
      const Bytef *dictionary;
      uInt  dictLength;
  {
***************
*** 272,278 ****
      deflate_state *s;
      uInt length = dictLength;
      uInt n;
!     IPos hash_head;
  
      if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
          strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
--- 281,287 ----
      deflate_state *s;
      uInt length = dictLength;
      uInt n;
!     IPos hash_head = 0;
  
      if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
          strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
***************
*** 298,309 ****
      for (n = 0; n <= length - MIN_MATCH; n++) {
  	INSERT_STRING(s, n, hash_head);
      }
      return Z_OK;
  }
  
  /* ========================================================================= */
  int deflateReset (strm)
!     z_stream *strm;
  {
      deflate_state *s;
      
--- 307,319 ----
      for (n = 0; n <= length - MIN_MATCH; n++) {
  	INSERT_STRING(s, n, hash_head);
      }
+     if (hash_head) hash_head = 0;  /* to make compiler happy */
      return Z_OK;
  }
  
  /* ========================================================================= */
  int deflateReset (strm)
!     z_streamp strm;
  {
      deflate_state *s;
      
***************
*** 333,344 ****
  
  /* ========================================================================= */
  int deflateParams(strm, level, strategy)
!     z_stream *strm;
      int level;
      int strategy;
  {
      deflate_state *s;
      compress_func func;
  
      if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
      s = strm->state;
--- 343,355 ----
  
  /* ========================================================================= */
  int deflateParams(strm, level, strategy)
!     z_streamp strm;
      int level;
      int strategy;
  {
      deflate_state *s;
      compress_func func;
+     int err = Z_OK;
  
      if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
      s = strm->state;
***************
*** 351,361 ****
      }
      func = configuration_table[s->level].func;
  
!     if (func != configuration_table[level].func
! 	&& strm->state->lookahead != 0) {
! 
  	/* Flush the last buffer: */
! 	(void)(*func)(strm->state, Z_PARTIAL_FLUSH);
      }
      if (s->level != level) {
  	s->level = level;
--- 362,370 ----
      }
      func = configuration_table[s->level].func;
  
!     if (func != configuration_table[level].func && strm->total_in != 0) {
  	/* Flush the last buffer: */
! 	err = deflate(strm, Z_PARTIAL_FLUSH);
      }
      if (s->level != level) {
  	s->level = level;
***************
*** 365,371 ****
  	s->max_chain_length = configuration_table[level].max_chain;
      }
      s->strategy = strategy;
!     return Z_OK;
  }
  
  /* =========================================================================
--- 374,380 ----
  	s->max_chain_length = configuration_table[level].max_chain;
      }
      s->strategy = strategy;
!     return err;
  }
  
  /* =========================================================================
***************
*** 388,394 ****
   * (See also read_buf()).
   */
  local void flush_pending(strm)
!     z_stream *strm;
  {
      unsigned len = strm->state->pending;
  
--- 397,403 ----
   * (See also read_buf()).
   */
  local void flush_pending(strm)
!     z_streamp strm;
  {
      unsigned len = strm->state->pending;
  
***************
*** 408,421 ****
  
  /* ========================================================================= */
  int deflate (strm, flush)
!     z_stream *strm;
      int flush;
  {
      int old_flush; /* value of flush param for previous deflate call */
      deflate_state *s;
  
!     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
!     
      s = strm->state;
  
      if (strm->next_out == Z_NULL ||
--- 417,432 ----
  
  /* ========================================================================= */
  int deflate (strm, flush)
!     z_streamp strm;
      int flush;
  {
      int old_flush; /* value of flush param for previous deflate call */
      deflate_state *s;
  
!     if (strm == Z_NULL || strm->state == Z_NULL ||
! 	flush > Z_FINISH || flush < 0) {
!         return Z_STREAM_ERROR;
!     }
      s = strm->state;
  
      if (strm->next_out == Z_NULL ||
***************
*** 447,460 ****
  	if (s->strstart != 0) {
  	    putShortMSB(s, (uInt)(strm->adler >> 16));
  	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
- 	    strm->adler = 1L;
  	}
      }
  
      /* Flush as much pending output as possible */
      if (s->pending != 0) {
          flush_pending(strm);
!         if (strm->avail_out == 0) return Z_OK;
  
      /* Make sure there is something to do and avoid duplicate consecutive
       * flushes. For repeated and useless calls with Z_FINISH, we keep
--- 458,480 ----
  	if (s->strstart != 0) {
  	    putShortMSB(s, (uInt)(strm->adler >> 16));
  	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
  	}
+ 	strm->adler = 1L;
      }
  
      /* Flush as much pending output as possible */
      if (s->pending != 0) {
          flush_pending(strm);
!         if (strm->avail_out == 0) {
! 	    /* Since avail_out is 0, deflate will be called again with
! 	     * more output space, but possibly with both pending and
! 	     * avail_in equal to zero. There won't be anything to do,
! 	     * but this is not an error situation so make sure we
! 	     * return OK instead of BUF_ERROR at next call of deflate:
!              */
! 	    s->last_flush = -1;
! 	    return Z_OK;
! 	}
  
      /* Make sure there is something to do and avoid duplicate consecutive
       * flushes. For repeated and useless calls with Z_FINISH, we keep
***************
*** 474,495 ****
       */
      if (strm->avail_in != 0 || s->lookahead != 0 ||
          (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
!         int quit;
  
!         if (flush == Z_FINISH) {
              s->status = FINISH_STATE;
          }
! 	quit = (*(configuration_table[s->level].func))(s, flush);
! 
!         if (quit || strm->avail_out == 0) return Z_OK;
!         /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
!          * of deflate should use the same flush parameter to make sure
!          * that the flush is complete. So we don't have to output an
!          * empty block here, this will be done at next call. This also
!          * ensures that for a very small output buffer, we emit at most
!          * one empty block.
!          */
!         if (flush != Z_NO_FLUSH && flush != Z_FINISH) {
              if (flush == Z_PARTIAL_FLUSH) {
                  _tr_align(s);
              } else { /* FULL_FLUSH or SYNC_FLUSH */
--- 494,520 ----
       */
      if (strm->avail_in != 0 || s->lookahead != 0 ||
          (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
!         block_state bstate;
  
! 	bstate = (*(configuration_table[s->level].func))(s, flush);
! 
!         if (bstate == finish_started || bstate == finish_done) {
              s->status = FINISH_STATE;
          }
!         if (bstate == need_more || bstate == finish_started) {
! 	    if (strm->avail_out == 0) {
! 	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
! 	    }
! 	    return Z_OK;
! 	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
! 	     * of deflate should use the same flush parameter to make sure
! 	     * that the flush is complete. So we don't have to output an
! 	     * empty block here, this will be done at next call. This also
! 	     * ensures that for a very small output buffer, we emit at most
! 	     * one empty block.
! 	     */
! 	}
!         if (bstate == block_done) {
              if (flush == Z_PARTIAL_FLUSH) {
                  _tr_align(s);
              } else { /* FULL_FLUSH or SYNC_FLUSH */
***************
*** 502,508 ****
                  }
              }
              flush_pending(strm);
!             if (strm->avail_out == 0) return Z_OK;
          }
      }
      Assert(strm->avail_out > 0, "bug2");
--- 527,536 ----
                  }
              }
              flush_pending(strm);
! 	    if (strm->avail_out == 0) {
! 	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
! 	      return Z_OK;
! 	    }
          }
      }
      Assert(strm->avail_out > 0, "bug2");
***************
*** 523,529 ****
  
  /* ========================================================================= */
  int deflateEnd (strm)
!     z_stream *strm;
  {
      int status;
  
--- 551,557 ----
  
  /* ========================================================================= */
  int deflateEnd (strm)
!     z_streamp strm;
  {
      int status;
  
***************
*** 544,551 ****
  
  /* ========================================================================= */
  int deflateCopy (dest, source)
!     z_stream *dest;
!     z_stream *source;
  {
      if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
          return Z_STREAM_ERROR;
--- 572,579 ----
  
  /* ========================================================================= */
  int deflateCopy (dest, source)
!     z_streamp dest;
!     z_streamp source;
  {
      if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
          return Z_STREAM_ERROR;
***************
*** 570,576 ****
   * (See also flush_pending()).
   */
  local int read_buf(strm, buf, size)
!     z_stream *strm;
      charf *buf;
      unsigned size;
  {
--- 598,604 ----
   * (See also flush_pending()).
   */
  local int read_buf(strm, buf, size)
!     z_streamp strm;
      charf *buf;
      unsigned size;
  {
***************
*** 632,638 ****
  /* For 80x86 and 680x0, an optimized version will be provided in match.asm or
   * match.S. The code will be functionally equivalent.
   */
! local int longest_match(s, cur_match)
      deflate_state *s;
      IPos cur_match;                             /* current match */
  {
--- 660,666 ----
  /* For 80x86 and 680x0, an optimized version will be provided in match.asm or
   * match.S. The code will be functionally equivalent.
   */
! local uInt longest_match(s, cur_match)
      deflate_state *s;
      IPos cur_match;                             /* current match */
  {
***************
*** 675,681 ****
      /* Do not look for matches beyond the end of the input. This is necessary
       * to make deflate deterministic.
       */
!     if (nice_match > s->lookahead) nice_match = s->lookahead;
  
      Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
  
--- 703,709 ----
      /* Do not look for matches beyond the end of the input. This is necessary
       * to make deflate deterministic.
       */
!     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
  
      Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
  
***************
*** 766,772 ****
      } while ((cur_match = prev[cur_match & wmask]) > limit
               && --chain_length != 0);
  
!     if (best_len <= s->lookahead) return best_len;
      return s->lookahead;
  }
  #endif /* ASMV */
--- 794,800 ----
      } while ((cur_match = prev[cur_match & wmask]) > limit
               && --chain_length != 0);
  
!     if ((uInt)best_len <= s->lookahead) return best_len;
      return s->lookahead;
  }
  #endif /* ASMV */
***************
*** 916,933 ****
  /* Same but force premature exit if necessary. */
  #define FLUSH_BLOCK(s, eof) { \
     FLUSH_BLOCK_ONLY(s, eof); \
!    if (s->strm->avail_out == 0) return 1; \
  }
  
  /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
!  * true if processing was terminated prematurely (no more input or output
!  * space).  This function does not insert new strings in the dictionary
!  * since uncompressible data is probably not useful. This function is used
   * only for the level=0 compression option.
   * NOTE: this function should be optimized to avoid extra copying.
   */
! local int deflate_stored(s, flush)
      deflate_state *s;
      int flush;
  {
--- 944,961 ----
  /* Same but force premature exit if necessary. */
  #define FLUSH_BLOCK(s, eof) { \
     FLUSH_BLOCK_ONLY(s, eof); \
!    if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
  }
  
  /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
!  * the current block state.
!  * This function does not insert new strings in the dictionary since
!  * uncompressible data is probably not useful. This function is used
   * only for the level=0 compression option.
   * NOTE: this function should be optimized to avoid extra copying.
   */
! local block_state deflate_stored(s, flush)
      deflate_state *s;
      int flush;
  {
***************
*** 939,945 ****
  		   s->block_start >= (long)s->w_size, "slide too late");
  
              fill_window(s);
!             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return 1;
  
              if (s->lookahead == 0) break; /* flush the current block */
          }
--- 967,973 ----
  		   s->block_start >= (long)s->w_size, "slide too late");
  
              fill_window(s);
!             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
  
              if (s->lookahead == 0) break; /* flush the current block */
          }
***************
*** 949,955 ****
  	s->lookahead = 0;
  
          /* Stored blocks are limited to 0xffff bytes: */
!         if (s->strstart == 0 || s->strstart > 0xffff) {
  	    /* strstart == 0 is possible when wraparound on 16-bit machine */
  	    s->lookahead = s->strstart - 0xffff;
  	    s->strstart = 0xffff;
--- 977,983 ----
  	s->lookahead = 0;
  
          /* Stored blocks are limited to 0xffff bytes: */
!         if (s->strstart == 0 || s->strstart > 0xfffe) {
  	    /* strstart == 0 is possible when wraparound on 16-bit machine */
  	    s->lookahead = s->strstart - 0xffff;
  	    s->strstart = 0xffff;
***************
*** 961,977 ****
  	}
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return 0; /* normal exit */
  }
  
  /* ===========================================================================
!  * Compress as much as possible from the input stream, return true if
!  * processing was terminated prematurely (no more input or output space).
   * This function does not perform lazy evaluation of matches and inserts
   * new strings in the dictionary only for unmatched strings or for short
   * matches. It is used only for the fast compression options.
   */
! local int deflate_fast(s, flush)
      deflate_state *s;
      int flush;
  {
--- 989,1005 ----
  	}
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return flush == Z_FINISH ? finish_done : block_done;
  }
  
  /* ===========================================================================
!  * Compress as much as possible from the input stream, return the current
!  * block state.
   * This function does not perform lazy evaluation of matches and inserts
   * new strings in the dictionary only for unmatched strings or for short
   * matches. It is used only for the fast compression options.
   */
! local block_state deflate_fast(s, flush)
      deflate_state *s;
      int flush;
  {
***************
*** 986,993 ****
           */
          if (s->lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
!             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) return 1;
! 
              if (s->lookahead == 0) break; /* flush the current block */
          }
  
--- 1014,1022 ----
           */
          if (s->lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
!             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
! 	        return need_more;
! 	    }
              if (s->lookahead == 0) break; /* flush the current block */
          }
  
***************
*** 1055,1061 ****
          if (bflush) FLUSH_BLOCK(s, 0);
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return 0; /* normal exit */
  }
  
  /* ===========================================================================
--- 1084,1090 ----
          if (bflush) FLUSH_BLOCK(s, 0);
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return flush == Z_FINISH ? finish_done : block_done;
  }
  
  /* ===========================================================================
***************
*** 1063,1069 ****
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */
! local int deflate_slow(s, flush)
      deflate_state *s;
      int flush;
  {
--- 1092,1098 ----
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */
! local block_state deflate_slow(s, flush)
      deflate_state *s;
      int flush;
  {
***************
*** 1079,1086 ****
           */
          if (s->lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
!             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) return 1;
! 
              if (s->lookahead == 0) break; /* flush the current block */
          }
  
--- 1108,1116 ----
           */
          if (s->lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
!             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
! 	        return need_more;
! 	    }
              if (s->lookahead == 0) break; /* flush the current block */
          }
  
***************
*** 1158,1164 ****
              }
              s->strstart++;
              s->lookahead--;
!             if (s->strm->avail_out == 0) return 1;
          } else {
              /* There is no previous match to compare with, wait for
               * the next step to decide.
--- 1188,1194 ----
              }
              s->strstart++;
              s->lookahead--;
!             if (s->strm->avail_out == 0) return need_more;
          } else {
              /* There is no previous match to compare with, wait for
               * the next step to decide.
***************
*** 1175,1180 ****
          s->match_available = 0;
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return 0;
  }
- 
--- 1205,1209 ----
          s->match_available = 0;
      }
      FLUSH_BLOCK(s, flush == Z_FINISH);
!     return flush == Z_FINISH ? finish_done : block_done;
  }
*** xc/lib/zlib/deflate.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:00 1996
--- xc/lib/zlib/deflate.h	Wed Feb 26 17:39:47 1997
***************
*** 1,4 ****
! /* $XConsortium: deflate.h /main/2 1996/03/07 13:53:04 mor $ */
  
  /* deflate.h -- internal compression state
   * Copyright (C) 1995-1996 Jean-loup Gailly
--- 1,4 ----
! /* $TOG: deflate.h /main/3 1997/02/26 17:42:35 kaleb $ */
  
  /* deflate.h -- internal compression state
   * Copyright (C) 1995-1996 Jean-loup Gailly
***************
*** 10,16 ****
     subject to change. Applications should only use zlib.h.
   */
  
! /* $Id: deflate.h /main/2 1996/03/07 13:53:04 mor $ */
  
  #ifndef _DEFLATE_H
  #define _DEFLATE_H
--- 10,16 ----
     subject to change. Applications should only use zlib.h.
   */
  
! /* $Id: deflate.h /main/3 1997/02/26 17:42:35 kaleb $ */
  
  #ifndef _DEFLATE_H
  #define _DEFLATE_H
***************
*** 82,88 ****
   */
  
  typedef struct internal_state {
!     z_stream *strm;      /* pointer back to this zlib stream */
      int   status;        /* as the name implies */
      Bytef *pending_buf;  /* output still pending */
      Bytef *pending_out;  /* next pending byte to output to the stream */
--- 82,88 ----
   */
  
  typedef struct internal_state {
!     z_streamp strm;      /* pointer back to this zlib stream */
      int   status;        /* as the name implies */
      Bytef *pending_buf;  /* output still pending */
      Bytef *pending_out;  /* next pending byte to output to the stream */
*** xc/lib/zlib/infblock.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:04 1996
--- xc/lib/zlib/infblock.c	Wed Feb 26 17:39:54 1997
***************
*** 1,4 ****
! /* $XConsortium: infblock.c /main/2 1996/03/07 13:53:08 mor $ */
  
  /* infblock.c -- interpret and process block types to last block
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infblock.c /main/3 1997/02/26 17:42:41 kaleb $ */
  
  /* infblock.c -- interpret and process block types to last block
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 65,71 ****
  
  void inflate_blocks_reset(s, z, c)
  inflate_blocks_statef *s;
! z_stream *z;
  uLongf *c;
  {
    if (s->checkfn != Z_NULL)
--- 65,71 ----
  
  void inflate_blocks_reset(s, z, c)
  inflate_blocks_statef *s;
! z_streamp z;
  uLongf *c;
  {
    if (s->checkfn != Z_NULL)
***************
*** 89,95 ****
  
  
  inflate_blocks_statef *inflate_blocks_new(z, c, w)
! z_stream *z;
  check_func c;
  uInt w;
  {
--- 89,95 ----
  
  
  inflate_blocks_statef *inflate_blocks_new(z, c, w)
! z_streamp z;
  check_func c;
  uInt w;
  {
***************
*** 112,120 ****
  }
  
  
  int inflate_blocks(s, z, r)
  inflate_blocks_statef *s;
! z_stream *z;
  int r;
  {
    uInt t;               /* temporary storage */
--- 112,123 ----
  }
  
  
+ #ifdef DEBUG
+   extern uInt inflate_hufts;
+ #endif
  int inflate_blocks(s, z, r)
  inflate_blocks_statef *s;
! z_streamp z;
  int r;
  {
    uInt t;               /* temporary storage */
***************
*** 191,197 ****
        s->sub.left = (uInt)b & 0xffff;
        b = k = 0;                      /* dump bits */
        Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
!       s->mode = s->sub.left ? STORED : TYPE;
        break;
      case STORED:
        if (n == 0)
--- 194,200 ----
        s->sub.left = (uInt)b & 0xffff;
        b = k = 0;                      /* dump bits */
        Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
!       s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
        break;
      case STORED:
        if (n == 0)
***************
*** 308,313 ****
--- 311,319 ----
          bl = 9;         /* must be <= 9 for lookahead assumptions */
          bd = 6;         /* must be <= 9 for lookahead assumptions */
          t = s->sub.trees.table;
+ #ifdef DEBUG
+       inflate_hufts = 0;
+ #endif
          t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                    s->sub.trees.blens, &bl, &bd, &tl, &td, z);
          if (t != Z_OK)
***************
*** 317,323 ****
            r = t;
            LEAVE
          }
!         Tracev((stderr, "inflate:       trees ok\n"));
          if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
          {
            inflate_trees_free(td, z);
--- 323,330 ----
            r = t;
            LEAVE
          }
!         Tracev((stderr, "inflate:       trees ok, %d * %d bytes used\n",
!               inflate_hufts, sizeof(inflate_huft)));
          if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
          {
            inflate_trees_free(td, z);
***************
*** 376,382 ****
  
  int inflate_blocks_free(s, z, c)
  inflate_blocks_statef *s;
! z_stream *z;
  uLongf *c;
  {
    inflate_blocks_reset(s, z, c);
--- 383,389 ----
  
  int inflate_blocks_free(s, z, c)
  inflate_blocks_statef *s;
! z_streamp z;
  uLongf *c;
  {
    inflate_blocks_reset(s, z, c);
***************
*** 387,395 ****
  }
  
  
! void inflate_set_dictionary(s, z, d, n)
  inflate_blocks_statef *s;
- z_stream *z;
  const Bytef *d;
  uInt  n;
  {
--- 394,401 ----
  }
  
  
! void inflate_set_dictionary(s, d, n)
  inflate_blocks_statef *s;
  const Bytef *d;
  uInt  n;
  {
*** xc/lib/zlib/infblock.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:08 1996
--- xc/lib/zlib/infblock.h	Wed Feb 26 17:40:01 1997
***************
*** 1,4 ****
! /* $XConsortium: infblock.h /main/2 1996/03/07 13:53:11 mor $ */
  
  /* infblock.h -- header to use infblock.c
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infblock.h /main/3 1997/02/26 17:42:49 kaleb $ */
  
  /* infblock.h -- header to use infblock.c
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 14,40 ****
  typedef struct inflate_blocks_state FAR inflate_blocks_statef;
  
  extern inflate_blocks_statef * inflate_blocks_new OF((
!     z_stream *z,
      check_func c,               /* check function */
      uInt w));                   /* window size */
  
  extern int inflate_blocks OF((
      inflate_blocks_statef *,
!     z_stream *,
      int));                      /* initial return code */
  
  extern void inflate_blocks_reset OF((
      inflate_blocks_statef *,
!     z_stream *,
      uLongf *));                  /* check value on output */
  
  extern int inflate_blocks_free OF((
      inflate_blocks_statef *,
!     z_stream *,
      uLongf *));                  /* check value on output */
  
  extern void inflate_set_dictionary OF((
      inflate_blocks_statef *s,
-     z_stream *z,
      const Bytef *d,  /* dictionary */
      uInt  n));       /* dictionary length */
--- 14,39 ----
  typedef struct inflate_blocks_state FAR inflate_blocks_statef;
  
  extern inflate_blocks_statef * inflate_blocks_new OF((
!     z_streamp z,
      check_func c,               /* check function */
      uInt w));                   /* window size */
  
  extern int inflate_blocks OF((
      inflate_blocks_statef *,
!     z_streamp ,
      int));                      /* initial return code */
  
  extern void inflate_blocks_reset OF((
      inflate_blocks_statef *,
!     z_streamp ,
      uLongf *));                  /* check value on output */
  
  extern int inflate_blocks_free OF((
      inflate_blocks_statef *,
!     z_streamp ,
      uLongf *));                  /* check value on output */
  
  extern void inflate_set_dictionary OF((
      inflate_blocks_statef *s,
      const Bytef *d,  /* dictionary */
      uInt  n));       /* dictionary length */
*** xc/lib/zlib/infcodes.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:11 1996
--- xc/lib/zlib/infcodes.c	Wed Feb 26 17:40:08 1997
***************
*** 1,4 ****
! /* $XConsortium: infcodes.c /main/2 1996/03/07 13:53:14 mor $ */
  
  /* infcodes.c -- process literals and length/distance pairs
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infcodes.c /main/3 1997/02/26 17:42:55 kaleb $ */
  
  /* infcodes.c -- process literals and length/distance pairs
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 62,68 ****
  uInt bl, bd;
  inflate_huft *tl;
  inflate_huft *td; /* need separate declaration for Borland C++ */
! z_stream *z;
  {
    inflate_codes_statef *c;
  
--- 62,68 ----
  uInt bl, bd;
  inflate_huft *tl;
  inflate_huft *td; /* need separate declaration for Borland C++ */
! z_streamp z;
  {
    inflate_codes_statef *c;
  
***************
*** 82,88 ****
  
  int inflate_codes(s, z, r)
  inflate_blocks_statef *s;
! z_stream *z;
  int r;
  {
    uInt j;               /* temporary storage */
--- 82,88 ----
  
  int inflate_codes(s, z, r)
  inflate_blocks_statef *s;
! z_streamp z;
  int r;
  {
    uInt j;               /* temporary storage */
***************
*** 242,248 ****
  
  void inflate_codes_free(c, z)
  inflate_codes_statef *c;
! z_stream *z;
  {
    ZFREE(z, c);
    Tracev((stderr, "inflate:       codes free\n"));
--- 242,248 ----
  
  void inflate_codes_free(c, z)
  inflate_codes_statef *c;
! z_streamp z;
  {
    ZFREE(z, c);
    Tracev((stderr, "inflate:       codes free\n"));
*** xc/lib/zlib/infcodes.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:15 1996
--- xc/lib/zlib/infcodes.h	Wed Feb 26 17:40:15 1997
***************
*** 1,4 ****
! /* $XConsortium: infcodes.h /main/2 1996/03/07 13:53:18 mor $ */
  
  /* infcodes.h -- header to use infcodes.c
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infcodes.h /main/3 1997/02/26 17:43:02 kaleb $ */
  
  /* infcodes.h -- header to use infcodes.c
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 16,29 ****
  extern inflate_codes_statef *inflate_codes_new OF((
      uInt, uInt,
      inflate_huft *, inflate_huft *,
!     z_stream *));
  
  extern int inflate_codes OF((
      inflate_blocks_statef *,
!     z_stream *,
      int));
  
  extern void inflate_codes_free OF((
      inflate_codes_statef *,
!     z_stream *));
  
--- 16,29 ----
  extern inflate_codes_statef *inflate_codes_new OF((
      uInt, uInt,
      inflate_huft *, inflate_huft *,
!     z_streamp ));
  
  extern int inflate_codes OF((
      inflate_blocks_statef *,
!     z_streamp ,
      int));
  
  extern void inflate_codes_free OF((
      inflate_codes_statef *,
!     z_streamp ));
  
*** xc/lib/zlib/inffast.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:18 1996
--- xc/lib/zlib/inffast.c	Wed Feb 26 17:40:22 1997
***************
*** 1,4 ****
! /* $XConsortium: inffast.c /main/2 1996/03/07 13:53:21 mor $ */
  
  /* inffast.c -- process literals and length/distance pairs fast
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: inffast.c /main/3 1997/02/26 17:43:09 kaleb $ */
  
  /* inffast.c -- process literals and length/distance pairs fast
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 34,40 ****
  inflate_huft *tl;
  inflate_huft *td; /* need separate declaration for Borland C++ */
  inflate_blocks_statef *s;
! z_stream *z;
  {
    inflate_huft *t;      /* temporary pointer */
    uInt e;               /* extra bits or operation */
--- 34,40 ----
  inflate_huft *tl;
  inflate_huft *td; /* need separate declaration for Borland C++ */
  inflate_blocks_statef *s;
! z_streamp z;
  {
    inflate_huft *t;      /* temporary pointer */
    uInt e;               /* extra bits or operation */
*** xc/lib/zlib/inffast.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:22 1996
--- xc/lib/zlib/inffast.h	Wed Feb 26 17:40:28 1997
***************
*** 1,4 ****
! /* $XConsortium: inffast.h /main/2 1996/03/07 13:53:25 mor $ */
  
  /* inffast.h -- header to use inffast.c
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: inffast.h /main/3 1997/02/26 17:43:15 kaleb $ */
  
  /* inffast.h -- header to use inffast.c
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 16,19 ****
      inflate_huft *,
      inflate_huft *,
      inflate_blocks_statef *,
!     z_stream *));
--- 16,19 ----
      inflate_huft *,
      inflate_huft *,
      inflate_blocks_statef *,
!     z_streamp ));
*** xc/lib/zlib/inflate.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:25 1996
--- xc/lib/zlib/inflate.c	Wed Feb 26 17:40:35 1997
***************
*** 1,4 ****
! /* $XConsortium: inflate.c /main/2 1996/03/07 13:53:28 mor $ */
  
  /* inflate.c -- zlib interface to inflate modules
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: inflate.c /main/3 1997/02/26 17:43:22 kaleb $ */
  
  /* inflate.c -- zlib interface to inflate modules
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 51,57 ****
  
  
  int inflateReset(z)
! z_stream *z;
  {
    uLong c;
  
--- 51,57 ----
  
  
  int inflateReset(z)
! z_streamp z;
  {
    uLong c;
  
***************
*** 67,73 ****
  
  
  int inflateEnd(z)
! z_stream *z;
  {
    uLong c;
  
--- 67,73 ----
  
  
  int inflateEnd(z)
! z_streamp z;
  {
    uLong c;
  
***************
*** 83,89 ****
  
  
  int inflateInit2_(z, w, version, stream_size)
! z_stream *z;
  int w;
  const char *version;
  int stream_size;
--- 83,89 ----
  
  
  int inflateInit2_(z, w, version, stream_size)
! z_streamp z;
  int w;
  const char *version;
  int stream_size;
***************
*** 140,146 ****
  
  
  int inflateInit_(z, version, stream_size)
! z_stream *z;
  const char *version;
  int stream_size;
  {
--- 140,146 ----
  
  
  int inflateInit_(z, version, stream_size)
! z_streamp z;
  const char *version;
  int stream_size;
  {
***************
*** 152,164 ****
  #define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
  
  int inflate(z, f)
! z_stream *z;
  int f;
  {
!   int r = f;    /* to avoid warning about unused f */
    uInt b;
  
!   if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
      return Z_STREAM_ERROR;
    r = Z_BUF_ERROR;
    while (1) switch (z->state->mode)
--- 152,164 ----
  #define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
  
  int inflate(z, f)
! z_streamp z;
  int f;
  {
!   int r;
    uInt b;
  
!   if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL || f < 0)
      return Z_STREAM_ERROR;
    r = Z_BUF_ERROR;
    while (1) switch (z->state->mode)
***************
*** 274,280 ****
  
  
  int inflateSetDictionary(z, dictionary, dictLength)
! z_stream *z;
  const Bytef *dictionary;
  uInt  dictLength;
  {
--- 274,280 ----
  
  
  int inflateSetDictionary(z, dictionary, dictLength)
! z_streamp z;
  const Bytef *dictionary;
  uInt  dictLength;
  {
***************
*** 282,296 ****
  
    if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
      return Z_STREAM_ERROR;
    if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
    z->adler = 1L;
  
!   if (length >= (1<<z->state->wbits))
    {
      length = (1<<z->state->wbits)-1;
      dictionary += dictLength - length;
    }
!   inflate_set_dictionary(z->state->blocks, z, dictionary, length);
    z->state->mode = BLOCKS;
    return Z_OK;
  }
--- 282,297 ----
  
    if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
      return Z_STREAM_ERROR;
+ 
    if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
    z->adler = 1L;
  
!   if (length >= ((uInt)1<<z->state->wbits))
    {
      length = (1<<z->state->wbits)-1;
      dictionary += dictLength - length;
    }
!   inflate_set_dictionary(z->state->blocks, dictionary, length);
    z->state->mode = BLOCKS;
    return Z_OK;
  }
***************
*** 297,303 ****
  
  
  int inflateSync(z)
! z_stream *z;
  {
    uInt n;       /* number of bytes to look at */
    Bytef *p;     /* pointer to bytes */
--- 298,304 ----
  
  
  int inflateSync(z)
! z_streamp z;
  {
    uInt n;       /* number of bytes to look at */
    Bytef *p;     /* pointer to bytes */
*** xc/lib/zlib/inftrees.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:28 1996
--- xc/lib/zlib/inftrees.c	Wed Feb 26 17:40:41 1997
***************
*** 1,4 ****
! /* $XConsortium: inftrees.c /main/2 1996/03/07 13:53:32 mor $ */
  
  /* inftrees.c -- generate Huffman trees for efficient decoding
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: inftrees.c /main/3 1997/02/26 17:43:29 kaleb $ */
  
  /* inftrees.c -- generate Huffman trees for efficient decoding
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 8,14 ****
  #include "zutil.h"
  #include "inftrees.h"
  
! char inflate_copyright[] = " inflate 1.0 Copyright 1995-1996 Mark Adler ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
--- 8,14 ----
  #include "zutil.h"
  #include "inftrees.h"
  
! char inflate_copyright[] = " inflate 1.0.4 Copyright 1995-1996 Mark Adler ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
***************
*** 32,38 ****
      uIntf *,            /* list of extra bits for non-simple codes */
      inflate_huft * FAR*,/* result: starting table */
      uIntf *,            /* maximum lookup bits (returns actual) */
!     z_stream *));       /* for zalloc function */
  
  local voidpf falloc OF((
      voidpf,             /* opaque pointer (not used) */
--- 32,38 ----
      uIntf *,            /* list of extra bits for non-simple codes */
      inflate_huft * FAR*,/* result: starting table */
      uIntf *,            /* maximum lookup bits (returns actual) */
!     z_streamp ));       /* for zalloc function */
  
  local voidpf falloc OF((
      voidpf,             /* opaque pointer (not used) */
***************
*** 105,111 ****
  uIntf *e;               /* list of extra bits for non-simple codes */  
  inflate_huft * FAR *t;  /* result: starting table */
  uIntf *m;               /* maximum lookup bits, returns actual */
! z_stream *zs;           /* for zalloc function */
  /* Given a list of code lengths and a maximum table size, make a set of
     tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
     if the given code set is incomplete (the tables are still built in this
--- 105,111 ----
  uIntf *e;               /* list of extra bits for non-simple codes */  
  inflate_huft * FAR *t;  /* result: starting table */
  uIntf *m;               /* maximum lookup bits, returns actual */
! z_streamp zs;           /* for zalloc function */
  /* Given a list of code lengths and a maximum table size, make a set of
     tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
     if the given code set is incomplete (the tables are still built in this
***************
*** 217,223 ****
          w += l;                 /* previous table always l bits */
  
          /* compute minimum size table less than or equal to l bits */
!         z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
          if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
          {                       /* too few codes for k-w bit table */
            f -= a + 1;           /* deduct codes from patterns left */
--- 217,224 ----
          w += l;                 /* previous table always l bits */
  
          /* compute minimum size table less than or equal to l bits */
!         z = g - w;
!         z = z > (uInt)l ? l : z;        /* table size upper limit */
          if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
          {                       /* too few codes for k-w bit table */
            f -= a + 1;           /* deduct codes from patterns left */
***************
*** 270,276 ****
        }
        else
        {
!         r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
          r.base = d[*p++ - s];
        }
  
--- 271,277 ----
        }
        else
        {
!         r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
          r.base = d[*p++ - s];
        }
  
***************
*** 303,309 ****
  uIntf *c;               /* 19 code lengths */
  uIntf *bb;              /* bits tree desired/actual depth */
  inflate_huft * FAR *tb; /* bits tree result */
! z_stream *z;            /* for zfree function */
  {
    int r;
  
--- 304,310 ----
  uIntf *c;               /* 19 code lengths */
  uIntf *bb;              /* bits tree desired/actual depth */
  inflate_huft * FAR *tb; /* bits tree result */
! z_streamp z;            /* for zfree function */
  {
    int r;
  
***************
*** 328,334 ****
  uIntf *bd;              /* distance desired/actual bit depth */
  inflate_huft * FAR *tl; /* literal/length tree result */
  inflate_huft * FAR *td; /* distance tree result */
! z_stream *z;            /* for zfree function */
  {
    int r;
  
--- 329,335 ----
  uIntf *bd;              /* distance desired/actual bit depth */
  inflate_huft * FAR *tl; /* literal/length tree result */
  inflate_huft * FAR *td; /* distance tree result */
! z_streamp z;            /* for zfree function */
  {
    int r;
  
***************
*** 443,449 ****
  
  int inflate_trees_free(t, z)
  inflate_huft *t;        /* table to free */
! z_stream *z;            /* for zfree function */
  /* Free the malloc'ed tables built by huft_build(), which makes a linked
     list of the tables it made, with the links in a dummy first entry of
     each table. */
--- 444,450 ----
  
  int inflate_trees_free(t, z)
  inflate_huft *t;        /* table to free */
! z_streamp z;            /* for zfree function */
  /* Free the malloc'ed tables built by huft_build(), which makes a linked
     list of the tables it made, with the links in a dummy first entry of
     each table. */
*** xc/lib/zlib/inftrees.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:33 1996
--- xc/lib/zlib/inftrees.h	Wed Feb 26 17:40:48 1997
***************
*** 1,4 ****
! /* $XConsortium: inftrees.h /main/2 1996/03/07 13:53:36 mor $ */
  
  /* inftrees.h -- header to use inftrees.c
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: inftrees.h /main/4 1997/02/26 17:43:36 kaleb $ */
  
  /* inftrees.h -- header to use inftrees.c
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 37,43 ****
      uIntf *,                    /* 19 code lengths */
      uIntf *,                    /* bits tree desired/actual depth */
      inflate_huft * FAR *,       /* bits tree result */
!     z_stream *));               /* for zalloc, zfree functions */
  
  extern int inflate_trees_dynamic OF((
      uInt,                       /* number of literal/length codes */
--- 37,43 ----
      uIntf *,                    /* 19 code lengths */
      uIntf *,                    /* bits tree desired/actual depth */
      inflate_huft * FAR *,       /* bits tree result */
!     z_streamp ));               /* for zalloc, zfree functions */
  
  extern int inflate_trees_dynamic OF((
      uInt,                       /* number of literal/length codes */
***************
*** 47,53 ****
      uIntf *,                    /* distance desired/actual bit depth */
      inflate_huft * FAR *,       /* literal/length tree result */
      inflate_huft * FAR *,       /* distance tree result */
!     z_stream *));               /* for zalloc, zfree functions */
  
  extern int inflate_trees_fixed OF((
      uIntf *,                    /* literal desired/actual bit depth */
--- 47,53 ----
      uIntf *,                    /* distance desired/actual bit depth */
      inflate_huft * FAR *,       /* literal/length tree result */
      inflate_huft * FAR *,       /* distance tree result */
!     z_streamp ));               /* for zalloc, zfree functions */
  
  extern int inflate_trees_fixed OF((
      uIntf *,                    /* literal desired/actual bit depth */
***************
*** 57,61 ****
  
  extern int inflate_trees_free OF((
      inflate_huft *,             /* tables to free */
!     z_stream *));               /* for zfree function */
  
--- 57,61 ----
  
  extern int inflate_trees_free OF((
      inflate_huft *,             /* tables to free */
!     z_streamp ));               /* for zfree function */
  
*** xc/lib/zlib/infutil.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:36 1996
--- xc/lib/zlib/infutil.c	Wed Feb 26 17:40:55 1997
***************
*** 1,4 ****
! /* $XConsortium: infutil.c /main/2 1996/03/07 13:53:39 mor $ */
  
  /* inflate_util.c -- data and routines common to blocks and codes
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infutil.c /main/3 1997/02/26 17:43:42 kaleb $ */
  
  /* inflate_util.c -- data and routines common to blocks and codes
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 24,34 ****
  /* copy as much as possible from the sliding window to the output area */
  int inflate_flush(s, z, r)
  inflate_blocks_statef *s;
! z_stream *z;
  int r;
  {
    uInt n;
!   Bytef *p, *q;
  
    /* local copies of source and destination pointers */
    p = z->next_out;
--- 24,35 ----
  /* copy as much as possible from the sliding window to the output area */
  int inflate_flush(s, z, r)
  inflate_blocks_statef *s;
! z_streamp z;
  int r;
  {
    uInt n;
!   Bytef *p;
!   Bytef *q;
  
    /* local copies of source and destination pointers */
    p = z->next_out;
*** xc/lib/zlib/infutil.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:39 1996
--- xc/lib/zlib/infutil.h	Wed Feb 26 17:41:02 1997
***************
*** 1,4 ****
! /* $XConsortium: infutil.h /main/2 1996/03/07 13:53:43 mor $ */
  
  /* infutil.h -- types and macros common to blocks and codes
   * Copyright (C) 1995-1996 Mark Adler
--- 1,4 ----
! /* $TOG: infutil.h /main/3 1997/02/26 17:43:49 kaleb $ */
  
  /* infutil.h -- types and macros common to blocks and codes
   * Copyright (C) 1995-1996 Mark Adler
***************
*** 43,49 ****
        inflate_huft *tb;         /* bit length decoding tree */
      } trees;            /* if DTREE, decoding info for trees */
      struct {
!       inflate_huft *tl, *td;    /* trees to free */
        inflate_codes_statef 
           *codes;
      } decode;           /* if CODES, current state */
--- 43,50 ----
        inflate_huft *tb;         /* bit length decoding tree */
      } trees;            /* if DTREE, decoding info for trees */
      struct {
!       inflate_huft *tl;
!       inflate_huft *td;         /* trees to free */
        inflate_codes_statef 
           *codes;
      } decode;           /* if CODES, current state */
***************
*** 92,98 ****
  /* copy as much as possible from the sliding window to the output area */
  extern int inflate_flush OF((
      inflate_blocks_statef *,
!     z_stream *,
      int));
  
  struct internal_state      {int dummy;}; /* for buggy compilers */
--- 93,99 ----
  /* copy as much as possible from the sliding window to the output area */
  extern int inflate_flush OF((
      inflate_blocks_statef *,
!     z_streamp ,
      int));
  
  struct internal_state      {int dummy;}; /* for buggy compilers */
*** xc/lib/zlib/trees.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:43 1996
--- xc/lib/zlib/trees.c	Wed Feb 26 17:41:08 1997
***************
*** 1,4 ****
! /* $XConsortium: trees.c /main/2 1996/03/07 13:53:46 mor $ */
  
  /* trees.c -- output deflated data using Huffman coding
   * Copyright (C) 1995-1996 Jean-loup Gailly
--- 1,4 ----
! /* $TOG: trees.c /main/3 1997/02/26 17:43:55 kaleb $ */
  
  /* trees.c -- output deflated data using Huffman coding
   * Copyright (C) 1995-1996 Jean-loup Gailly
***************
*** 31,37 ****
   *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
   */
  
! /* $Id: trees.c /main/2 1996/03/07 13:53:46 mor $ */
  
  #include "deflate.h"
  
--- 31,37 ----
   *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
   */
  
! /* $Id: trees.c /main/3 1997/02/26 17:43:55 kaleb $ */
  
  #include "deflate.h"
  
***************
*** 156,162 ****
  
  #else /* DEBUG */
  #  define send_code(s, c, tree) \
!      { if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \
         send_bits(s, tree[c].Code, tree[c].Len); }
  #endif
  
--- 156,162 ----
  
  #else /* DEBUG */
  #  define send_code(s, c, tree) \
!      { if (verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
         send_bits(s, tree[c].Code, tree[c].Len); }
  #endif
  
***************
*** 234,240 ****
   */
  local void tr_static_init()
  {
!     static static_init_done = 0;
      int n;        /* iterates over tree elements */
      int bits;     /* bit counter */
      int length;   /* length value */
--- 234,240 ----
   */
  local void tr_static_init()
  {
!     static int static_init_done = 0;
      int n;        /* iterates over tree elements */
      int bits;     /* bit counter */
      int length;   /* length value */
*** xc/lib/zlib/zconf.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:47 1996
--- xc/lib/zlib/zconf.h	Wed Feb 26 17:41:16 1997
***************
*** 1,4 ****
! /* $XConsortium: zconf.h /main/2 1996/03/07 13:53:50 mor $ */
  
  /* zconf.h -- configuration of the zlib compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
--- 1,4 ----
! /* $TOG: zconf.h /main/3 1997/02/26 17:44:03 kaleb $ */
  
  /* zconf.h -- configuration of the zlib compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
***************
*** 5,18 ****
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: zconf.h /main/2 1996/03/07 13:53:50 mor $ */
  
  #ifndef _ZCONF_H
  #define _ZCONF_H
  
  /*
!  * People prefering a unique prefix for all types and library functions
!  * should compile with -DZ_PREFIX
   */
  #ifdef Z_PREFIX
  #  define deflateInit_	z_deflateInit_
--- 5,18 ----
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: zconf.h /main/3 1997/02/26 17:44:03 kaleb $ */
  
  #ifndef _ZCONF_H
  #define _ZCONF_H
  
  /*
!  * If you *really* need a unique prefix for all types and library functions,
!  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
   */
  #ifdef Z_PREFIX
  #  define deflateInit_	z_deflateInit_
***************
*** 22,31 ****
--- 22,33 ----
  #  define inflate	z_inflate
  #  define inflateEnd	z_inflateEnd
  #  define deflateInit2_	z_deflateInit2_
+ #  define deflateSetDictionary z_deflateSetDictionary
  #  define deflateCopy	z_deflateCopy
  #  define deflateReset	z_deflateReset
  #  define deflateParams	z_deflateParams
  #  define inflateInit2_	z_inflateInit2_
+ #  define inflateSetDictionary z_inflateSetDictionary
  #  define inflateSync	z_inflateSync
  #  define inflateReset	z_inflateReset
  #  define compress	z_compress
***************
*** 37,43 ****
  #  define Byte		z_Byte
  #  define uInt		z_uInt
  #  define uLong		z_uLong
! #  define Bytef		z_Bytef
  #  define charf		z_charf
  #  define intf		z_intf
  #  define uIntf		z_uIntf
--- 39,45 ----
  #  define Byte		z_Byte
  #  define uInt		z_uInt
  #  define uLong		z_uLong
! #  define Bytef	        z_Bytef
  #  define charf		z_charf
  #  define intf		z_intf
  #  define uIntf		z_uIntf
***************
*** 49,56 ****
  #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
  #  define WIN32
  #endif
! #if (defined(__GNUC__) || defined(WIN32)) && !defined(__32BIT__)
! #  define __32BIT__
  #endif
  #if defined(__MSDOS__) && !defined(MSDOS)
  #  define MSDOS
--- 51,60 ----
  #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
  #  define WIN32
  #endif
! #if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
! #  ifndef __32BIT__
! #    define __32BIT__
! #  endif
  #endif
  #if defined(__MSDOS__) && !defined(MSDOS)
  #  define MSDOS
***************
*** 74,86 ****
  #  define STDC
  #endif
  
! #if !defined(STDC) && !defined(const)
! #  define const
  #endif
  
! #ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
! #  include <unix.h>
! #  define Byte _Byte /* Byte already used on Mac */
  #endif
  
  /* Maximum value for memLevel in deflateInit2 */
--- 78,92 ----
  #  define STDC
  #endif
  
! #ifndef STDC
! #  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
! #    define const
! #  endif
  #endif
  
! /* Some Mac compilers merge all .h files incorrectly: */
! #if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
! #  define NO_DUMMY_DECL
  #endif
  
  /* Maximum value for memLevel in deflateInit2 */
***************
*** 126,132 ****
   * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
   * just define FAR to be empty.
   */
! #if defined(M_I86SM) || defined(M_I86MM) /* MSC small or medium model */
  #  define SMALL_MEDIUM
  #  ifdef _MSC_VER
  #    define FAR __far
--- 132,139 ----
   * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
   * just define FAR to be empty.
   */
! #if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
!    /* MSC small or medium model */
  #  define SMALL_MEDIUM
  #  ifdef _MSC_VER
  #    define FAR __far
***************
*** 135,157 ****
  #  endif
  #endif
  #if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
  #    define SMALL_MEDIUM
  #    define FAR __far
  #endif
  #ifndef FAR
  #   define FAR
  #endif
- /* The Watcom compiler defines M_I86SM and __SMALL__ even in 32 bit mode */
- #if defined(__WATCOMC__) && defined(__386__)
- #  undef FAR
- #  undef SMALL_MEDIUM
- #endif
  
  typedef unsigned char  Byte;  /* 8 bits */
  typedef unsigned int   uInt;  /* 16 bits or more */
  typedef unsigned long  uLong; /* 32 bits or more */
  
! typedef Byte  FAR Bytef;
  typedef char  FAR charf;
  typedef int   FAR intf;
  typedef uInt  FAR uIntf;
--- 142,166 ----
  #  endif
  #endif
  #if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
+ #  ifndef __32BIT__
  #    define SMALL_MEDIUM
  #    define FAR __far
+ #  endif
  #endif
  #ifndef FAR
  #   define FAR
  #endif
  
  typedef unsigned char  Byte;  /* 8 bits */
  typedef unsigned int   uInt;  /* 16 bits or more */
  typedef unsigned long  uLong; /* 32 bits or more */
  
! #if defined(__BORLANDC__) && defined(SMALL_MEDIUM)
!    /* Borland C/C++ ignores FAR inside typedef */
! #  define Bytef Byte FAR
! #else
!    typedef Byte  FAR Bytef;
! #endif
  typedef char  FAR charf;
  typedef int   FAR intf;
  typedef uInt  FAR uIntf;
***************
*** 163,168 ****
--- 172,186 ----
  #else
     typedef Byte FAR *voidpf;
     typedef Byte     *voidp;
+ #endif
+ 
+ 
+ /* Compile with -DZLIB_DLL for Windows DLL support */
+ #if (defined(_WINDOWS) || defined(WINDOWS)) && defined(ZLIB_DLL)
+ #  include <windows.h>
+ #  define EXPORT  WINAPI
+ #else
+ #  define EXPORT
  #endif
  
  #endif /* _ZCONF_H */
*** xc/lib/zlib/zlib.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:51 1996
--- xc/lib/zlib/zlib.h	Wed Feb 26 17:41:23 1997
***************
*** 1,7 ****
! /* $XConsortium: zlib.h /main/2 1996/03/07 13:53:54 mor $ */
  
  /* zlib.h -- interface of the 'zlib' general purpose compression library
!   version 1.0, Jan 27th, 1996.
  
    Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler
  
--- 1,7 ----
! /* $TOG: zlib.h /main/3 1997/02/26 17:44:11 kaleb $ */
  
  /* zlib.h -- interface of the 'zlib' general purpose compression library
!   version 1.0.4, Jul 24th, 1996.
  
    Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler
  
***************
*** 23,30 ****
  
    Jean-loup Gailly        Mark Adler
    gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
-  */
  
  #ifndef _ZLIB_H
  #define _ZLIB_H
  
--- 23,35 ----
  
    Jean-loup Gailly        Mark Adler
    gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
  
+ 
+   The data format used by the zlib library is described by RFCs (Request for
+   Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+   (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+ */
+ 
  #ifndef _ZLIB_H
  #define _ZLIB_H
  
***************
*** 34,40 ****
  
  #include "zconf.h"
  
! #define ZLIB_VERSION "1.0"
  
  /* 
       The 'zlib' compression library provides in-memory compression and
--- 39,45 ----
  
  #include "zconf.h"
  
! #define ZLIB_VERSION "1.0.4"
  
  /* 
       The 'zlib' compression library provides in-memory compression and
***************
*** 86,91 ****
--- 91,98 ----
      uLong   reserved;   /* reserved for future use */
  } z_stream;
  
+ typedef z_stream FAR *z_streamp;
+ 
  /*
     The application must update next_in and avail_in when avail_in has
     dropped to zero. It must update next_out and avail_out when avail_out
***************
*** 158,173 ****
  
  #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
  
! extern const char *zlib_version;
! /* The application can compare zlib_version and ZLIB_VERSION for consistency.
     If the first character differs, the library code actually used is
     not compatible with the zlib.h header file used by the application.
   */
  
-                         /* basic functions */
- 
  /* 
! extern int deflateInit OF((z_stream *strm, int level));
  
       Initializes the internal stream state for compression. The fields
     zalloc, zfree and opaque must be initialized before by the caller.
--- 165,184 ----
  
  #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
  
! #define zlib_version zlibVersion()
! /* for compatibility with versions < 1.0.2 */
! 
!                         /* basic functions */
! 
! extern const char * EXPORT zlibVersion OF((void));
! /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
     If the first character differs, the library code actually used is
     not compatible with the zlib.h header file used by the application.
+    This check is automatically made by deflateInit and inflateInit.
   */
  
  /* 
! extern int EXPORT deflateInit OF((z_streamp strm, int level));
  
       Initializes the internal stream state for compression. The fields
     zalloc, zfree and opaque must be initialized before by the caller.
***************
*** 189,195 ****
  */
  
  
! extern int deflate OF((z_stream *strm, int flush));
  /*
    Performs one or both of the following actions:
  
--- 200,206 ----
  */
  
  
! extern int EXPORT deflate OF((z_streamp strm, int flush));
  /*
    Performs one or both of the following actions:
  
***************
*** 209,215 ****
    more output, and updating avail_in or avail_out accordingly; avail_out
    should never be zero before the call. The application can consume the
    compressed output when it wants, for example when the output buffer is full
!   (avail_out == 0), or after each call of deflate().
  
      If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
    block is terminated and flushed to the output buffer so that the
--- 220,228 ----
    more output, and updating avail_in or avail_out accordingly; avail_out
    should never be zero before the call. The application can consume the
    compressed output when it wants, for example when the output buffer is full
!   (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
!   and with zero avail_out, it must be called again after making room in the
!   output buffer because there might be more output pending.
  
      If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
    block is terminated and flushed to the output buffer so that the
***************
*** 230,237 ****
    parameter and more output space (updated avail_out), until the flush is
    complete (deflate returns with non-zero avail_out).
  
!     If the parameter flush is set to Z_FINISH, all pending input is processed,
!   all pending output is flushed and deflate returns with Z_STREAM_END if there
    was enough output space; if deflate returns with Z_OK, this function must be
    called again with Z_FINISH and more output space (updated avail_out) but no
    more input data, until it returns with Z_STREAM_END or an error. After
--- 243,250 ----
    parameter and more output space (updated avail_out), until the flush is
    complete (deflate returns with non-zero avail_out).
  
!     If the parameter flush is set to Z_FINISH, pending input is processed,
!   pending output is flushed and deflate returns with Z_STREAM_END if there
    was enough output space; if deflate returns with Z_OK, this function must be
    called again with Z_FINISH and more output space (updated avail_out) but no
    more input data, until it returns with Z_STREAM_END or an error. After
***************
*** 256,262 ****
  */
  
  
! extern int deflateEnd OF((z_stream *strm));
  /*
       All dynamically allocated data structures for this stream are freed.
     This function discards any unprocessed input and does not flush any
--- 269,275 ----
  */
  
  
! extern int EXPORT deflateEnd OF((z_streamp strm));
  /*
       All dynamically allocated data structures for this stream are freed.
     This function discards any unprocessed input and does not flush any
***************
*** 271,277 ****
  
  
  /* 
! extern int inflateInit OF((z_stream *strm));
  
       Initializes the internal stream state for decompression. The fields
     zalloc, zfree and opaque must be initialized before by the caller.  If
--- 284,290 ----
  
  
  /* 
! extern int EXPORT inflateInit OF((z_streamp strm));
  
       Initializes the internal stream state for decompression. The fields
     zalloc, zfree and opaque must be initialized before by the caller.  If
***************
*** 286,292 ****
  */
  
  
! extern int inflate OF((z_stream *strm, int flush));
  /*
    Performs one or both of the following actions:
  
--- 299,305 ----
  */
  
  
! extern int EXPORT inflate OF((z_streamp strm, int flush));
  /*
    Performs one or both of the following actions:
  
***************
*** 296,303 ****
      will resume at this point for the next call of inflate().
  
    - Provide more output starting at next_out and update next_out and avail_out
!     accordingly.  inflate() always provides as much output as possible
!     (until there is no more input data or no more space in the output buffer).
  
    Before the call of inflate(), the application should ensure that at least
    one of the actions is possible, by providing more input and/or consuming
--- 309,317 ----
      will resume at this point for the next call of inflate().
  
    - Provide more output starting at next_out and update next_out and avail_out
!     accordingly.  inflate() provides as much output as possible, until there
!     is no more input data or no more space in the output buffer (see below
!     about the flush parameter).
  
    Before the call of inflate(), the application should ensure that at least
    one of the actions is possible, by providing more input and/or consuming
***************
*** 304,310 ****
    more output, and updating the next_* and avail_* values accordingly.
    The application can consume the uncompressed output when it wants, for
    example when the output buffer is full (avail_out == 0), or after each
!   call of inflate().
  
      If the parameter flush is set to Z_PARTIAL_FLUSH, inflate flushes as much
    output as possible to the output buffer. The flushing behavior of inflate is
--- 318,326 ----
    more output, and updating the next_* and avail_* values accordingly.
    The application can consume the uncompressed output when it wants, for
    example when the output buffer is full (avail_out == 0), or after each
!   call of inflate(). If inflate returns Z_OK and with zero avail_out, it
!   must be called again after making room in the output buffer because there
!   might be more output pending.
  
      If the parameter flush is set to Z_PARTIAL_FLUSH, inflate flushes as much
    output as possible to the output buffer. The flushing behavior of inflate is
***************
*** 338,344 ****
  */
  
  
! extern int inflateEnd OF((z_stream *strm));
  /*
       All dynamically allocated data structures for this stream are freed.
     This function discards any unprocessed input and does not flush any
--- 354,360 ----
  */
  
  
! extern int EXPORT inflateEnd OF((z_streamp strm));
  /*
       All dynamically allocated data structures for this stream are freed.
     This function discards any unprocessed input and does not flush any
***************
*** 356,367 ****
  */
  
  /*   
! extern int deflateInit2 OF((z_stream *strm,
!                             int  level,
!                             int  method,
!                             int  windowBits,
!                             int  memLevel,
!                             int  strategy));
  
       This is another version of deflateInit with more compression options. The
     fields next_in, zalloc, zfree and opaque must be initialized before by
--- 372,383 ----
  */
  
  /*   
! extern int EXPORT deflateInit2 OF((z_streamp strm,
!                                    int  level,
!                                    int  method,
!                                    int  windowBits,
!                                    int  memLevel,
!                                    int  strategy));
  
       This is another version of deflateInit with more compression options. The
     fields next_in, zalloc, zfree and opaque must be initialized before by
***************
*** 414,422 ****
     deflate(). 
  */
                              
! extern int deflateSetDictionary OF((z_stream *strm,
! 				    const Bytef *dictionary,
! 				    uInt  dictLength));
  /*
       Initializes the compression dictionary (history buffer) from the given
     byte sequence without producing any compressed output. This function must
--- 430,438 ----
     deflate(). 
  */
                              
! extern int EXPORT deflateSetDictionary OF((z_streamp strm,
!                                            const Bytef *dictionary,
! 				           uInt  dictLength));
  /*
       Initializes the compression dictionary (history buffer) from the given
     byte sequence without producing any compressed output. This function must
***************
*** 443,450 ****
     be done by deflate(). 
  */
  
! extern int deflateCopy OF((z_stream *dest,
!                            z_stream *source));
  /*
       Sets the destination stream as a complete copy of the source stream.  If
     the source stream is using an application-supplied history buffer, a new
--- 459,466 ----
     be done by deflate(). 
  */
  
! extern int EXPORT deflateCopy OF((z_streamp dest,
!                                   z_streamp source));
  /*
       Sets the destination stream as a complete copy of the source stream.  If
     the source stream is using an application-supplied history buffer, a new
***************
*** 466,472 ****
     destination.
  */
  
! extern int deflateReset OF((z_stream *strm));
  /*
       This function is equivalent to deflateEnd followed by deflateInit,
     but does not free and reallocate all the internal compression state.
--- 482,488 ----
     destination.
  */
  
! extern int EXPORT deflateReset OF((z_streamp strm));
  /*
       This function is equivalent to deflateEnd followed by deflateInit,
     but does not free and reallocate all the internal compression state.
***************
*** 477,483 ****
     stream state was inconsistent (such as zalloc or state being NULL).
  */
  
! extern int deflateParams OF((z_stream *strm, int level, int strategy));
  /*
       Dynamically update the compression level and compression strategy.
     This can be used to switch between compression and straight copy of
--- 493,499 ----
     stream state was inconsistent (such as zalloc or state being NULL).
  */
  
! extern int EXPORT deflateParams OF((z_streamp strm, int level, int strategy));
  /*
       Dynamically update the compression level and compression strategy.
     This can be used to switch between compression and straight copy of
***************
*** 486,498 ****
     available so far is compressed with the old level (and may be flushed);
     the new level will take effect only at the next call of deflate().
  
       deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
!    stream state was inconsistent or if a parameter was invalid.
  */
  
  /*   
! extern int inflateInit2 OF((z_stream *strm,
!                             int  windowBits));
  
       This is another version of inflateInit with more compression options. The
     fields next_out, zalloc, zfree and opaque must be initialized before by
--- 502,519 ----
     available so far is compressed with the old level (and may be flushed);
     the new level will take effect only at the next call of deflate().
  
+      Before the call of deflateParams, the stream state must be set as for
+    a call of deflate(), since the currently available input may have to
+    be compressed and flushed. In particular, strm->avail_out must be non-zero.
+ 
       deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
!    stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
!    if strm->avail_out was zero.
  */
  
  /*   
! extern int EXPORT inflateInit2 OF((z_streamp strm,
!                                    int  windowBits));
  
       This is another version of inflateInit with more compression options. The
     fields next_out, zalloc, zfree and opaque must be initialized before by
***************
*** 525,533 ****
     inflate().
  */
  
! extern int inflateSetDictionary OF((z_stream *strm,
! 				    const Bytef *dictionary,
! 				    uInt  dictLength));
  /*
       Initializes the decompression dictionary (history buffer) from the given
     uncompressed byte sequence. This function must be called immediately after
--- 546,554 ----
     inflate().
  */
  
! extern int EXPORT inflateSetDictionary OF((z_streamp strm,
! 				           const Bytef *dictionary,
! 					   uInt  dictLength));
  /*
       Initializes the decompression dictionary (history buffer) from the given
     uncompressed byte sequence. This function must be called immediately after
***************
*** 544,550 ****
     inflate().
  */
  
! extern int inflateSync OF((z_stream *strm));
  /* 
      Skips invalid compressed data until the special marker (see deflate()
    above) can be found, or until all available input is skipped. No output
--- 565,571 ----
     inflate().
  */
  
! extern int EXPORT inflateSync OF((z_streamp strm));
  /* 
      Skips invalid compressed data until the special marker (see deflate()
    above) can be found, or until all available input is skipped. No output
***************
*** 559,565 ****
    until success or end of the input data.
  */
  
! extern int inflateReset OF((z_stream *strm));
  /*
       This function is equivalent to inflateEnd followed by inflateInit,
     but does not free and reallocate all the internal decompression state.
--- 580,586 ----
    until success or end of the input data.
  */
  
! extern int EXPORT inflateReset OF((z_streamp strm));
  /*
       This function is equivalent to inflateEnd followed by inflateInit,
     but does not free and reallocate all the internal decompression state.
***************
*** 580,587 ****
     utility functions can easily be modified if you need special options.
  */
  
! extern int compress OF((Bytef *dest,   uLongf *destLen,
!                         const Bytef *source, uLong sourceLen));
  /*
       Compresses the source buffer into the destination buffer.  sourceLen is
     the byte length of the source buffer. Upon entry, destLen is the total
--- 601,608 ----
     utility functions can easily be modified if you need special options.
  */
  
! extern int EXPORT compress OF((Bytef *dest,   uLongf *destLen,
! 			       const Bytef *source, uLong sourceLen));
  /*
       Compresses the source buffer into the destination buffer.  sourceLen is
     the byte length of the source buffer. Upon entry, destLen is the total
***************
*** 595,602 ****
     buffer.
  */
  
! extern int uncompress OF((Bytef *dest,   uLongf *destLen,
!                           const Bytef *source, uLong sourceLen));
  /*
       Decompresses the source buffer into the destination buffer.  sourceLen is
     the byte length of the source buffer. Upon entry, destLen is the total
--- 616,623 ----
     buffer.
  */
  
! extern int EXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
! 				 const Bytef *source, uLong sourceLen));
  /*
       Decompresses the source buffer into the destination buffer.  sourceLen is
     the byte length of the source buffer. Upon entry, destLen is the total
***************
*** 616,622 ****
  
  typedef voidp gzFile;
  
! extern gzFile gzopen  OF((const char *path, const char *mode));
  /*
       Opens a gzip (.gz) file for reading or writing. The mode parameter
     is as in fopen ("rb" or "wb") but can also include a compression level
--- 637,643 ----
  
  typedef voidp gzFile;
  
! extern gzFile EXPORT gzopen  OF((const char *path, const char *mode));
  /*
       Opens a gzip (.gz) file for reading or writing. The mode parameter
     is as in fopen ("rb" or "wb") but can also include a compression level
***************
*** 628,639 ****
     zlib error is Z_MEM_ERROR).
  */
  
! extern gzFile gzdopen  OF((int fd, const char *mode));
  /*
       gzdopen() associates a gzFile with the file descriptor fd.  File
     descriptors are obtained from calls like open, dup, creat, pipe or
     fileno (in the file has been previously opened with fopen).
!    The mode parameter is as in fopen ("rb" or "wb").
       The next call of gzclose on the returned gzFile will also close the
     file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
     descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
--- 649,660 ----
     zlib error is Z_MEM_ERROR).
  */
  
! extern gzFile EXPORT gzdopen  OF((int fd, const char *mode));
  /*
       gzdopen() associates a gzFile with the file descriptor fd.  File
     descriptors are obtained from calls like open, dup, creat, pipe or
     fileno (in the file has been previously opened with fopen).
!    The mode parameter is as in gzopen.
       The next call of gzclose on the returned gzFile will also close the
     file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
     descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
***************
*** 641,647 ****
     the (de)compression state.
  */
  
! extern int    gzread  OF((gzFile file, voidp buf, unsigned len));
  /*
       Reads the given number of uncompressed bytes from the compressed file.
     If the input file was not in gzip format, gzread copies the given number
--- 662,668 ----
     the (de)compression state.
  */
  
! extern int EXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
  /*
       Reads the given number of uncompressed bytes from the compressed file.
     If the input file was not in gzip format, gzread copies the given number
***************
*** 649,655 ****
       gzread returns the number of uncompressed bytes actually read (0 for
     end of file, -1 for error). */
  
! extern int    gzwrite OF((gzFile file, const voidp buf, unsigned len));
  /*
       Writes the given number of uncompressed bytes into the compressed file.
     gzwrite returns the number of uncompressed bytes actually written
--- 670,676 ----
       gzread returns the number of uncompressed bytes actually read (0 for
     end of file, -1 for error). */
  
! extern int EXPORT    gzwrite OF((gzFile file, const voidp buf, unsigned len));
  /*
       Writes the given number of uncompressed bytes into the compressed file.
     gzwrite returns the number of uncompressed bytes actually written
***************
*** 656,662 ****
     (0 in case of error).
  */
  
! extern int    gzflush OF((gzFile file, int flush));
  /*
       Flushes all pending output into the compressed file. The parameter
     flush is as in the deflate() function. The return value is the zlib
--- 677,683 ----
     (0 in case of error).
  */
  
! extern int EXPORT    gzflush OF((gzFile file, int flush));
  /*
       Flushes all pending output into the compressed file. The parameter
     flush is as in the deflate() function. The return value is the zlib
***************
*** 666,672 ****
     degrade compression.
  */
  
! extern int    gzclose OF((gzFile file));
  /*
       Flushes all pending output if necessary, closes the compressed file
     and deallocates all the (de)compression state. The return value is the zlib
--- 687,693 ----
     degrade compression.
  */
  
! extern int EXPORT    gzclose OF((gzFile file));
  /*
       Flushes all pending output if necessary, closes the compressed file
     and deallocates all the (de)compression state. The return value is the zlib
***************
*** 673,679 ****
     error number (see function gzerror below).
  */
  
! extern char*   gzerror OF((gzFile file, int *errnum));
  /*
       Returns the error message for the last error which occurred on the
     given compressed file. errnum is set to zlib error number. If an
--- 694,700 ----
     error number (see function gzerror below).
  */
  
! extern const char * EXPORT gzerror OF((gzFile file, int *errnum));
  /*
       Returns the error message for the last error which occurred on the
     given compressed file. errnum is set to zlib error number. If an
***************
*** 690,696 ****
     compression library.
  */
  
! extern uLong adler32 OF((uLong adler, const Bytef *buf, uInt len));
  
  /*
       Update a running Adler-32 checksum with the bytes buf[0..len-1] and
--- 711,717 ----
     compression library.
  */
  
! extern uLong EXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
  
  /*
       Update a running Adler-32 checksum with the bytes buf[0..len-1] and
***************
*** 707,713 ****
       if (adler != original_adler) error();
  */
  
! extern uLong crc32   OF((uLong crc, const Bytef *buf, uInt len));
  /*
       Update a running crc with the bytes buf[0..len-1] and return the updated
     crc. If buf is NULL, this function returns the required initial value
--- 728,734 ----
       if (adler != original_adler) error();
  */
  
! extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
  /*
       Update a running crc with the bytes buf[0..len-1] and return the updated
     crc. If buf is NULL, this function returns the required initial value
***************
*** 729,743 ****
  /* deflateInit and inflateInit are macros to allow checking the zlib version
   * and the compiler's view of z_stream:
   */
! extern int deflateInit_ OF((z_stream *strm, int level,
! 			    const char *version, int stream_size));
! extern int inflateInit_ OF((z_stream *strm,
! 			    const char *version, int stream_size));
! extern int deflateInit2_ OF((z_stream *strm, int  level, int  method,
!                              int  windowBits, int  memLevel, int  strategy,
! 			     const char *version, int stream_size));
! extern int inflateInit2_ OF((z_stream *strm, int  windowBits,
! 			     const char *version, int stream_size));
  #define deflateInit(strm, level) \
          deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
  #define inflateInit(strm) \
--- 750,764 ----
  /* deflateInit and inflateInit are macros to allow checking the zlib version
   * and the compiler's view of z_stream:
   */
! extern int EXPORT deflateInit_ OF((z_streamp strm, int level,
! 			           const char *version, int stream_size));
! extern int EXPORT inflateInit_ OF((z_streamp strm,
! 				   const char *version, int stream_size));
! extern int EXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
! 				    int windowBits, int memLevel, int strategy,
! 				    const char *version, int stream_size));
! extern int EXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
! 				    const char *version, int stream_size));
  #define deflateInit(strm, level) \
          deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
  #define inflateInit(strm) \
***************
*** 748,754 ****
  #define inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
  
! #ifndef _Z_UTIL_H
      struct internal_state {int dummy;}; /* hack for buggy compilers */
  #endif
  
--- 769,775 ----
  #define inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
  
! #if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
      struct internal_state {int dummy;}; /* hack for buggy compilers */
  #endif
  
*** xc/lib/zlib/zutil.c@@/PUBLIC-LATEST	Thu Mar  7 13:55:55 1996
--- xc/lib/zlib/zutil.c	Wed Feb 26 17:41:32 1997
***************
*** 1,4 ****
! /* $XConsortium: zutil.c /main/2 1996/03/07 13:53:58 mor $ */
  
  /* zutil.c -- target dependent utility functions for the compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
--- 1,4 ----
! /* $TOG: zutil.c /main/3 1997/02/26 17:44:19 kaleb $ */
  
  /* zutil.c -- target dependent utility functions for the compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
***************
*** 5,11 ****
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: zutil.c /main/2 1996/03/07 13:53:58 mor $ */
  
  #include <stdio.h>
  
--- 5,11 ----
   * For conditions of distribution and use, see copyright notice in zlib.h 
   */
  
! /* $Id: zutil.c /main/3 1997/02/26 17:44:19 kaleb $ */
  
  #include <stdio.h>
  
***************
*** 17,24 ****
  extern void exit OF((int));
  #endif
  
- const char *zlib_version = ZLIB_VERSION;
- 
  const char *z_errmsg[10] = {
  "need dictionary",     /* Z_NEED_DICT       2  */
  "stream end",          /* Z_STREAM_END      1  */
--- 17,22 ----
***************
*** 32,37 ****
--- 30,41 ----
  ""};
  
  
+ const char *zlibVersion()
+ {
+     return ZLIB_VERSION;
+ }
+ 
+ #ifdef DEBUG
  void z_error (m)
      char *m;
  {
***************
*** 38,43 ****
--- 42,48 ----
      fprintf(stderr, "%s\n", m);
      exit(1);
  }
+ #endif
  
  #ifndef HAVE_MEMCPY
  
***************
*** 52,57 ****
--- 57,75 ----
      } while (--len != 0);
  }
  
+ int zmemcmp(s1, s2, len)
+     Bytef* s1;
+     Bytef* s2;
+     uInt  len;
+ {
+     uInt j;
+ 
+     for (j = 0; j < len; j++) {
+         if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+     }
+     return 0;
+ }
+ 
  void zmemzero(dest, len)
      Bytef* dest;
      uInt  len;
***************
*** 137,150 ****
          return;
      }
      ptr = opaque; /* just to make some compilers happy */
!     z_error("zcfree: ptr not found");
  }
  #endif
  #endif /* __TURBOC__ */
  
  
! #if defined(M_I86) && !(defined(__WATCOMC__) && defined(__386__))
! /* Microsoft C */
  
  #  define MY_ZCALLOC
  
--- 155,168 ----
          return;
      }
      ptr = opaque; /* just to make some compilers happy */
!     Assert(0, "zcfree: ptr not found");
  }
  #endif
  #endif /* __TURBOC__ */
  
  
! #if defined(M_I86) && !defined(__32BIT__)
! /* Microsoft C in 16-bit mode */
  
  #  define MY_ZCALLOC
  
***************
*** 180,186 ****
      unsigned items;
      unsigned size;
  {
!     if (opaque) opaque = 0; /* to make compiler happy */
      return (voidpf)calloc(items, size);
  }
  
--- 198,204 ----
      unsigned items;
      unsigned size;
  {
!     if (opaque) items += size - size; /* make compiler happy */
      return (voidpf)calloc(items, size);
  }
  
***************
*** 188,195 ****
      voidpf opaque;
      voidpf ptr;
  {
-     if (opaque) opaque = 0; /* to make compiler happy */
      free(ptr);
  }
  
  #endif /* MY_ZCALLOC */
--- 206,213 ----
      voidpf opaque;
      voidpf ptr;
  {
      free(ptr);
+     if (opaque) return; /* make compiler happy */
  }
  
  #endif /* MY_ZCALLOC */
*** xc/lib/zlib/zutil.h@@/PUBLIC-LATEST	Thu Mar  7 13:55:58 1996
--- xc/lib/zlib/zutil.h	Wed Feb 26 17:41:39 1997
***************
*** 1,4 ****
! /* $XConsortium: zutil.h /main/2 1996/03/07 13:54:02 mor $ */
  
  /* zutil.h -- internal interface and configuration of the compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
--- 1,4 ----
! /* $TOG: zutil.h /main/3 1997/02/26 17:44:26 kaleb $ */
  
  /* zutil.h -- internal interface and configuration of the compression library
   * Copyright (C) 1995-1996 Jean-loup Gailly.
***************
*** 10,16 ****
     subject to change. Applications should only use zlib.h.
   */
  
! /* $Id: zutil.h /main/2 1996/03/07 13:54:02 mor $ */
  
  #ifndef _Z_UTIL_H
  #define _Z_UTIL_H
--- 10,16 ----
     subject to change. Applications should only use zlib.h.
   */
  
! /* $Id: zutil.h /main/3 1997/02/26 17:44:26 kaleb $ */
  
  #ifndef _Z_UTIL_H
  #define _Z_UTIL_H
***************
*** 17,23 ****
  
  #include "zlib.h"
  
! #if defined(MSDOS) || defined(VMS) || defined(CRAY) || defined(WIN32)
  #   include <stddef.h>
  #   include <errno.h>
  #else
--- 17,23 ----
  
  #include "zlib.h"
  
! #if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
  #   include <stddef.h>
  #   include <errno.h>
  #else
***************
*** 42,51 ****
  extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
  /* (size given to avoid silly warnings with Visual C++) */
  
! #define ERR_MSG(err) (char*)z_errmsg[Z_NEED_DICT-(err)]
  
  #define ERR_RETURN(strm,err) \
!   return (strm->msg = ERR_MSG(err), (err))
  /* To be used only when the state is known to be valid */
  
          /* common constants */
--- 42,51 ----
  extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
  /* (size given to avoid silly warnings with Visual C++) */
  
! #define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
  
  #define ERR_RETURN(strm,err) \
!   return (strm->msg = (char*)ERR_MSG(err), (err))
  /* To be used only when the state is known to be valid */
  
          /* common constants */
***************
*** 118,123 ****
--- 118,127 ----
  #  define OS_CODE  0x0a
  #endif
  
+ #if defined(_BEOS_) || defined(RISCOS)
+ #  define fdopen(fd,mode) NULL /* No fdopen() */
+ #endif
+ 
          /* Common defaults */
  
  #ifndef OS_CODE
***************
*** 161,166 ****
--- 165,171 ----
  #  endif
  #else
     extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
+    extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
     extern void zmemzero OF((Bytef* dest, uInt len));
  #endif
  
***************
*** 170,175 ****
--- 175,181 ----
  #  ifndef verbose
  #    define verbose 0
  #  endif
+    extern void z_error    OF((char *m));
  #  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
  #  define Trace(x) fprintf x
  #  define Tracev(x) {if (verbose) fprintf x ;}
***************
*** 187,194 ****
  
  
  typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));
- 
- extern void z_error    OF((char *m));
  
  voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
  void   zcfree  OF((voidpf opaque, voidpf ptr));
--- 193,198 ----
*** xc/nls/XLC_LOCALE/Imakefile@@/PUBLIC-LATEST	Tue Nov 19 10:39:58 1996
--- xc/nls/XLC_LOCALE/Imakefile	Wed Jun 11 06:50:58 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/13 1996/11/19 10:35:28 kaleb $
  
    WCHAR32 = HasWChar32
     TBLDIR = $(XLOCALEDIR)/tbl_data
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/14 1997/06/11 06:46:23 kaleb $
  
    WCHAR32 = HasWChar32
     TBLDIR = $(XLOCALEDIR)/tbl_data
***************
*** 12,18 ****
  all:: name.lt								@@\
  	MakeDir($(BUILDLIBDIR)/locale/name)				@@\
  	RemoveFile($(BUILDLIBDIR)/locale/name/XLC_LOCALE)		@@\
! 	cd $(BUILDLIBDIR)/locale/name && $(LN) $(BUILDLIBTOP)/../../$(CURRENT_DIR)/name XLC_LOCALE @@\
  									@@\
  InstallNamedNonExec(name.lt,XLC_LOCALE,$(XLOCALEDIR)/name)
  #else
--- 12,18 ----
  all:: name.lt								@@\
  	MakeDir($(BUILDLIBDIR)/locale/name)				@@\
  	RemoveFile($(BUILDLIBDIR)/locale/name/XLC_LOCALE)		@@\
! 	cd $(BUILDLIBDIR)/locale/name && $(LN) $(BUILDLIBTOP)/../../$(CURRENT_DIR)/name.lt XLC_LOCALE @@\
  									@@\
  InstallNamedNonExec(name.lt,XLC_LOCALE,$(XLOCALEDIR)/name)
  #else
***************
*** 24,30 ****
  all:: name.lt								@@\
  	MakeDir(Concat($(BUILDLIBDIR:/=\)\locale\,name))		@@\
  	RemoveFile(Concat($(BUILDLIBDIR:/=\)\locale\,name\XLC_LOCALE))	@@\
! 	cd Concat($(BUILDLIBDIR:/=\)\locale\,name) && $(LN) Concat($(BUILDLIBTOP:/=\)\..\..\$(CURRENT_DIR:/=\)\,name) XLC_LOCALE @@\
  									@@\
  InstallNamedNonExec(name.lt,XLC_LOCALE,$(XLOCALEDIR)/name)
  #endif
--- 24,30 ----
  all:: name.lt								@@\
  	MakeDir(Concat($(BUILDLIBDIR:/=\)\locale\,name))		@@\
  	RemoveFile(Concat($(BUILDLIBDIR:/=\)\locale\,name\XLC_LOCALE))	@@\
! 	cd Concat($(BUILDLIBDIR:/=\)\locale\,name) && $(LN) Concat($(BUILDLIBTOP:/=\)\..\..\$(CURRENT_DIR:/=\)\,name.lt) XLC_LOCALE @@\
  									@@\
  InstallNamedNonExec(name.lt,XLC_LOCALE,$(XLOCALEDIR)/name)
  #endif
*** xc/nls/XLC_LOCALE/zh_TW@@/PUBLIC-LATEST	Sat Sep 28 17:01:04 1996
--- xc/nls/XLC_LOCALE/zh_TW	Fri Apr 18 07:58:03 1997
***************
*** 1,4 ****
! XCOMM  $XConsortium: zh_TW /main/7 1996/09/28 16:52:44 rws $
  XCOMM  XLocale Database Sample for zh_TW
  XCOMM 
  XCOMM Note: In lib/X11/lcCT.c, charset names for CNS11643 coded character
--- 1,4 ----
! XCOMM  $TOG: zh_TW /main/8 1997/04/18 07:51:12 barstow $
  XCOMM  XLocale Database Sample for zh_TW
  XCOMM 
  XCOMM Note: In lib/X11/lcCT.c, charset names for CNS11643 coded character
***************
*** 6,12 ****
  XCOMM CNS coded character sets 1-7 are registered as CNS 11643-1992.
  XCOMM CJK.INF Version 1.7 (August 15, 1995) written by Ken Lunde says
  XCOMM plane 14 of CNS 11643-1983 now became plane 3 of CNS 11643-1992.
! XCOMM I don't know how Taiwanese EUC is organized currently, so I left the
  XCOMM X11R6 organization of fsN/csN as it is and only changed "CNS11643-*"
  XCOMM to "CNS11643.1986-*".
  XCOMM	1995-10-24	T. Numata (numa@rp.open.cs.fujitsu.co.jp)
--- 6,12 ----
  XCOMM CNS coded character sets 1-7 are registered as CNS 11643-1992.
  XCOMM CJK.INF Version 1.7 (August 15, 1995) written by Ken Lunde says
  XCOMM plane 14 of CNS 11643-1983 now became plane 3 of CNS 11643-1992.
! XCOMM I do not know how Taiwanese EUC is organized currently, so I left the
  XCOMM X11R6 organization of fsN/csN as it is and only changed "CNS11643-*"
  XCOMM to "CNS11643.1986-*".
  XCOMM	1995-10-24	T. Numata (numa@rp.open.cs.fujitsu.co.jp)
*** xc/nls/locale.alias@@/PUBLIC-LATEST	Wed Dec 25 23:58:05 1996
--- xc/nls/locale.alias	Fri Apr 18 08:02:50 1997
***************
*** 1,4 ****
! XCOMM	$XConsortium: locale.alias /main/21 1996/12/25 23:52:56 kaleb $
  XCOMM
  XCOMM	This file contains alias name of locale.
  XCOMM	Each alias name is described within one line.
--- 1,4 ----
! XCOMM	$TOG: locale.alias /main/22 1997/04/18 07:56:01 barstow $
  XCOMM
  XCOMM	This file contains alias name of locale.
  XCOMM	Each alias name is described within one line.
***************
*** 158,164 ****
  ko_KR			ko_KR.eucKR
  ko_KR.EUC		ko_KR.eucKR
  ko_KR.euc		ko_KR.eucKR
! XCOMM most locales in FreeBSD 2.1.[56] don't work, allow use of generic latin-1
  lt_LN.ISO_8859-1	lt_LN.ISO8859-1
  mk			mk_MK.ISO8859-5
  mk_MK			mk_MK.ISO8859-5
--- 158,164 ----
  ko_KR			ko_KR.eucKR
  ko_KR.EUC		ko_KR.eucKR
  ko_KR.euc		ko_KR.eucKR
! XCOMM most locales in FreeBSD 2.1.[56] do not work, allow use of generic latin-1
  lt_LN.ISO_8859-1	lt_LN.ISO8859-1
  mk			mk_MK.ISO8859-5
  mk_MK			mk_MK.ISO8859-5
*** xc/programs/Xserver/Imakefile@@/PUBLIC-LATEST	Fri Dec 27 16:23:24 1996
--- xc/programs/Xserver/Imakefile	Sun May 25 15:01:48 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/234 1996/12/27 16:16:06 kaleb $
  /*
   * Server Master Makefile
   */
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/235 1997/05/25 15:12:21 kaleb $
  /*
   * Server Master Makefile
   */
***************
*** 119,125 ****
           XAULIB = $(XAUTHSRC)/LibraryTargetName(Xau)
         XDMCPLIB = $(XDMCPLIBSRC)/LibraryTargetName(Xdmcp)
  #if BuildLBX || GzipFontCompression
!            ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
  #endif
               OS = os/LibraryTargetName(os) $(XAULIB) $(XDMCPLIB)
          BSDEMUL = $(DEPXBSDLIB)
--- 119,129 ----
           XAULIB = $(XAUTHSRC)/LibraryTargetName(Xau)
         XDMCPLIB = $(XDMCPLIBSRC)/LibraryTargetName(Xdmcp)
  #if BuildLBX || GzipFontCompression
! #if HasZlib
!        ZLIB = -lz
! #else
!        ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
! #endif
  #endif
               OS = os/LibraryTargetName(os) $(XAULIB) $(XDMCPLIB)
          BSDEMUL = $(DEPXBSDLIB)
*** xc/programs/Xserver/Xext/shape.c@@/PUBLIC-LATEST	Thu Aug  1 19:29:38 1996
--- xc/programs/Xserver/Xext/shape.c	Thu May 22 10:00:43 1997
***************
*** 25,31 ****
  
  ********************************************************/
  
! /* $XConsortium: shape.c /main/36 1996/08/01 19:23:05 dpw $ */
  #define NEED_REPLIES
  #define NEED_EVENTS
  #include <stdio.h>
--- 25,31 ----
  
  ********************************************************/
  
! /* $TOG: shape.c /main/37 1997/05/22 10:11:40 kaleb $ */
  #define NEED_REPLIES
  #define NEED_EVENTS
  #include <stdio.h>
***************
*** 132,142 ****
  	srcRgn = 0;
  	break;
      case ShapeUnion:
! 	if (*destRgnp)
  	    REGION_UNION(pScreen, *destRgnp, *destRgnp, srcRgn);
  	break;
      case ShapeIntersect:
! 	if (*destRgnp)
  	    REGION_INTERSECT(pScreen, *destRgnp, *destRgnp, srcRgn);
  	else {
  	    *destRgnp = srcRgn;
--- 132,142 ----
  	srcRgn = 0;
  	break;
      case ShapeUnion:
! 	if (*destRgnp && srcRgn)
  	    REGION_UNION(pScreen, *destRgnp, *destRgnp, srcRgn);
  	break;
      case ShapeIntersect:
! 	if (*destRgnp && srcRgn)
  	    REGION_INTERSECT(pScreen, *destRgnp, *destRgnp, srcRgn);
  	else {
  	    *destRgnp = srcRgn;
***************
*** 146,157 ****
      case ShapeSubtract:
  	if (!*destRgnp)
  	    *destRgnp = (*create)(pWin);
! 	REGION_SUBTRACT(pScreen, *destRgnp, *destRgnp, srcRgn);
  	break;
      case ShapeInvert:
  	if (!*destRgnp)
  	    *destRgnp = REGION_CREATE(pScreen, (BoxPtr) 0, 0);
! 	else
  	    REGION_SUBTRACT(pScreen, *destRgnp, srcRgn, *destRgnp);
  	break;
      default:
--- 146,158 ----
      case ShapeSubtract:
  	if (!*destRgnp)
  	    *destRgnp = (*create)(pWin);
! 	if (srcRgn)
! 	    REGION_SUBTRACT(pScreen, *destRgnp, *destRgnp, srcRgn);
  	break;
      case ShapeInvert:
  	if (!*destRgnp)
  	    *destRgnp = REGION_CREATE(pScreen, (BoxPtr) 0, 0);
! 	else if (srcRgn)
  	    REGION_SUBTRACT(pScreen, *destRgnp, srcRgn, *destRgnp);
  	break;
      default:
*** xc/programs/Xserver/Xi/exevents.c@@/PUBLIC-LATEST	Fri Dec  8 13:42:16 1995
--- xc/programs/Xserver/Xi/exevents.c	Mon Apr 14 08:36:52 1997
***************
*** 1,4 ****
! /* $XConsortium: exevents.c /main/51 1995/12/08 13:41:35 dpw $ */
  /************************************************************
  
  Copyright (c) 1989  X Consortium
--- 1,4 ----
! /* $TOG: exevents.c /main/52 1997/04/14 08:30:09 barstow $ */
  /************************************************************
  
  Copyright (c) 1989  X Consortium
***************
*** 147,153 ****
      if (DeviceEventCallback)
      {
  	DeviceEventInfoRec eventinfo;
! 	eventinfo.events = xE;
  	eventinfo.count = count;
  	CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
      }
--- 147,153 ----
      if (DeviceEventCallback)
      {
  	DeviceEventInfoRec eventinfo;
! 	eventinfo.events = (xEventPtr) xE;
  	eventinfo.count = count;
  	CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
      }
*** xc/programs/Xserver/Xi/extinit.c@@/PUBLIC-LATEST	Sun Apr 17 20:33:08 1994
--- xc/programs/Xserver/Xi/extinit.c	Thu May 15 16:17:40 1997
***************
*** 1,4 ****
! /* $XConsortium: extinit.c,v 1.18 94/04/17 20:33:08 rws Exp $ */
  
  /************************************************************
  
--- 1,4 ----
! /* $TOG: extinit.c /main/18 1997/05/15 16:15:30 barstow $ */
  
  /************************************************************
  
***************
*** 683,697 ****
      AllowPropagateSuppress (mask);
  
      mask = GetNextExtEventMask ();
-     DevicePointerMotionMask = mask;
-     SetMaskForExtEvent (mask, DeviceMotionNotify);
-     AllowPropagateSuppress (mask);
- 
-     DeviceFocusChangeMask = GetNextExtEventMask ();
-     SetMaskForExtEvent (DeviceFocusChangeMask, DeviceFocusIn);
-     SetMaskForExtEvent (DeviceFocusChangeMask, DeviceFocusOut);
- 
-     mask = GetNextExtEventMask ();
      SetMaskForExtEvent (mask, ProximityIn);
      SetMaskForExtEvent (mask, ProximityOut);
      AllowPropagateSuppress (mask);
--- 683,688 ----
***************
*** 701,713 ****
      SetMaskForExtEvent (mask, DeviceStateNotify);
  
      mask = GetNextExtEventMask ();
!     SetMaskForExtEvent (mask, DeviceMappingNotify);
!     DeviceMappingNotifyMask = mask;
  
-     mask = GetNextExtEventMask ();
-     SetMaskForExtEvent (mask, ChangeDeviceNotify);
-     ChangeDeviceNotifyMask = mask;
- 
      DevicePointerMotionHintMask = GetNextExtEventMask();
      SetEventInfo (DevicePointerMotionHintMask, _devicePointerMotionHint);
      SetEventInfo (GetNextExtEventMask(), _deviceButton1Motion);
--- 692,701 ----
      SetMaskForExtEvent (mask, DeviceStateNotify);
  
      mask = GetNextExtEventMask ();
!     DevicePointerMotionMask = mask;
!     SetMaskForExtEvent (mask, DeviceMotionNotify);
!     AllowPropagateSuppress (mask);
  
      DevicePointerMotionHintMask = GetNextExtEventMask();
      SetEventInfo (DevicePointerMotionHintMask, _devicePointerMotionHint);
      SetEventInfo (GetNextExtEventMask(), _deviceButton1Motion);
***************
*** 717,722 ****
--- 705,722 ----
      SetEventInfo (GetNextExtEventMask(), _deviceButton5Motion);
      DeviceButtonMotionMask = GetNextExtEventMask();
      SetEventInfo (DeviceButtonMotionMask, _deviceButtonMotion);
+ 
+     DeviceFocusChangeMask = GetNextExtEventMask ();
+     SetMaskForExtEvent (DeviceFocusChangeMask, DeviceFocusIn);
+     SetMaskForExtEvent (DeviceFocusChangeMask, DeviceFocusOut);
+ 
+     mask = GetNextExtEventMask ();
+     SetMaskForExtEvent (mask, DeviceMappingNotify);
+     DeviceMappingNotifyMask = mask;
+ 
+     mask = GetNextExtEventMask ();
+     SetMaskForExtEvent (mask, ChangeDeviceNotify);
+     ChangeDeviceNotifyMask = mask;
  
      DeviceButtonGrabMask = GetNextExtEventMask();
      SetEventInfo (DeviceButtonGrabMask, _deviceButtonGrab);
*** xc/programs/Xserver/Xi/gtmotion.c@@/PUBLIC-LATEST	Sun Apr 17 20:33:15 1994
--- xc/programs/Xserver/Xi/gtmotion.c	Fri Apr  4 09:14:42 1997
***************
*** 1,4 ****
! /* $XConsortium: gtmotion.c,v 1.15 94/04/17 20:33:15 rws Exp $ */ /*ALLOC-FIX*/
  
  /************************************************************
  
--- 1,4 ----
! /* $TOG: gtmotion.c /main/12 1997/04/04 09:10:45 barstow $ */ /*ALLOC-FIX*/
  
  /************************************************************
  
***************
*** 96,102 ****
  ProcXGetDeviceMotionEvents(client)
      ClientPtr client;
  {
!     INT32 *coords, *bufptr;
      xGetDeviceMotionEventsReply rep;
      int     i, j, num_events, axes, size, tsize;
      unsigned long nEvents;
--- 96,102 ----
  ProcXGetDeviceMotionEvents(client)
      ClientPtr client;
  {
!     INT32 *coords = NULL, *bufptr;
      xGetDeviceMotionEventsReply rep;
      int     i, j, num_events, axes, size, tsize;
      unsigned long nEvents;
***************
*** 149,154 ****
--- 149,160 ----
  	size = sizeof(Time) + (axes * sizeof (INT32));
  	tsize = num_events * size;
  	coords = (INT32 *) ALLOCATE_LOCAL(tsize);
+ 	if (!coords)
+ 	    {
+ 	    SendErrorToClient(client, IReqCode, X_GetDeviceMotionEvents, 0, 
+ 	        BadAlloc);
+ 	    return Success;
+ 	    }
  	rep.nEvents = (v->GetMotionProc) (
  		dev, (xTimecoord *)coords, /* XXX */
  		start.milliseconds, stop.milliseconds, (ScreenPtr)NULL);
***************
*** 174,181 ****
  		}
  	    }
  	WriteToClient(client, length * 4, (char *)coords);
- 	DEALLOCATE_LOCAL(coords);
          }
      return Success;
  }
  
--- 180,188 ----
  		}
  	    }
  	WriteToClient(client, length * 4, (char *)coords);
          }
+     if (coords)
+ 	DEALLOCATE_LOCAL(coords);
      return Success;
  }
  
*** xc/programs/Xserver/Xprint/Imakefile@@/PUBLIC-LATEST	Sat Nov 16 15:34:48 1996
--- xc/programs/Xserver/Xprint/Imakefile	Wed Jun 11 16:20:55 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/2 1996/11/16 15:23:16 rws $
  #include <Server.tmpl>
  
  #ifndef XpRasterDDX
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/3 1997/06/11 16:26:50 samborn $
  #include <Server.tmpl>
  
  #ifndef XpRasterDDX
***************
*** 49,55 ****
  PCLDIR = pcl
  PCLDEF = -DXPPCLDDX
  #endif
! #if XpMonPclDDX
  MPCLDIR = pcl-mono
  MPCLDEF = -DXPMONOPCLDDX
  #endif
--- 49,55 ----
  PCLDIR = pcl
  PCLDEF = -DXPPCLDDX
  #endif
! #if XpMonoPclDDX
  MPCLDIR = pcl-mono
  MPCLDEF = -DXPMONOPCLDDX
  #endif
*** xc/programs/Xserver/Xprint/Init.c@@/PUBLIC-LATEST	Mon Dec 30 15:00:56 1996
--- xc/programs/Xserver/Xprint/Init.c	Thu Jun 12 10:01:39 1997
***************
*** 1,4 ****
! /* $XConsortium: Init.c /main/4 1996/12/30 14:55:45 kaleb $ */
  /*
  (c) Copyright 1996 Hewlett-Packard Company
  (c) Copyright 1996 International Business Machines Corp.
--- 1,4 ----
! /* $TOG: Init.c /main/6 1997/06/12 09:59:34 samborn $ */
  /*
  (c) Copyright 1996 Hewlett-Packard Company
  (c) Copyright 1996 International Business Machines Corp.
***************
*** 312,318 ****
      {
  	"XP-PCL-MONO",
  	InitializeMonoPclDriver,
! 	PclValidatePoolsRec,
  	(pVFunc) NULL,
  	MonoPclPixmapFormats,
  	NUMMPCLFORMATS
--- 312,318 ----
      {
  	"XP-PCL-MONO",
  	InitializeMonoPclDriver,
! 	&PclValidatePoolsRec,
  	(pVFunc) NULL,
  	MonoPclPixmapFormats,
  	NUMMPCLFORMATS
***************
*** 650,655 ****
--- 650,661 ----
  	   strlen(pEntry->driverName) == 0 ||
  	   GetInitFunc(pEntry->driverName) == (Bool(*)())NULL)
  	{
+ 	    if (pEntry->driverName && (strlen(pEntry->driverName) != 0)) {
+ 	        ErrorF("Xp Extension: Can't load driver %s\n", 
+ 		       pEntry->driverName);
+ 	        ErrorF("              init function missing\n"); 
+ 	    }
+ 
  	    pEntry->driverName = defaultDriver;
  	    XpAddPrinterAttribute(pEntry->name,
  			          (pEntry->qualifier != (char *)NULL)?
***************
*** 1287,1292 ****
--- 1293,1324 ----
      PrinterDbPtr pDb, pDbEntry;
      int driverCount = 0, i;
      char **driverNames;
+     char *configDir;
+ 
+     /* 
+      * this little test is just a warning at startup to make sure
+      * that the config directory exists.
+      *
+      * what this ugly looking if says is that if both ways of
+      * calling configDir works and both directories don't exist, 
+      * then print an error saying we can't find the non-lang one.
+      */
+     if (((configDir = XpGetConfigDir(TRUE)) != NULL) && 
+ 	(access(configDir, F_OK) == 0))
+     {
+         xfree(configDir);
+     }
+     else if (((configDir = XpGetConfigDir(FALSE)) != NULL) &&
+ 	     (access(configDir, F_OK) == 0))
+     {
+         xfree(configDir);
+     }
+     else {
+ 	ErrorF("Xp Extension: could not find config dir %s\n",
+ 	       configDir ? configDir : XPRINTDIR);
+ 
+ 	if (configDir) xfree(configDir);
+     }
  
      if(printerDb != (PrinterDbPtr)NULL)
  	FreePrinterDb();
*** xc/programs/Xserver/Xprint/Xrm.c@@/PUBLIC-LATEST	Mon Dec 30 15:01:15 1996
--- xc/programs/Xserver/Xprint/Xrm.c	Sun Jun 22 07:16:30 1997
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xrm.c /main/2 1996/12/30 14:56:02 kaleb $
   */
  /*
  (c) Copyright 1996 Hewlett-Packard Company
--- 1,5 ----
  /*
!  * $TOG: Xrm.c /main/4 1997/06/22 07:14:18 kaleb $
   */
  /*
  (c) Copyright 1996 Hewlett-Packard Company
***************
*** 490,495 ****
--- 490,496 ----
      db = (XrmDatabase) xalloc(sizeof(XrmHashBucketRec));
      if (db) {
  	db->table = (NTable)NULL;
+ 	db->mbstate = (XPointer)NULL;
  #ifdef NOT_IN_SERVER
  	db->methods = _XrmInitParseInfo(&db->mbstate);
  #else
***************
*** 1063,1071 ****
   * Chris Peterson, MIT X Consortium		5/17/90.
   */
  
! #define LIST_SIZE 101
! #define BUFFER_SIZE 100
  
  static void GetIncludeFile();
  
  static void GetDatabase(db, str, filename, doall)
--- 1064,1082 ----
   * Chris Peterson, MIT X Consortium		5/17/90.
   */
  
! /* 
!  * Xlib spec says max 100 quarks in a lookup, will stop and return if
!  * return if any single production's lhs has more than 100 components.
!  */
! #define QLIST_SIZE 100
  
+ /* 
+  * This should be big enough to handle things like the XKeysymDB or biggish
+  * ~/.Xdefaults or app-defaults files. Anything bigger will be allocated on
+  * the heap.
+  */
+ #define DEF_BUFF_SIZE 8192
+ 
  static void GetIncludeFile();
  
  static void GetDatabase(db, str, filename, doall)
***************
*** 1074,1092 ****
      char *filename;
      Bool doall;
  {
      register char *ptr;
      register XrmBits bits = 0;
      register char c;
-     int len;
      register Signature sig;
      register char *ptr_max;
!     register XrmQuarkList t_quarks;
      register XrmBindingList t_bindings;
  
!     int alloc_chars = BUFSIZ;
!     char buffer[BUFSIZ], *value_str;
!     XrmQuark quarks[LIST_SIZE];
!     XrmBinding bindings[LIST_SIZE];
      XrmValue value;
      Bool only_pcs;
      Bool dolines;
--- 1085,1105 ----
      char *filename;
      Bool doall;
  {
+     char *rhs;
+     char *lhs, lhs_s[DEF_BUFF_SIZE];
+     XrmQuark quarks[QLIST_SIZE + 1];	/* allow for a terminal NullQuark */
+     XrmBinding bindings[QLIST_SIZE + 1];
+ 
      register char *ptr;
      register XrmBits bits = 0;
      register char c;
      register Signature sig;
      register char *ptr_max;
!     register int num_quarks;
      register XrmBindingList t_bindings;
  
!     int len, alloc_chars;
!     unsigned long str_len;
      XrmValue value;
      Bool only_pcs;
      Bool dolines;
***************
*** 1094,1102 ****
      if (!db)
  	return;
  
!     if (!(value_str = (char *)xalloc(sizeof(char) * alloc_chars)))
  	return;
  
      (*db->methods->mbinit)(db->mbstate);
      str--;
      dolines = True;
--- 1107,1139 ----
      if (!db)
  	return;
  
!      /*
!       * if strlen (str) < DEF_BUFF_SIZE allocate buffers on the stack for
!       * speed otherwise malloc the buffer. From a buffer overflow standpoint
!       * we can be sure that neither: a) a component on the lhs, or b) a
!       * value on the rhs, will be longer than the overall length of str,
!       * i.e. strlen(str).
!       *
!       * This should give good performance when parsing "*foo: bar" type
!       * databases as might be passed with -xrm command line options; but
!       * with larger databases, e.g. .Xdefaults, app-defaults, or KeysymDB
!       * files, the size of the buffers will be overly large. One way
!       * around this would be to double-parse each production with a resulting
!       * performance hit. In any event we can be assured that a lhs component
!       * name or a rhs value won't be longer than str itself.
!       */
! 
!     str_len = strlen (str);
!     if (DEF_BUFF_SIZE > str_len) lhs = lhs_s;
!     else if ((lhs = (char*) xalloc (str_len)) == NULL)
  	return;
  
+     alloc_chars = DEF_BUFF_SIZE < str_len ? str_len : DEF_BUFF_SIZE;
+     if ((rhs = (char*) xalloc (alloc_chars)) == NULL) {
+ 	if (lhs != lhs_s) Xfree (lhs);
+ 	return;
+     }
+ 
      (*db->methods->mbinit)(db->mbstate);
      str--;
      dolines = True;
***************
*** 1175,1193 ****
  	/*
  	 * Third: loop through the LHS of the resource specification
  	 * storing characters and converting this to a Quark.
- 	 *
- 	 * If the number of quarks is greater than LIST_SIZE - 1.  This
- 	 * function will trash your memory.
- 	 *
- 	 * If the length of any quark is larger than BUFSIZ this function
- 	 * will also trash memory.
  	 */
  	
  	t_bindings = bindings;
- 	t_quarks = quarks;
  
  	sig = 0;
! 	ptr = buffer;
  	*t_bindings = XrmBindTightly;	
  	for(;;) {
  	    if (!is_binding(bits)) {
--- 1212,1224 ----
  	/*
  	 * Third: loop through the LHS of the resource specification
  	 * storing characters and converting this to a Quark.
  	 */
  	
+ 	num_quarks = 0;
  	t_bindings = bindings;
  
  	sig = 0;
! 	ptr = lhs;
  	*t_bindings = XrmBindTightly;	
  	for(;;) {
  	    if (!is_binding(bits)) {
***************
*** 1197,1205 ****
  		    bits = next_char(c, str);
  		}
  
! 		*t_quarks++ = _XrmInternalStringToQuark(buffer, ptr - buffer,
! 							sig, False);
  
  		if (is_separator(bits))  {
  		    if (!is_space(bits))
  			break;
--- 1228,1243 ----
  		    bits = next_char(c, str);
  		}
  
! 		quarks[num_quarks++] = 
! 			_XrmInternalStringToQuark(lhs, ptr - lhs, sig, False);
  
+ 		if (num_quarks > QLIST_SIZE) {
+ 		    Xfree(rhs);
+ 		    if (lhs != lhs_s) Xfree (lhs);
+ 		    (*db->methods->mbfinish)(db->mbstate);
+ 		    return;
+ 		}
+ 
  		if (is_separator(bits))  {
  		    if (!is_space(bits))
  			break;
***************
*** 1217,1223 ****
  
  		    if (is_separator(bits))
  			break;
! 		    t_quarks--;
  		    continue;
  		}
  
--- 1255,1261 ----
  
  		    if (is_separator(bits))
  			break;
! 		    num_quarks--;
  		    continue;
  		}
  
***************
*** 1227,1233 ****
  		    *(++t_bindings) = XrmBindLoosely;
  
  		sig = 0;
! 		ptr = buffer;
  	    }
  	    else {
  		/*
--- 1265,1271 ----
  		    *(++t_bindings) = XrmBindLoosely;
  
  		sig = 0;
! 		ptr = lhs;
  	    }
  	    else {
  		/*
***************
*** 1247,1253 ****
  	    bits = next_char(c, str);
  	}
  
! 	*t_quarks = NULLQUARK;
  
  	/*
  	 * Make sure that there is a ':' in this line.
--- 1285,1291 ----
  	    bits = next_char(c, str);
  	}
  
! 	quarks[num_quarks] = NULLQUARK;
  
  	/*
  	 * Make sure that there is a ':' in this line.
***************
*** 1303,1309 ****
  	 * Fifth: Process the right hand side.
  	 */
  
! 	ptr = value_str;
  	ptr_max = ptr + alloc_chars - 4;
  	only_pcs = True;
  	len = 1;
--- 1341,1347 ----
  	 * Fifth: Process the right hand side.
  	 */
  
! 	ptr = rhs;
  	ptr_max = ptr + alloc_chars - 4;
  	only_pcs = True;
  	len = 1;
***************
*** 1427,1443 ****
  		char * temp_str;
  
  		alloc_chars += BUFSIZ/10;		
! 		temp_str = (char *)xrealloc(value_str, sizeof(char) * alloc_chars);
  
  		if (!temp_str) {
! 		    xfree(value_str);
  		    (*db->methods->mbfinish)(db->mbstate);
  		    return;
  		}
  
! 		ptr = temp_str + (ptr - value_str); /* reset pointer. */
! 		value_str = temp_str;
! 		ptr_max = value_str + alloc_chars - 4;
  	    }
  	}
  
--- 1465,1482 ----
  		char * temp_str;
  
  		alloc_chars += BUFSIZ/10;		
! 		temp_str = (char *)xrealloc(rhs, sizeof(char) * alloc_chars);
  
  		if (!temp_str) {
! 		    xfree(rhs);
! 		    if (lhs != lhs_s) xfree(lhs);
  		    (*db->methods->mbfinish)(db->mbstate);
  		    return;
  		}
  
! 		ptr = temp_str + (ptr - rhs); /* reset pointer. */
! 		rhs = temp_str;
! 		ptr_max = rhs + alloc_chars - 4;
  	    }
  	}
  
***************
*** 1449,1461 ****
  	*ptr++ = '\0';
  
  	/* Store it in database */
! 	value.size = ptr - value_str;
! 	value.addr = (XPointer) value_str;
  	
  	PutEntry(db, bindings, quarks, XrmQString, &value);
      }
  
!     xfree(value_str);
      (*db->methods->mbfinish)(db->mbstate);
  }
  
--- 1488,1501 ----
  	*ptr++ = '\0';
  
  	/* Store it in database */
! 	value.size = ptr - rhs;
! 	value.addr = (XPointer) rhs;
  	
  	PutEntry(db, bindings, quarks, XrmQString, &value);
      }
  
!     if (lhs != lhs_s) xfree (lhs);
!     xfree(rhs);
      (*db->methods->mbfinish)(db->mbstate);
  }
  
*** xc/programs/Xserver/Xprint/pcl/PclGC.c@@/PUBLIC-LATEST	Mon Dec 30 15:01:55 1996
--- xc/programs/Xserver/Xprint/pcl/PclGC.c	Wed Jun 11 17:55:50 1997
***************
*** 1,4 ****
! /* $XConsortium: PclGC.c /main/2 1996/12/30 14:56:42 kaleb $ */
  /*******************************************************************
  **
  **    *********************************************************
--- 1,4 ----
! /* $TOG: PclGC.c /main/3 1997/06/11 17:53:43 samborn $ */
  /*******************************************************************
  **
  **    *********************************************************
***************
*** 667,673 ****
  		sz = h * BitmapBytePad( w );
  
  		bits = (char *)xalloc( sz );
! 		mfbGetImage( pGC->tile, 0, 0, w, h, XYPixmap, ~0, bits );
  		PclSendPattern( bits, sz, 1, h, w, 100, *outFile );
  		xfree( bits );
  	    }
--- 667,673 ----
  		sz = h * BitmapBytePad( w );
  
  		bits = (char *)xalloc( sz );
! 		mfbGetImage(pGC->tile.pixmap, 0, 0, w, h, XYPixmap, ~0, bits);
  		PclSendPattern( bits, sz, 1, h, w, 100, *outFile );
  		xfree( bits );
  	    }
***************
*** 675,681 ****
  	    {
  		sz = h * PixmapBytePad( w, 8 );
  		bits = (char *)xalloc( sz );
! 		cfbGetImage( pGC->tile, 0, 0, w, h, ZPixmap, ~0, bits );
  		PclSendPattern( bits, sz, 8, h, w, 100, *outFile );
  		xfree( bits );
  	    }
--- 675,681 ----
  	    {
  		sz = h * PixmapBytePad( w, 8 );
  		bits = (char *)xalloc( sz );
! 		cfbGetImage(pGC->tile.pixmap, 0, 0, w, h, ZPixmap, ~0, bits);
  		PclSendPattern( bits, sz, 8, h, w, 100, *outFile );
  		xfree( bits );
  	    }
***************
*** 684,690 ****
  		sz = h * PixmapBytePad( w, 24 );
  		
  		bits = (char *)xalloc( sz );
! 		cfb32GetImage( pGC->tile, 0, 0, w, h, ZPixmap, ~0, bits );
  		PclSendPattern( bits, sz, 24, h, w, 100, *outFile );
  		xfree( bits );
  	    }
--- 684,690 ----
  		sz = h * PixmapBytePad( w, 24 );
  		
  		bits = (char *)xalloc( sz );
! 		cfb32GetImage(pGC->tile.pixmap, 0, 0, w, h, ZPixmap, ~0, bits);
  		PclSendPattern( bits, sz, 24, h, w, 100, *outFile );
  		xfree( bits );
  	    }
*** xc/programs/Xserver/cfb/cfb8line.c@@/PUBLIC-LATEST	Tue Jan  3 15:28:30 1995
--- xc/programs/Xserver/cfb/cfb8line.c	Fri Feb 28 18:15:06 1997
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfb8line.c,v 1.30 95/01/03 15:28:30 dpw Exp $
   *
  Copyright (c) 1990  X Consortium
  
--- 1,5 ----
  /*
!  * $TOG: cfb8line.c /main/32 1997/02/28 18:12:53 kaleb $
   *
  Copyright (c) 1990  X Consortium
  
***************
*** 305,312 ****
  	    _x2 = _x1 + _x2;
  	    _y2 = _y1 + _y2;
  
! 	    if (_x1 < extents_x1 || _x1 >= extents_x2 ||
! 		_y1 < extents_y1 || _y1 >= extents_y2)
  	    {
  		break;
  	    }
--- 305,312 ----
  	    _x2 = _x1 + _x2;
  	    _y2 = _y1 + _y2;
  
! 	    if (_x1 < extents_x1 || _x2 >= extents_x2 ||
! 		_y1 < extents_y1 || _y2 >= extents_y2)
  	    {
  		break;
  	    }
*** xc/programs/Xserver/dix/dixutils.c@@/PUBLIC-LATEST	Thu Nov  7 15:41:41 1996
--- xc/programs/Xserver/dix/dixutils.c	Thu May 22 09:51:20 1997
***************
*** 82,88 ****
  
  */
  
! /* $XConsortium: dixutils.c /main/32 1996/11/07 15:34:26 dpw $ */
  
  #include "X.h"
  #include "Xmd.h"
--- 82,88 ----
  
  */
  
! /* $TOG: dixutils.c /main/33 1997/05/22 10:02:20 kaleb $ */
  
  #include "X.h"
  #include "Xmd.h"
***************
*** 906,912 ****
      }
  
      listsToCleanup = (CallbackListPtr **)xnfrealloc(listsToCleanup,
! 		sizeof(CallbackListPtr *) * numCallbackListsToCleanup+1);
      listsToCleanup[numCallbackListsToCleanup] = pcbl;
      numCallbackListsToCleanup++;
      return TRUE;
--- 906,912 ----
      }
  
      listsToCleanup = (CallbackListPtr **)xnfrealloc(listsToCleanup,
! 		sizeof(CallbackListPtr *) * (numCallbackListsToCleanup+1));
      listsToCleanup[numCallbackListsToCleanup] = pcbl;
      numCallbackListsToCleanup++;
      return TRUE;
*** xc/programs/Xserver/hw/sun/sunIo.c@@/PUBLIC-LATEST	Thu Oct  5 07:36:52 1995
--- xc/programs/Xserver/hw/sun/sunIo.c	Tue May 20 11:39:03 1997
***************
*** 1,4 ****
! /* $XConsortium: sunIo.c /main/48 1995/10/05 07:36:52 kaleb $ */
  /*-
   * sunIo.c --
   *	Functions to handle input from the keyboard and mouse.
--- 1,4 ----
! /* $TOG: sunIo.c /main/49 1997/05/20 11:42:20 kaleb $ */
  /*-
   * sunIo.c --
   *	Functions to handle input from the keyboard and mouse.
***************
*** 199,220 ****
  {
      extern void UseMsg();
  
! #ifndef XKB
      if (strcmp (argv[i], "-ar1") == 0) {	/* -ar1 int */
  	if (++i >= argc) UseMsg ();
! 	sunAutoRepeatInitiate = 1000 * (long)atoi(argv[i]);
  	if (sunAutoRepeatInitiate > 1000000)
  	    sunAutoRepeatInitiate =  999000;
  	return 2;
      }
      if (strcmp (argv[i], "-ar2") == 0) {	/* -ar2 int */
  	if (++i >= argc) UseMsg ();
! 	sunAutoRepeatDelay = 1000 * (long)atoi(argv[i]);
  	if (sunAutoRepeatDelay > 1000000)
  	    sunAutoRepeatDelay =  999000;
  	return 2;
      }
- #endif
      if (strcmp (argv[i], "-swapLkeys") == 0) {	/* -swapLkeys */
  	sunSwapLkeys = TRUE;
  	return 1;
--- 199,233 ----
  {
      extern void UseMsg();
  
! #ifdef XKB
!     int noxkb = 0, n;
!     /* 
!      * peek in argv and see if -kb because noXkbExtension won't 
!      * get set until too late to useful here.
!      */
!     for (n = 1; n < argc; n++)
! 	if (strcmp (argv[n], "-kb") == 0)
! 	    noxkb = 1;
! 
!     if (noxkb)
! #endif
      if (strcmp (argv[i], "-ar1") == 0) {	/* -ar1 int */
  	if (++i >= argc) UseMsg ();
! 	sunAutoRepeatInitiate = 1000 * (long)atoi(argv[i]); /* cvt to usec */
  	if (sunAutoRepeatInitiate > 1000000)
  	    sunAutoRepeatInitiate =  999000;
  	return 2;
      }
+ #ifdef XKB
+     if (noxkb)
+ #endif
      if (strcmp (argv[i], "-ar2") == 0) {	/* -ar2 int */
  	if (++i >= argc) UseMsg ();
! 	sunAutoRepeatDelay = 1000 * (long)atoi(argv[i]); /* cvt to usec */
  	if (sunAutoRepeatDelay > 1000000)
  	    sunAutoRepeatDelay =  999000;
  	return 2;
      }
      if (strcmp (argv[i], "-swapLkeys") == 0) {	/* -swapLkeys */
  	sunSwapLkeys = TRUE;
  	return 1;
*** xc/programs/Xserver/hw/sun/sunKbd.c@@/PUBLIC-LATEST	Wed Sep 25 00:57:01 1996
--- xc/programs/Xserver/hw/sun/sunKbd.c	Wed Mar 26 16:43:46 1997
***************
*** 1,4 ****
! /* $XConsortium: sunKbd.c /main/76 1996/09/25 00:53:01 dpw $ */
  /*-
   * Copyright (c) 1987 by the Regents of the University of California
   *
--- 1,4 ----
! /* $TOG: sunKbd.c /main/77 1997/03/26 16:50:17 kaleb $ */
  /*-
   * Copyright (c) 1987 by the Regents of the University of California
   *
***************
*** 486,495 ****
  		(void) strcat (names->symbols, "sun/us(sun4)");
  	} else {
  	    (void) strcat (names->keycodes, "sun(type5)");
! 	    if (pKbd->layout == 34 || pKbd->layout == 81)
! 		(void) strcat (names->geometry, "sun(type5unix)");
! 	    else
  		(void) strcat (names->geometry, "sun(type5)");
  	    if (sunSwapLkeys)
  		(void) strcat (names->symbols, "sun/us(sun5ol)");
  	    else
--- 486,506 ----
  		(void) strcat (names->symbols, "sun/us(sun4)");
  	} else {
  	    (void) strcat (names->keycodes, "sun(type5)");
! 
! 	    switch (pKbd->layout) {
! 	    case 33: case 80: /* U.S. */
! 	    case 47: case 94: /* Korea */
! 	    case 48: case 95: /* Taiwan */
! 	    case 49: case 96: /* Japan */
  		(void) strcat (names->geometry, "sun(type5)");
+ 		break;
+ 	    case 34: case 81: /* U.S. Unix */
+ 		(void) strcat (names->geometry, "sun(type5unix)");
+ 		break;
+ 	    default:
+ 		(void) strcat (names->geometry, "sun(type5euro)");
+ 	    }
+ 
  	    if (sunSwapLkeys)
  		(void) strcat (names->symbols, "sun/us(sun5ol)");
  	    else
***************
*** 502,507 ****
--- 513,535 ----
      }
  
      /* extra symbols */
+ 
+     if (pKbd->type == KB_SUN4) {
+ 	switch (pKbd->layout) {
+ 	case  4: case 36: case 83: 
+ 	case  5: case 37: case 84: 
+ 	case  6: case 38: case 85: 
+ 	case  8: case 40: case 87: 
+ 	case  9: case 41: case 88: 
+ 	case 10: case 42: case 89: 
+ 	case 11: case 43: case 90: 
+ 	case 12: case 44: case 91: 
+ 	case 13: case 45: case 92: 
+ 	case 14: case 46: case 93: 
+ 	    (void) strcat (names->symbols, "+iso9995-3(basic)"); break;
+ 	}
+     }
+ 
      if (pKbd->type == KB_SUN4) {
  	switch (pKbd->layout) {
  	case  0: case  1: case 33: case 34: case 80: case 81: 
*** xc/programs/Xserver/hw/xfree86/XF86Setup/tcllib/tclIndex@@/PUBLIC-LATEST	Sat Sep 21 14:19:32 1996
--- xc/programs/Xserver/hw/xfree86/XF86Setup/tcllib/tclIndex	Thu Feb 13 13:52:17 1997
***************
*** 1,8 ****
- # $XConsortium: tclIndex /main/1 1996/09/21 14:15:32 kaleb $
- #
- #
- #
- #
  # Tcl autoload index file, version 2.0
  # This file is generated by the "auto_mkindex" command
  # and sourced to set up indexing information for one or
--- 1,3 ----
***************
*** 10,15 ****
--- 5,11 ----
  # sets an element in the auto_index array, where the
  # element name is the name of a command and the value is
  # a script that loads the command.
+ # $TOG: tclIndex /main/2 1997/02/13 13:55:50 kaleb $
  
  set auto_index(tkButtonEnter) "source $dir/button.tcl"
  set auto_index(tkButtonLeave) "source $dir/button.tcl"
*** xc/programs/Xserver/os/connection.c@@/PUBLIC-LATEST	Sun Dec 15 21:33:40 1996
--- xc/programs/Xserver/os/connection.c	Thu Jun  5 18:39:26 1997
***************
*** 1,4 ****
! /* $XConsortium: connection.c /main/155 1996/12/15 21:27:07 rws $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
--- 1,4 ----
! /* $TOG: connection.c /main/156 1997/06/05 18:43:01 sekhar $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
***************
*** 725,731 ****
  	{
  	    oc = (OsCommPtr)(client->osPrivate);
  	    if (oc && (oc->conn_time != 0) &&
! 		(connect_time - oc->conn_time) >= TimeOutValue)
  		CloseDownClient(client);     
  	}
      }
--- 725,732 ----
  	{
  	    oc = (OsCommPtr)(client->osPrivate);
  	    if (oc && (oc->conn_time != 0) &&
! 		(connect_time - oc->conn_time) >= TimeOutValue || 
! 		client->noClientException != Success && !client->clientGone)
  		CloseDownClient(client);     
  	}
      }
*** xc/programs/Xserver/os/utils.c@@/PUBLIC-LATEST	Mon Dec  2 10:26:22 1996
--- xc/programs/Xserver/os/utils.c	Sun Jun  1 13:47:17 1997
***************
*** 1,4 ****
! /* $XConsortium: utils.c /main/127 1996/12/02 10:23:20 lehors $ */
  /*
  
  Copyright (c) 1987  X Consortium
--- 1,4 ----
! /* $TOG: utils.c /main/128 1997/06/01 13:50:39 sekhar $ */
  /*
  
  Copyright (c) 1987  X Consortium
***************
*** 123,129 ****
  #endif
  
  #ifdef AIXV3
- #define AIXFILE "/tmp/aixfile"
  FILE *aixfd;
  int SyncOn  = 0;
  extern int SelectWaitTime;
--- 123,128 ----
***************
*** 1070,1080 ****
  #ifdef AIXV3
  OpenDebug()
  {
!         if((aixfd = fopen(AIXFILE,"w")) == NULL )
          {
!                 fprintf(stderr,"open aixfile failed\n");
                  exit(-1);
          }
!         chmod(AIXFILE,00777);
  }
  #endif
--- 1069,1090 ----
  #ifdef AIXV3
  OpenDebug()
  {
!     char aixlogfile[100];
!     struct stat aixfilebuf;
! 
!         sprintf(aixlogfile,"/tmp/xlogfile%d",getpid());
! 
!         /* if the logfile already exists & is a symlink, fopen() overwrites
!          * it without unlinking the file. It is necessary to unlink the
!          * logfile to avoid a security breach & possible exploitation.
!          */
!         if (stat((const char *)aixlogfile,&aixfilebuf) == 0)
!                 unlink(aixlogfile);
!         if((aixfd = fopen(aixlogfile,"w")) == NULL )
          {
!                 fprintf(stderr,"open %s failed\n",aixlogfile);
                  exit(-1);
          }
!         chmod(aixlogfile,00644);
  }
  #endif
*** xc/programs/Xserver/record/record.c@@/PUBLIC-LATEST	Wed Jan 24 15:15:00 1996
--- xc/programs/Xserver/record/record.c	Sun Apr  6 10:48:38 1997
***************
*** 1,4 ****
! /* $XConsortium: record.c /main/7 1996/01/24 15:18:10 dpw $ */
  
  /*
  
--- 1,4 ----
! /* $TOG: record.c /main/8 1997/04/06 10:52:30 kaleb $ */
  
  /*
  
***************
*** 1116,1121 ****
--- 1116,1123 ----
  	 * and call RemoveBlockAndWakeupHandlers here passing
  	 * RecordFlushAllContexts.  Is this any better?
  	 */
+ 	/* Having deleted the callback, call it one last time. -gildea */
+ 	RecordFlushAllContexts(&FlushCallback, NULL, NULL);
      }
  } /* RecordUninstallHooks */
  
*** xc/programs/Xserver/xkb/ddxBeep.c@@/PUBLIC-LATEST	Fri Feb  2 14:40:45 1996
--- xc/programs/Xserver/xkb/ddxBeep.c	Tue Jun 10 07:03:11 1997
***************
*** 1,4 ****
! /* $XConsortium: ddxBeep.c /main/4 1996/02/02 14:39:20 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: ddxBeep.c /main/5 1997/06/10 06:53:42 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 42,52 ****
  #include <alpha/prom.h>
  #endif
  
! #define FALLING_TONE	1
! #define RISING_TONE	1
  #define	SHORT_TONE	50
  #define	SHORT_DELAY	60
  #define	LONG_TONE	75
  #define	LONG_DELAY	85
  #define CLICK_DURATION	1
  
--- 42,55 ----
  #include <alpha/prom.h>
  #endif
  
! /*#define FALLING_TONE	1*/
! /*#define RISING_TONE	1*/
! #define FALLING_TONE	10
! #define RISING_TONE	10
  #define	SHORT_TONE	50
  #define	SHORT_DELAY	60
  #define	LONG_TONE	75
+ #define	VERY_LONG_TONE	100
  #define	LONG_DELAY	85
  #define CLICK_DURATION	1
  
***************
*** 209,230 ****
           */
  	case _BEEP_FEATURE_ON:
  	    if (name==None)	name= featureOn;
! 	    duration= RISING_TONE;
! 	    pitch = LOW_PITCH + (128 * xkbInfo->beepCount);
! 	    if (doesPitch && (pitch <= HIGH_PITCH))
! 		next = RISING_TONE;
  	    break;
  
  	case _BEEP_FEATURE_OFF:
! 	    if (name==None)	name= featureOn;
! 	    duration= FALLING_TONE;
! 	    pitch = HIGH_PITCH - (128 * xkbInfo->beepCount);
! 	    if (doesPitch) {
! 		if (pitch >= LOW_PITCH)
! 		    next = FALLING_TONE;	    
  	    }
! 	    else if (xkbInfo->beepCount<1)
! 		next = SHORT_DELAY;
  	    break;
  
  	/* Two high beeps indicate an LED or Feature changed
--- 212,242 ----
           */
  	case _BEEP_FEATURE_ON:
  	    if (name==None)	name= featureOn;
! 	    if (xkbInfo->beepCount<1) {
! 		pitch= LOW_PITCH;
! 		duration= VERY_LONG_TONE;
! 		if (doesPitch)
! 		    next= SHORT_DELAY;
! 	    }
! 	    else {
! 		pitch= MID_PITCH;
! 		duration= SHORT_TONE;
! 	    }
  	    break;
  
  	case _BEEP_FEATURE_OFF:
! 	    if (name==None)	name= featureOff;
! 	    if (xkbInfo->beepCount<1) {
! 		pitch= MID_PITCH;
! 		if (doesPitch)
! 		     duration= VERY_LONG_TONE;
! 		else duration= SHORT_TONE;
! 		next= SHORT_DELAY;
  	    }
! 	    else {
! 		pitch= LOW_PITCH;
! 		duration= SHORT_TONE;
! 	    }
  	    break;
  
  	/* Two high beeps indicate an LED or Feature changed
*** xc/programs/Xserver/xkb/ddxList.c@@/PUBLIC-LATEST	Mon Dec  2 10:26:48 1996
--- xc/programs/Xserver/xkb/ddxList.c	Tue Jun 10 07:03:14 1997
***************
*** 1,4 ****
! /* $XConsortium: ddxList.c /main/5 1996/12/02 10:23:46 lehors $ */
  /************************************************************
  Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: ddxList.c /main/6 1997/06/10 06:53:45 kaleb $ */
  /************************************************************
  Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 82,94 ****
  	return Success;
      }
      tmp= strchr(str,')');
!     if (tmp==NULL) {
! 	while ((*tmp!='\0')&&((*tmp=='_')||(*tmp=='-')||isalnum(*tmp))) {
! 	    tmp++;
  	}
- 	tmp--;
      }
!     slen= (tmp-str+1);
      wlen= (((slen+1)/2)*2)+4;	/* four bytes for flags and length, pad to */
  				/* 2-byte boundary */
      if ((list->szPool-list->nPool)<wlen) {
--- 82,96 ----
  	return Success;
      }
      tmp= strchr(str,')');
!     if ((tmp==NULL)&&((tmp=strchr(str,'('))==NULL)) {
! 	slen= strlen(str);
! 	while ((slen>0) && isspace(str[slen-1])) {
! 	    slen--;
  	}
      }
!     else {
! 	slen= (tmp-str+1);
!     }
      wlen= (((slen+1)/2)*2)+4;	/* four bytes for flags and length, pad to */
  				/* 2-byte boundary */
      if ((list->szPool-list->nPool)<wlen) {
*** xc/programs/Xserver/xkb/ddxLoad.c@@/PUBLIC-LATEST	Mon Dec  2 10:26:56 1996
--- xc/programs/Xserver/xkb/ddxLoad.c	Wed Jun 18 07:39:34 1997
***************
*** 1,4 ****
! /* $XConsortium: ddxLoad.c /main/20 1996/12/02 10:23:54 lehors $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: ddxLoad.c /main/21 1997/06/18 07:33:24 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 82,88 ****
      {
  #ifdef _PATH_VARTMP
  	(void) strcpy (outdir, _PATH_VARTMP);
! 	if (outdir[strlen(outdir)] != '/')
  	    (void) strcat (outdir, "/");
  #else
  	(void) strcpy (outdir, "/tmp/");
--- 82,88 ----
      {
  #ifdef _PATH_VARTMP
  	(void) strcpy (outdir, _PATH_VARTMP);
! 	if (outdir[strlen(outdir) - 1] != '/')	/* Hi IBM, Digital */
  	    (void) strcat (outdir, "/");
  #else
  	(void) strcpy (outdir, "/tmp/");
***************
*** 124,132 ****
      else outFile= _XkbDupString(file);
      XkbEnsureSafeMapName(outFile);
      OutputDirectory(xkm_output_dir);
- /*  (void) strcpy (xkm_output_dir, XKM_OUTPUT_DIR); */
-     if (xkm_output_dir[strlen(xkm_output_dir)] != '/') /* hi IBM, Digital */
- 	(void) strcat (xkm_output_dir, "/");
      if (XkbBaseDirectory!=NULL) {
  	if (strlen(XkbBaseDirectory)*2+(xkbDebugFlags>9?2:1)
  		+(map?strlen(map)+3:0)+strlen(PRE_ERROR_MSG)
--- 124,129 ----
*** xc/programs/Xserver/xkb/xkb.c@@/PUBLIC-LATEST	Sat Aug 31 12:48:03 1996
--- xc/programs/Xserver/xkb/xkb.c	Tue Jun 10 07:03:17 1997
***************
*** 1,4 ****
! /* $XConsortium: xkb.c /main/21 1996/08/31 12:44:16 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkb.c /main/22 1997/06/10 06:53:48 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 5795,5816 ****
      if (stuff->load)
  	 fwant= XkbGBN_AllComponentsMask;
      else fwant= stuff->want|stuff->need;
!     if ((!names.compat)&&
      		(fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
! 	names.compat= _XkbDupString("%");
      }
!     if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
! 	names.types= _XkbDupString("%");
      }
-     if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask))
- 	names.symbols= _XkbDupString("%");
  
-     geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
-     if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
- 	names.geometry= _XkbDupString("%");
- 	geom_changed= False;
-     }
- 
      bzero(mapFile,PATH_MAX);
      rep.type= X_Reply;
      rep.deviceID = dev->id;
--- 5795,5821 ----
      if (stuff->load)
  	 fwant= XkbGBN_AllComponentsMask;
      else fwant= stuff->want|stuff->need;
!     if (!names.keymap) {
! 	if ((!names.compat)&&
      		(fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
! 	    names.compat= _XkbDupString("%");
! 	}
! 	if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
! 	    names.types= _XkbDupString("%");
! 	}
! 	if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask)) {
! 	    names.symbols= _XkbDupString("%");
! 	}
! 	geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
! 	if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
! 	    names.geometry= _XkbDupString("%");
! 	    geom_changed= False;
! 	}
      }
!     else {
! 	geom_changed= True;
      }
  
      bzero(mapFile,PATH_MAX);
      rep.type= X_Reply;
      rep.deviceID = dev->id;
***************
*** 5843,5854 ****
  	    rep.loaded= True;
  	if (stuff->load || 
  		((rep.reported&XkbGBN_SymbolsMask) && (finfo.xkb->compat))) {
! 	    register int first,num,key;
! 	    first= finfo.xkb->min_key_code;
! 	    num= XkbNumKeys(finfo.xkb);
! 	    for (key=first;key<(first+num);key++) {
! 		XkbApplyCompatMapToKey(finfo.xkb,key,NULL);
! 	    }
  	}
  
  	if (finfo.xkb->map==NULL)
--- 5848,5858 ----
  	    rep.loaded= True;
  	if (stuff->load || 
  		((rep.reported&XkbGBN_SymbolsMask) && (finfo.xkb->compat))) {
! 	    XkbChangesRec changes;
! 	    bzero(&changes,sizeof(changes));
! 	    XkbUpdateDescActions(finfo.xkb,
! 			finfo.xkb->min_key_code,XkbNumKeys(finfo.xkb),
! 			&changes);
  	}
  
  	if (finfo.xkb->map==NULL)
***************
*** 6008,6013 ****
--- 6012,6018 ----
      if (rep.loaded) {
  	XkbDescPtr		old_xkb;
  	xkbNewKeyboardNotify 	nkn;
+ 	int 			i,nG,nTG;
  	old_xkb= xkb;
  	xkb= finfo.xkb;
  	dev->key->xkbInfo->desc= xkb;
***************
*** 6018,6023 ****
--- 6023,6039 ----
  	    dev->kbdfeed->xkb_sli= NULL;
  	}
  	*xkb->ctrls= *old_xkb->ctrls;
+ 	for (nG=nTG=0,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
+ 	    nG= XkbKeyNumGroups(xkb,i);
+ 	    if (nG>=XkbNumKbdGroups) {
+ 		nTG= XkbNumKbdGroups;
+ 		break;
+ 	    }
+ 	    if (nG>nTG) {
+ 		nTG= nG;
+ 	    }
+ 	}
+ 	xkb->ctrls->num_groups= nTG;
  
  	memcpy(dev->key->modifierMap,xkb->map->modmap,xkb->max_key_code+1);
  	XkbUpdateCoreDescription(dev,True);
*** xc/programs/Xserver/xkb/xkbInit.c@@/PUBLIC-LATEST	Sat Sep 28 17:24:39 1996
--- xc/programs/Xserver/xkb/xkbInit.c	Tue May 20 11:34:13 1997
***************
*** 1,7 ****
  /*
!  * @(#)$RCSfile: xkbInit.c $ $Revision: /main/23 $ (DEC) $Date: 1996/09/28 17:16:19 $
   */
! /* $XConsortium: xkbInit.c /main/23 1996/09/28 17:16:19 rws $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
--- 1,7 ----
  /*
!  * @(#)$RCSfile: xkbInit.c $ $Revision: /main/24 $ (DEC) $Date: 1997/05/20 11:42:06 $
   */
! /* $TOG: xkbInit.c /main/24 1997/05/20 11:42:06 kaleb $ */
  /************************************************************
  Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 971,986 ****
      }
      if (strcmp (argv[i], "-ar1") == 0) {	/* -ar1 int */
  	if (++i >= argc) UseMsg ();
! 	XkbDfltRepeatDelay = 1000 * (long)atoi(argv[i]);
! 	if (XkbDfltRepeatDelay > 1000000)
! 	    XkbDfltRepeatDelay =  999000;
  	return 2;
      }
      if (strcmp (argv[i], "-ar2") == 0) {	/* -ar2 int */
  	if (++i >= argc) UseMsg ();
! 	XkbDfltRepeatInterval = 1000 * (long)atoi(argv[i]);
! 	if (XkbDfltRepeatInterval > 1000000)
! 	    XkbDfltRepeatInterval =  999000;
  	return 2;
      }
      return 0;
--- 971,982 ----
      }
      if (strcmp (argv[i], "-ar1") == 0) {	/* -ar1 int */
  	if (++i >= argc) UseMsg ();
! 	XkbDfltRepeatDelay = (long)atoi(argv[i]);
  	return 2;
      }
      if (strcmp (argv[i], "-ar2") == 0) {	/* -ar2 int */
  	if (++i >= argc) UseMsg ();
! 	XkbDfltRepeatInterval = (long)atoi(argv[i]);
  	return 2;
      }
      return 0;
*** xc/programs/bdftopcf/Imakefile@@/PUBLIC-LATEST	Fri Nov 22 09:27:31 1996
--- xc/programs/bdftopcf/Imakefile	Sun May 25 15:00:41 1997
***************
*** 1,6 ****
! XCOMM $XConsortium: Imakefile /main/9 1996/11/22 09:23:17 kaleb $
  #if GzipFontCompression
! ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
  #endif
  LOCAL_LIBRARIES = $(FONTLIB) $(ZLIB)
  DEPLIBS = $(DEPFONTLIB)
--- 1,10 ----
! XCOMM $TOG: Imakefile /main/10 1997/05/25 15:12:03 kaleb $
  #if GzipFontCompression
! #if HasZlib
!        ZLIB = -lz
! #else
!        ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
! #endif
  #endif
  LOCAL_LIBRARIES = $(FONTLIB) $(ZLIB)
  DEPLIBS = $(DEPFONTLIB)
*** xc/programs/lbxproxy/Imakefile@@/PUBLIC-LATEST	Fri Dec  6 09:34:37 1996
--- xc/programs/lbxproxy/Imakefile	Sun May 25 15:01:45 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/15 1996/12/06 09:34:35 swick $
  
  #include <Server.tmpl>
  #define       IHaveSubdirs
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/16 1997/05/25 15:12:17 kaleb $
  
  #include <Server.tmpl>
  #define       IHaveSubdirs
***************
*** 5,12 ****
  
  LBXPROXYCONFIGDIR = LbxproxyConfigSubdir
  
  SUBDIRS = di os $(LBXPROXYCONFIGDIR)
! LBXLIBS = di/LibraryTargetName(dilbx) os/LibraryTargetName(os) $(TOP)/lib/lbxutil/LibraryTargetName(lbxutil) $(TOP)/lib/zlib/LibraryTargetName(z)
  OTHERLIBS = $(ICELIB) $(XLIB)
  
  ServerTarget(lbxproxy,$(SUBDIRS),NullParameter,$(LBXLIBS),$(OTHERLIBS))
--- 5,18 ----
  
  LBXPROXYCONFIGDIR = LbxproxyConfigSubdir
  
+ #if HasZlib
+        ZLIB = -lz
+ #else
+        ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
+ #endif
+ 
  SUBDIRS = di os $(LBXPROXYCONFIGDIR)
! LBXLIBS = di/LibraryTargetName(dilbx) os/LibraryTargetName(os) $(TOP)/lib/lbxutil/LibraryTargetName(lbxutil) $(ZLIB)
  OTHERLIBS = $(ICELIB) $(XLIB)
  
  ServerTarget(lbxproxy,$(SUBDIRS),NullParameter,$(LBXLIBS),$(OTHERLIBS))
*** xc/programs/lbxproxy/di/utils.c@@/PUBLIC-LATEST	Sun Dec 15 21:35:32 1996
--- xc/programs/lbxproxy/di/utils.c	Mon Jun 23 21:39:28 1997
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c /main/37 1996/12/15 21:28:59 rws $ */
  
  #include "lbx.h"
  #include <stdio.h>
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $TOG: utils.c /main/39 1997/06/23 21:37:31 kaleb $ */
  
  #include "lbx.h"
  #include <stdio.h>
***************
*** 244,250 ****
  
  int lbxMaxMotionEvents = NUM_MOTION_EVENTS;	/* max # motion events */
  
! int zlevel = 9;		/* best compression */
  
  AtomControlPtr atom_control = NULL;
  int atom_control_count = 0;
--- 244,258 ----
  
  int lbxMaxMotionEvents = NUM_MOTION_EVENTS;	/* max # motion events */
  
! /* 
!  * zlevel = 1..9, 9 == max compression. 6 == good tradeoff between 
!  * compression and speed. Try gzipping a large file at the default
!  * level (which is 6) and at max compression (9) and notice the
!  * difference in time it takes to compress the file and the difference 
!  * in file size. level 9 compression takes ~50 more (time, cpu) but 
!  * only yields a very small improvement in compression.
!  */
! int zlevel = 6;		
  
  AtomControlPtr atom_control = NULL;
  int atom_control_count = 0;
*** xc/programs/mkfontdir/Imakefile@@/PUBLIC-LATEST	Sun Nov  3 19:36:56 1996
--- xc/programs/mkfontdir/Imakefile	Sun May 25 15:01:36 1997
***************
*** 1,9 ****
! XCOMM $XConsortium: Imakefile /main/10 1996/11/03 19:32:28 kaleb $
  LOCAL_LIBRARIES = $(FONTLIB)
  DEPLIBS = $(DEPFONTLIB)
  INCLUDES = -I$(FONTINCSRC) -I$(FONTLIBSRC)/include
  #if GzipFontCompression
! ZLIB = -lz
  #endif
  SYS_LIBRARIES = MathLibrary $(ZLIB)
  SRCS = mkfontdir.c
--- 1,13 ----
! XCOMM $TOG: Imakefile /main/11 1997/05/25 15:12:09 kaleb $
  LOCAL_LIBRARIES = $(FONTLIB)
  DEPLIBS = $(DEPFONTLIB)
  INCLUDES = -I$(FONTINCSRC) -I$(FONTLIBSRC)/include
  #if GzipFontCompression
! #if HasZlib
!        ZLIB = -lz
! #else
!        ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
! #endif
  #endif
  SYS_LIBRARIES = MathLibrary $(ZLIB)
  SRCS = mkfontdir.c
*** xc/programs/twm/gram.y@@/PUBLIC-LATEST	Sun Apr 17 20:38:11 1994
--- xc/programs/twm/gram.y	Tue May 27 11:44:46 1997
***************
*** 53,59 ****
  
  /***********************************************************************
   *
!  * $XConsortium: gram.y,v 1.93 94/04/17 20:38:11 dave Exp $
   *
   * .twmrc command grammer
   *
--- 53,59 ----
  
  /***********************************************************************
   *
!  * $TOG: gram.y /main/66 1997/05/27 11:55:53 kaleb $
   *
   * .twmrc command grammer
   *
***************
*** 119,124 ****
--- 119,127 ----
  %token <ptr> STRING 
  
  %type <ptr> string
+ %type <num> pixmap_list cursor_list color_list save_color_list stmt
+ %type <num> win_color_list iconm_list win_list icon_list function menu
+ %type <num> noarg sarg error narg squeeze
  %type <num> action button number signed_number full fullkey
  
  %start twmrc 
***************
*** 231,241 ****
  		  icon_list
  		| COLOR 		{ color = COLOR; }
  		  color_list
!   		| GRAYSCALE 		{ color = GRAYSCALE; }
    		  color_list
!                 | SAVECOLOR          
                    save_color_list
!                 | MONOCHROME 		{ color = MONOCHROME; }
  	          color_list
  		| DEFAULT_FUNCTION action { Scr->DefaultFunction.func = $2;
  					  if ($2 == F_MENU)
--- 234,244 ----
  		  icon_list
  		| COLOR 		{ color = COLOR; }
  		  color_list
! 		| GRAYSCALE 		{ color = GRAYSCALE; }
    		  color_list
! 		| SAVECOLOR          
                    save_color_list
! 		| MONOCHROME 		{ color = MONOCHROME; }
  	          color_list
  		| DEFAULT_FUNCTION action { Scr->DefaultFunction.func = $2;
  					  if ($2 == F_MENU)
*** xc/programs/x11perf/x11pcomp.cpp@@/PUBLIC-LATEST	Thu Aug 22 11:43:57 1991
--- xc/programs/x11perf/x11pcomp.cpp	Mon Apr 14 09:22:30 1997
***************
*** 16,22 ****
  XCOMM Mark Moraes, University of Toronto <moraes@csri.toronto.edu>
  XCOMM Joel McCormack, DEC Western Research Lab <joel@decwrl.dec.com>
  XCOMM
! XCOMM $XConsortium: x11pcomp.cpp,v 1.6 91/08/22 11:43:57 rws Exp $
  
  PATH=LIBPATH:.:$PATH
  export PATH
--- 16,22 ----
  XCOMM Mark Moraes, University of Toronto <moraes@csri.toronto.edu>
  XCOMM Joel McCormack, DEC Western Research Lab <joel@decwrl.dec.com>
  XCOMM
! XCOMM $TOG: x11pcomp.cpp /main/7 1997/04/14 09:15:45 barstow $
  
  PATH=LIBPATH:.:$PATH
  export PATH
***************
*** 48,54 ****
  		awk '$2 == "reps" || $2 == "trep" { print $0; next; }' $file |
   		sed 's/^.*: //' |
   		sed 's/ /_/g' |
!  		awk 'NR > 1 	{ printf ("%s %s\n", prev, $0); }
  				{ prev = $0; }'
  	done | tsort 2>/dev/null | sed 's/_/ /g' > $tmp/labels
  	;;
--- 48,54 ----
  		awk '$2 == "reps" || $2 == "trep" { print $0; next; }' $file |
   		sed 's/^.*: //' |
   		sed 's/ /_/g' |
!  		awk 'NR > 1 	{ printf ("%s %s\n", prev, $0); } \
  				{ prev = $0; }'
  	done | tsort 2>/dev/null | sed 's/_/ /g' > $tmp/labels
  	;;
***************
*** 62,82 ****
  	base=`basename $i`
  	(echo "     $n  "
  	 echo '--------'
! 	 awk '$2 == "reps" || $2 == "trep" {
! 		line = $0;
! 		next;
! 	    }
! 	    NF == 0 && line != "" {
! 		print line;
! 		line="";
! 		next;
! 	    }
  	 ' $i > $tmp/$n.avg
  	 fillblnk $tmp/$n.avg $tmp/labels |
  	 sed 's/( *\([0-9]*\)/(\1/'   |
! 	 awk '$2 == "reps" || $2 == "trep" {
! 	 					n = substr($6,2,length($6)-7);
! 						printf "%8s\n", n;
      	 				   }'
  	) > $tmp/rates/$n
  	echo "$n: $i"
--- 62,82 ----
  	base=`basename $i`
  	(echo "     $n  "
  	 echo '--------'
! 	 awk '$2 == "reps" || $2 == "trep" { \
! 		line = $0; \
! 		next; \
! 	    } \
! 	    NF == 0 && line != "" { \
! 		print line; \
! 		line=""; \
! 		next; \
! 	    } \
  	 ' $i > $tmp/$n.avg
  	 fillblnk $tmp/$n.avg $tmp/labels |
  	 sed 's/( *\([0-9]*\)/(\1/'   |
! 	 awk '$2 == "reps" || $2 == "trep" { \
! 	 					n = substr($6,2,length($6)-7); \
! 						printf "%8s\n", n; \
      	 				   }'
  	) > $tmp/rates/$n
  	echo "$n: $i"
*** xc/programs/xdm/xdmcp.c@@/PUBLIC-LATEST	Mon Sep 19 20:16:38 1994
--- xc/programs/xdm/xdmcp.c	Thu Feb 27 11:02:00 1997
***************
*** 1,4 ****
! /* $XConsortium: xdmcp.c,v 1.15 94/09/19 20:16:38 converse Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
--- 1,4 ----
! /* $TOG: xdmcp.c /main/16 1997/02/27 11:05:56 kaleb $ */
  /*
  
  Copyright (c) 1988  X Consortium
***************
*** 855,862 ****
      int			expectlen;
      struct protoDisplay	*pdpy;
      struct display	*d;
!     char		*name;
!     char		*class;
      XdmcpNetaddr	from_save;
      ARRAY8		clientAddress, clientPort;
      CARD16		connectionType;
--- 855,862 ----
      int			expectlen;
      struct protoDisplay	*pdpy;
      struct display	*d;
!     char		*name = NULL;
!     char		*class = NULL;
      XdmcpNetaddr	from_save;
      ARRAY8		clientAddress, clientPort;
      CARD16		connectionType;
***************
*** 930,936 ****
  		class[displayClass.length] = '\0';
  	    }
  	    else
! 		class = (char *) 0;
  	    from_save = (XdmcpNetaddr) malloc (fromlen);
  	    if (!from_save)
  	    {
--- 930,939 ----
  		class[displayClass.length] = '\0';
  	    }
  	    else
! 	    {
! 		free ((char *) class);
! 		class = (char *) NULL;
! 	    }
  	    from_save = (XdmcpNetaddr) malloc (fromlen);
  	    if (!from_save)
  	    {
***************
*** 988,993 ****
--- 991,998 ----
      }
  abort:
      XdmcpDisposeARRAY8 (&displayClass);
+     if (name) free ((char*) name);
+     if (class) free ((char*) class);
  }
  
  SendFailed (d, reason)
*** xc/programs/xfs/Imakefile@@/PUBLIC-LATEST	Sun Nov  3 19:37:39 1996
--- xc/programs/xfs/Imakefile	Sun May 25 15:01:41 1997
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile /main/28 1996/11/03 19:33:19 kaleb $
  #undef ServerDefines
  #include <Server.tmpl>
  #define	IHaveSubdirs
--- 1,4 ----
! XCOMM $TOG: Imakefile /main/29 1997/05/25 15:12:14 kaleb $
  #undef ServerDefines
  #include <Server.tmpl>
  #define	IHaveSubdirs
***************
*** 9,15 ****
  DIFSLIB = $(DIFSDIR)/libdifs.a
  SYSLIBS = MathLibrary
  #if GzipFontCompression
! ZLIB = -lz
  #endif
  #ifdef i386SVR3Architecture
  BSDEMUL = $(DEPXBSDLIB)
--- 9,19 ----
  DIFSLIB = $(DIFSDIR)/libdifs.a
  SYSLIBS = MathLibrary
  #if GzipFontCompression
! #if HasZlib
!        ZLIB = -lz
! #else
!        ZLIB = $(TOP)/exports/lib/LibraryTargetName(z)
! #endif
  #endif
  #ifdef i386SVR3Architecture
  BSDEMUL = $(DEPXBSDLIB)
*** xc/programs/xfs/README@@/PUBLIC-LATEST	Mon May 13 11:34:32 1991
--- xc/programs/xfs/README	Mon Jun  9 17:00:03 1997
***************
*** 1,3 ****
--- 1,4 ----
+ /* $TOG: README /main/4 1997/06/09 16:57:45 barstow $ */
  Installation instructions for fontserver
  
  1 - set DefaultFSConfigFile to point to the correct place, if the default
***************
*** 9,15 ****
  	parameter points to a set of valid font directories.
  
  At this point the test programs should work.  Start the font server
! 	(fs &) and try some tests.  Most of the clients take
  	a command line switch of where to find the server, and
  	FSlib understands the environment variable FONTSERVER.
  	The format is the same as Xlib, (ie, hostname:server_number).
--- 10,16 ----
  	parameter points to a set of valid font directories.
  
  At this point the test programs should work.  Start the font server
! 	(xfs &) and try some tests.  Most of the clients take
  	a command line switch of where to find the server, and
  	FSlib understands the environment variable FONTSERVER.
  	The format is the same as Xlib, (ie, hostname:server_number).
*** xc/programs/xfs/difs/charinfo.c@@/PUBLIC-LATEST	Sun Apr 17 19:56:12 1994
--- xc/programs/xfs/difs/charinfo.c	Tue Jun  3 20:01:19 1997
***************
*** 1,4 ****
! /* $XConsortium: charinfo.c,v 1.15 94/04/17 19:56:12 gildea Exp $ */
  /*
   
  Copyright (c) 1990, 1991  X Consortium
--- 1,4 ----
! /* $TOG: charinfo.c /main/16 1997/06/03 19:59:02 barstow $ */
  /*
   
  Copyright (c) 1990, 1991  X Consortium
***************
*** 362,373 ****
  	    inkc = *inkChars++;
      	l->position = size;
  	/*
! 	 * Repad even characters with no bits (bitc->bits == NULL).
! 	 * When X server requests all characters to be repadded to
! 	 * charcell size (because it thinks the font is TE) it assumes
! 	 * the FS will do it.
! 	 */
!     	if (bitc) {
  	    if (!gdata)
  		gdata = (pointer) bitc->bits;
  	    if ((char *) gdata + size != bitc->bits)
--- 362,371 ----
  	    inkc = *inkChars++;
      	l->position = size;
  	/*
!          * Do not repad characters with no bits except for those
!          * with non-zero width.
!          */
!         if (bitc && (bitc->bits || bitc->metrics.characterWidth)) {
  	    if (!gdata)
  		gdata = (pointer) bitc->bits;
  	    if ((char *) gdata + size != bitc->bits)
*** xc/programs/xfs/difs/dispatch.c@@/PUBLIC-LATEST	Sun Apr 17 19:56:13 1994
--- xc/programs/xfs/difs/dispatch.c	Thu May 29 15:16:12 1997
***************
*** 1,4 ****
! /* $XConsortium: dispatch.c,v 1.24 94/04/17 19:56:13 gildea Exp $ */
  /*
   * protocol dispatcher
   */
--- 1,4 ----
! /* $TOG: dispatch.c /main/25 1997/05/29 15:13:56 barstow $ */
  /*
   * protocol dispatcher
   */
***************
*** 388,412 ****
      case FSBadAccessContext:
      case FSBadIDChoice:
      case FSBadEventMask:
! 	if (client->swapped)
! 	    SwapLongs((long *) data, 1);
! 	extralen = 4;
  	break;
      case FSBadRange:
  	extralen = SIZEOF(fsRange);
  	break;
      case FSBadResolution:
! 	if (client->swapped)
! 	    SwapShorts((short *) data, 1);
! 	/* note sneaky hack */
! 	rep.pad = *(CARD16 *) data;
! 	data += 2;
! 	extralen = 4;
  	break;
      case FSBadLength:
! 	if (client->swapped)
! 	    SwapLongs((long *) data, 1);
! 	extralen = 4;
  	break;
      default:
  	/* nothing else to send */
--- 388,418 ----
      case FSBadAccessContext:
      case FSBadIDChoice:
      case FSBadEventMask:
! 	if (data) {
! 	    if (client->swapped)
! 	        SwapLongs((long *) data, 1);
! 	    extralen = 4;
! 	}
  	break;
      case FSBadRange:
  	extralen = SIZEOF(fsRange);
  	break;
      case FSBadResolution:
! 	if (data) {
! 	    if (client->swapped)
! 	        SwapShorts((short *) data, 1);
! 	    /* note sneaky hack */
! 	    rep.pad = *(CARD16 *) data;
! 	    data += 2;
! 	    extralen = 4;
! 	}
  	break;
      case FSBadLength:
! 	if (data) {
! 	    if (client->swapped)
! 	        SwapLongs((long *) data, 1);
! 	    extralen = 4;
! 	}
  	break;
      default:
  	/* nothing else to send */
*** xc/programs/xfs/difs/events.c@@/PUBLIC-LATEST	Sun Apr 17 19:56:14 1994
--- xc/programs/xfs/difs/events.c	Wed May 28 12:35:37 1997
***************
*** 1,4 ****
! /* $XConsortium: events.c,v 1.5 94/04/17 19:56:14 gildea Exp $ */
  /*
   * event handling stuff
   */
--- 1,4 ----
! /* $TOG: events.c /main/6 1997/05/28 12:33:20 barstow $ */
  /*
   * event handling stuff
   */
***************
*** 124,132 ****
  #endif
  
      if (client->swapped) {
! 	fsKeepAliveEvent evTo;
! 
! 	SErrorEvent((fsError *) & ev, (fsError *) & evTo);
  	(void) WriteToClient(client, SIZEOF(fsKeepAliveEvent), (char *) &evTo);
      } else {
  	(void) WriteToClient(client, SIZEOF(fsKeepAliveEvent), (char *) &ev);
--- 124,133 ----
  #endif
  
      if (client->swapped) {
! 	/* SErrorEvent requires two fsError pointers */
! 	fsError evTo;
! 	
! 	SErrorEvent((fsError *) & ev, (fsError *) &evTo);
  	(void) WriteToClient(client, SIZEOF(fsKeepAliveEvent), (char *) &evTo);
      } else {
  	(void) WriteToClient(client, SIZEOF(fsKeepAliveEvent), (char *) &ev);
*** xc/programs/xfs/include/osstruct.h@@/PUBLIC-LATEST	Sun Apr 17 19:56:00 1994
--- xc/programs/xfs/include/osstruct.h	Fri Jun  6 13:38:59 1997
***************
*** 1,4 ****
! /* $XConsortium: osstruct.h,v 1.4 94/04/17 19:56:00 dpw Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
--- 1,4 ----
! /* $TOG: osstruct.h /main/5 1997/06/06 13:36:42 barstow $ */
  /*
  Copyright (c) 1987  X Consortium
  
***************
*** 55,61 ****
  
  typedef struct _alt_server {
      char        subset;
!     char        namelen;
      char       *name;
  }           AlternateServerRec;
  
--- 55,61 ----
  
  typedef struct _alt_server {
      char        subset;
!     short       namelen;
      char       *name;
  }           AlternateServerRec;
  
*** xc/programs/xfs/os/connection.c@@/PUBLIC-LATEST	Wed Apr  5 19:58:18 1995
--- xc/programs/xfs/os/connection.c	Fri Jun  6 11:37:21 1997
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.32 95/04/05 19:58:18 kaleb Exp $ */
  /*
   * handles connections
   */
--- 1,4 ----
! /* $TOG: connection.c /main/34 1997/06/06 11:35:03 barstow $ */
  /*
   * handles connections
   */
***************
*** 316,322 ****
  	if ((client = clients[i]) != NullClient) {
  	    oc = (OsCommPtr) client->osPrivate;
  	    if (oc && (oc->conn_time != 0) &&
! 		    (connect_time - oc->conn_time) >= TimeOutValue)
  		CloseDownClient(client);
  	}
      }
--- 316,324 ----
  	if ((client = clients[i]) != NullClient) {
  	    oc = (OsCommPtr) client->osPrivate;
  	    if (oc && (oc->conn_time != 0) &&
! 		    (connect_time - oc->conn_time) >= TimeOutValue ||
! 		    client->noClientException != FSSuccess &&
! 		    client->clientGone != CLIENT_GONE)
  		CloseDownClient(client);
  	}
      }
***************
*** 429,436 ****
  		(void) _FontTransWrite(trans_conn,
  		(char *) pad, ((4 - (altlen & 3)) & 3));
  	}
- 	if (num_alts)
- 	    fsfree((char *) altservers);
      }
  }
  
--- 431,436 ----
*** xc/programs/xfs/os/io.c@@/PUBLIC-LATEST	Wed Apr  5 19:58:20 1995
--- xc/programs/xfs/os/io.c	Wed May 28 14:11:40 1997
***************
*** 1,4 ****
! /* $XConsortium: io.c,v 1.17 95/04/05 19:58:20 kaleb Exp $ */
  /*
   * i/o functions
   */
--- 1,4 ----
! /* $TOG: io.c /main/18 1997/05/28 14:09:25 barstow $ */
  /*
   * i/o functions
   */
***************
*** 416,422 ****
  	InsertIOV(padBuffer, padsize);
  
  	errno = 0;
! 	if ((len = _FontTransWritev(oc->trans_conn, iov, i)) >= 0) {
  	    written += len;
  	    notWritten -= len;
  	    todo = notWritten;
--- 416,422 ----
  	InsertIOV(padBuffer, padsize);
  
  	errno = 0;
! 	if (oc->trans_conn && (len = _FontTransWritev(oc->trans_conn, iov, i)) >= 0) {
  	    written += len;
  	    notWritten -= len;
  	    todo = notWritten;
***************
*** 475,481 ****
  #endif
  	else
  	{
! 	    _FontTransClose(oc->trans_conn);
  	    oc->trans_conn = NULL;
  	    MarkClientException(client);
  	    oco->count = 0;
--- 475,482 ----
  #endif
  	else
  	{
! 	    if (oc->trans_conn)
! 	        _FontTransClose(oc->trans_conn);
  	    oc->trans_conn = NULL;
  	    MarkClientException(client);
  	    oco->count = 0;
*** xc/programs/xfs/os/osglue.c@@/PUBLIC-LATEST	Fri Apr  7 19:42:57 1995
--- xc/programs/xfs/os/osglue.c	Thu May 22 09:54:20 1997
***************
*** 1,4 ****
! /* $XConsortium: osglue.c,v 1.12 95/04/07 19:42:57 kaleb Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
--- 1,4 ----
! /* $TOG: osglue.c /main/13 1997/05/22 10:04:48 barstow $ */
  /*
  Copyright (c) 1987  X Consortium
  
***************
*** 294,299 ****
--- 294,301 ----
      char	*arg_ptr = old_listen_arg;
      int         i, j;
      int         lastfdesc;
+     char	portnum[20];
+     extern int	ListenPort;
  
      assert(!drone_server);	/* a drone shouldn't hit this */
  
***************
*** 366,375 ****
--- 368,379 ----
  	    }
  	}
  
+ 	sprintf (portnum, "%d", ListenPort);
  	if (*old_listen_arg != '\0')
  	    execlp(progname, progname,
  		   "-ls", old_listen_arg,
  		   "-cf", configfilename,
+ 		   "-port", portnum,
  		   NULL);
  
  	InitErrors();		/* reopen errors, since we don't want to lose
*** xc/programs/xfs/xfs.man@@/PUBLIC-LATEST	Mon Dec  9 17:16:07 1996
--- xc/programs/xfs/xfs.man	Mon Jun  9 18:00:26 1997
***************
*** 35,41 ****
  .\" no representations about the
  .\" suitability of this software for any purpose.  It is provided "as is"
  .\" without express or implied warranty.
! .\" $XConsortium: xfs.man /main/13 1996/12/09 17:08:59 kaleb $
  .TH XFS 1 "Release 6.3" "X Version 11"
  .SH NAME
  xfs \- X font server
--- 35,41 ----
  .\" no representations about the
  .\" suitability of this software for any purpose.  It is provided "as is"
  .\" without express or implied warranty.
! .\" $TOG: xfs.man /main/14 1997/06/09 17:58:07 barstow $
  .TH XFS 1 "Release 6.3" "X Version 11"
  .SH NAME
  xfs \- X font server
***************
*** 65,70 ****
--- 65,71 ----
  .TP 8
  .B \-port tcp_port
  Specifies the TCP port number on which the server will listen for connections.
+ The default port number is 7100.
  .SH "SIGNALS"
  .TP 8
  .I SIGTERM
*** xc/programs/xkbcomp/alias.c@@/PUBLIC-LATEST	Fri Dec 27 21:21:17 1996
--- xc/programs/xkbcomp/alias.c	Tue Jun 10 07:03:24 1997
***************
*** 1,4 ****
! /* $XConsortium: alias.c /main/7 1996/12/27 21:16:10 kaleb $ */
  /************************************************************
   Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: alias.c /main/8 1997/06/10 06:53:55 kaleb $ */
  /************************************************************
   Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 214,220 ****
  	unsigned int kc;
  
  	lname= KeyNameToLong(info->real);
! 	if (!FindNamedKey(xkb,lname,&kc,False,CreateKeyNames(xkb))) {
  	    if (warningLevel>4) {
  		WARN2("Attempt to alias %s to non-existent key %s\n",
  					XkbKeyNameText(info->alias,XkbMessage),
--- 214,220 ----
  	unsigned int kc;
  
  	lname= KeyNameToLong(info->real);
! 	if (!FindNamedKey(xkb,lname,&kc,False,CreateKeyNames(xkb),0)) {
  	    if (warningLevel>4) {
  		WARN2("Attempt to alias %s to non-existent key %s\n",
  					XkbKeyNameText(info->alias,XkbMessage),
***************
*** 225,231 ****
  	    continue;
  	}
  	lname= KeyNameToLong(info->alias);
! 	if (FindNamedKey(xkb,lname,&kc,False,False)) {
  	    if (warningLevel>4) {
  		WARN("Attempt to create alias with the name of a real key\n");
  		ACTION2("Alias \"%s = %s\" ignored\n",
--- 225,231 ----
  	    continue;
  	}
  	lname= KeyNameToLong(info->alias);
! 	if (FindNamedKey(xkb,lname,&kc,False,False,0)) {
  	    if (warningLevel>4) {
  		WARN("Attempt to create alias with the name of a real key\n");
  		ACTION2("Alias \"%s = %s\" ignored\n",
*** xc/programs/xkbcomp/compat/Imakefile@@/PUBLIC-LATEST	Tue Sep  3 19:49:17 1996
--- xc/programs/xkbcomp/compat/Imakefile	Sat Jun 14 06:40:12 1997
***************
*** 1,7 ****
! XCOMM $XConsortium: Imakefile /main/2 1996/09/03 19:45:40 kaleb $
  
!      DATAFILES = accessx basic complete default iso9995 japan misc \
! 		 mousekeys norepeat pc xtest
  
  all::
  
--- 1,7 ----
! XCOMM $TOG: Imakefile /main/4 1997/06/14 06:35:53 kaleb $
  
!      DATAFILES = accessx basic complete default iso9995 japan keypad \
! 		 misc mousekeys norepeat pc xtest
  
  all::
  
*** xc/programs/xkbcomp/geometry/sgi/Imakefile@@/PUBLIC-LATEST	Fri Feb  2 14:20:34 1996
--- xc/programs/xkbcomp/geometry/sgi/Imakefile	Tue Jun 10 07:04:03 1997
***************
*** 1,6 ****
! XCOMM $XConsortium: Imakefile /main/1 1996/02/02 14:19:09 kaleb $
  
!      DATAFILES = indy indigo
  
  all::
  
--- 1,6 ----
! XCOMM $TOG: Imakefile /main/2 1997/06/10 06:54:34 kaleb $
  
!      DATAFILES = indy indigo O2
  
  all::
  
*** xc/programs/xkbcomp/geometry/sgi/indy@@/PUBLIC-LATEST	Sat Aug 31 12:20:35 1996
--- xc/programs/xkbcomp/geometry/sgi/indy	Tue Jun 10 07:04:09 1997
***************
*** 1,4 ****
! // $XConsortium: indy /main/2 1996/08/31 12:16:48 kaleb $
  //
  // Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
  //
--- 1,4 ----
! // $TOG: indy /main/3 1997/06/10 06:54:40 kaleb $
  //
  // Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
  //
***************
*** 213,218 ****
--- 213,219 ----
      alias <AC00> = <CAPS>;
      alias <AA00> = <LCTL>;
  };
+ 
  xkb_geometry "pc102" {
  
      // This is an approximate layout for 102-key SGI international
***************
*** 409,411 ****
--- 410,599 ----
      alias <AC00> = <CAPS>;
      alias <AA00> = <LCTL>;
  };
+ 
+ xkb_geometry "jp106" {
+     description= "Silicon Graphics 106-key Japanese keyboard";
+     width= 442;
+     height= 167;
+ 
+     shape "EDGE" { cornerRadius= 2, { [ 442, 167 ] } };
+     shape.cornerRadius= 1;
+     shape "NORM" { { [ 18,18] }, { [2,1], [ 16,17] } };
+     shape "BKSP" { { [ 18,18] }, { [2,1], [ 16,17] } };
+     shape "TABK" { { [ 28,18] }, { [2,1], [ 26,17] } };
+     shape "BKSL" { { [ 27,18] }, { [2,1], [ 25,17] } };
+     shape "RTRN" {
+         { [0,0],[ 27,0],[27,37],[4,37],[4,18],[0,18] } ,
+         { [2,1],[ 25,1],[25,36],[5,36],[5,17],[2,17] } };
+     shape "CAPS" { { [ 32,18] }, { [2,1], [ 30,17] } };
+     shape "LFSH" { { [ 42,18] }, { [2,1], [ 40,17] } };
+     shape "RTSH" { { [ 32,18] }, { [2,1], [ 30,17] } };
+     shape "MODK" { { [ 28,18] }, { [2,1], [ 26,17] } };
+     shape "SPCE" { { [ 46,18] }, { [2,1], [ 44,17] } };
+     shape "KP0"  { { [ 37,18] }, { [2,1], [ 35,17] } };
+     shape "KPAD" { { [ 18,37] }, { [2,1], [ 16,36] } };
+     shape "LOGO" { { [ 16,16] } };
+ 
+     outline "Edges" {
+ 	top= 0;
+ 	left= 0;
+ 	shape= "EDGE";
+     };
+ 
+     logo "SGILogoImage" { 
+ 	top= 5;
+ 	left= 6;
+ 	name= "SGI"; 
+ 	shape= "LOGO"; 
+     };
+ 
+     text "SGILogoText"	{
+ 	top= 9;
+ 	left= 25;
+ 	width= 50;
+ 	text= "SiliconGraphics";
+ 	font= "helvetica";
+ 	slant= "o";
+ 	weight= "bold";
+ 	fontWidth= "narrow";
+ 	fontSize= 24;
+     };
+ 
+     shape "LEDS" { cornerRadius= 0.1, { [ 76 ,20 ] } };
+     shape "LED"  { cornerRadius= 0, { [  5,  1 ] } };
+     solid "LedPanel" {
+ 	shape= "LEDS";
+ 	top=  25;
+ 	left= 362;
+ 	color= "grey10";
+     };
+ 
+     indicator.onColor= "green";
+     indicator.offColor= "green30";
+     indicator.top= 40;
+     indicator.shape= "LED";
+     indicator "NumLock"     { left= 366; };
+     indicator "CapsLock"    { left= 391; };
+     indicator "ScrollLock"  { left= 416; };
+     text.top= 28;
+     text.color= "black";
+     text "NumLockLabel"		{ left= 366; text="Num\nLock"; };
+     text "CapsLockLabel"	{ left= 391; text="Caps\nLock"; };
+     text "ScrollLockLabel"	{ left= 416; text="Scroll\nLock"; };
+ 
+     section.left= 5;
+     row.left= 1;
+     key.shape= "NORM";
+     key.gap=  1;
+     section "Function" {
+ 	top= 25;
+ 	row {
+ 	    top= 1;
+ 	    keys {  { <ESC>, color="grey20" },
+ 		    { <FK01>, 18 }, <FK02>, <FK03>, <FK04>,
+ 		    { <FK05>, 11 ,color="grey20"}, {<FK06>,color="grey20"}, 
+ 		    { <FK07>, color="grey20"}, {<FK08>,color="grey20"},
+ 		    { <FK09>, 11 }, <FK10>, <FK11>, <FK12>,
+ 		    { <PRSC>, 8 }, <SCLK>, <PAUS> 
+ 	    };
+ 	};
+     }; // End of "Function" section
+ 
+     section "Alpha" {
+ 	top= 61;
+ 	row {
+ 	    top= 1;
+ 	    keys { {<HZTG>,color="grey20"}, <AE01>, <AE02>, 
+                     <AE03>, <AE04>, <AE05>, <AE06>, <AE07>, 
+ 	            <AE08>, <AE09>, <AE10>, <AE11>, <AE12>,
+ 		    <AE13>, { <BKSP>, "BKSP", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { { <TAB>, "TABK", color="grey20" },
+ 		   <AD01>, <AD02>, <AD03>, <AD04>, <AD05>, 
+ 		   <AD06>, <AD07>, <AD08>, <AD09>, <AD10>, 
+ 		   <AD11>, <AD12>, { <RTRN>, 1 ,"RTRN",color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { { <CAPS>, "CAPS", color="grey20" },
+ 		   <AC01>, <AC02>, <AC03>, <AC04>, <AC05>, 
+ 		   <AC06>, <AC07>, <AC08>, <AC09>, <AC10>, 
+ 		   <AC11>, <AC12>
+ 	    };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { { <LFSH>, "LFSH", color="grey20" },
+ 		    <AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
+ 		    <AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
+ 		    <AB11>, { <RTSH>, "RTSH", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    key.shape= "MODK";
+ 	    key.color= "grey20";
+ 	    keys { <LCTL>, { <LALT>, 20 },<NFER>,
+ 		   { <SPCE>, "SPCE", color="white" },
+ 		   <XFER>,<HKTG>,<RALT>, { <RCTL>, 17 }
+ 	    };
+ 	};
+     }; // End of "Alpha" section
+ 
+     section "Editing" {
+ 	top= 61;
+ 	left= 296;
+ 	key.color= "grey20";
+ 	row {
+ 	    top= 1;
+ 	    keys { <INS>, <HOME>, <PGUP> };
+ 	};
+         row {
+ 	    top= 20;
+ 	    keys { <DELE>, <END>, <PGDN> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    left= 20;
+ 	    keys { <UP> };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { <LEFT>, <DOWN>, <RGHT> };
+ 	};
+     }; // End of "Editing" section
+ 
+     section "Keypad" {
+ 	top= 61;
+ 	left= 361;
+ 	row {
+ 	    top= 1;
+ 	    key.color= "grey20";
+ 	    keys { <NMLK>, <KPDV>, <KPMU>, <KPSU> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <KP7>, <KP8>, <KP9>, { <KPAD>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <KP4>, <KP5>, <KP6> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <KP1>, <KP2>, <KP3>, { <KPEN>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { { <KP0>, "KP0" }, <KPDL> };
+ 	};
+     }; // End of "Keypad" section
+ 
+     alias <AC00> = <CAPS>;
+     alias <AA00> = <LCTL>;
+ 
+ }; // End of "jp106" geometry
*** xc/programs/xkbcomp/geometry/sun@@/PUBLIC-LATEST	Wed Jan 24 12:20:03 1996
--- xc/programs/xkbcomp/geometry/sun	Wed Mar 26 16:46:56 1997
***************
*** 1,4 ****
! // $XConsortium: sun /main/6 1996/01/24 12:18:45 kaleb $
  //
  //Copyright (c) 1996  X Consortium
  //
--- 1,4 ----
! // $TOG: sun /main/7 1997/03/26 16:50:29 kaleb $
  //
  //Copyright (c) 1996  X Consortium
  //
***************
*** 241,246 ****
--- 241,394 ----
  	row {
  	    top= 58;
  	    keys { <OPEN>, <PAST>, { <LFSH>, 9 , shape="LFSH" }, 
+ 		   <AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
+ 		   <AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
+ 		 { <RTSH>, "RTSH", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { <FIND>, <CUT>, { <LCTL>, 9, shape="LCTL" },
+ 		   <LALT>, <LMTA>,
+ 		 { <SPCE>, "SPCE" },
+ 		   <RMTA>, <COMP>, <ALGR>
+ 	    };
+ 	};
+     }; // End of "Alpha" section
+ 
+     section "Editing" {
+ 	top= 61;
+ 	left= 352;
+ 	row {
+ 	    top= 1;
+ 	    keys { <INS>, <HOME>, <PGUP> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <DELE>, <END>, <PGDN> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    left= 20;
+ 	    keys { <UP> };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { <LEFT>, <DOWN>, <RGHT> };
+ 	};
+     }; // End of "Editing" section
+ 
+     section "Keypad" {
+ 	top= 61;
+ 	left= 420;
+ 	row {
+ 	    top= 1;
+ 	    keys { <NMLK>, <KPDV>, <KPMU>, <KPSU> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <KP7>, <KP8>, <KP9>, { <KPAD>, "KPAD", color= "grey20" } };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <KP4>, <KP5>, <KP6> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <KP1>, <KP2>, <KP3>, { <KPEN>, "KPAD", color= "grey20" } };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { { <KP0>, "KP0" }, <KPDL> };
+ 	};
+     }; // End of "Keypad" section
+ };
+ 
+ xkb_geometry "type5euro" {
+ 
+     // This is an approximate layout for a (US/ASCII) Sun Type5
+     // keyboard.  I just took a similar layout (101 key PC keyboard)
+     // and adjusted the sizes.
+ 
+     description= "Sun Type5 keyboard";
+ 
+     width= 515;
+     height= 170;
+ 
+     shape "EDGE" { cornerRadius= 2, { [ 515, 170 ] } };
+     shape.cornerRadius= 1;
+     shape "NORM" { { [ 18,18] }, { [2,1], [16,17] } };
+     shape "BKSP" { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "TABK" { { [ 27,18] }, { [2,1], [25,17] } };
+     shape "BKSL" { { [ 27,18] }, { [2,1], [25,17] } };
+     shape "RTRN" { { [ 42,18] }, { [2,1], [40,17] } };
+     shape "CAPS" { { [ 32,18] }, { [2,1], [30,17] } };
+     shape "LFSH" { { [ 24,18] }, { [2,1], [22,17] } };
+     shape "RTSH" { { [ 51,18] }, { [2,1], [49,17] } };
+     shape "LCTL" { { [ 32,18] }, { [2,1], [30,17] } };
+     shape "MODK" { { [ 28,18] }, { [2,1], [26,17] } };
+     shape "SPCE" { { [157,18] }, { [2,1], [155,17] } };
+     shape "KP0"  { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "KPAD" { { [ 18,37] }, { [2,1], [16,36] } };
+     shape "HELP" { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "LOGO" { { [ 16,16] } };
+ 
+     outline "Edges" {
+ 	top= 0;
+ 	left= 0;
+ 	shape= "EDGE";
+     };
+ 
+     section.left= 14;
+     row.left= 1;
+     key.shape= "NORM";
+     key.gap=  1;
+     section "Function" {
+ 	top= 24;
+ 	row {
+ 	    top= 1;
+ 	    keys { { <HELP>, "HELP" }, { <ESC>, 9 },
+ 		   { <FK01>, 19 }, <FK02>, <FK03>, <FK04>,
+ 		   { <FK05>, 11 }, <FK06>, <FK07>, <FK08>,
+ 		   { <FK09>, 11 }, <FK10>, <FK11>, <FK12>,
+ 		   { <PRSC>,  9 }, <SCLK>, <PAUS>,
+ 		   { <MUTE>,  9 }, <VOL->, <VOL+>, <POWR>
+ 	    };
+ 	};
+     }; // End of "Function" section
+ 
+     section "Alpha" {
+ 	top= 61;
+ 	row {
+ 	    top= 1;
+ 	    keys { <STOP>, <AGAI>,
+ 		 { <TLDE>, 9}, <AE01>, <AE02>, <AE03>, <AE04>,
+ 		   <AE05>, <AE06>, <AE07>, <AE08>, <AE09>,
+ 		   <AE10>, <AE11>, <AE12>,
+ 		 { <BKSP>, "BKSP", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <PROP>, <UNDO>, { <TAB>, 9, shape="TABK" },
+ 		   <AD01>, <AD02>, <AD03>, <AD04>, <AD05>, 
+ 		   <AD06>, <AD07>, <AD08>, <AD09>, <AD10>, 
+ 		   <AD11>, <AD12>,
+ 		 { <BKSL>, "BKSL" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <FRNT>, <COPY>, { <CAPS>, 9, shape="CAPS" },
+ 		   <AC01>, <AC02>, <AC03>, <AC04>, <AC05>, 
+ 		   <AC06>, <AC07>, <AC08>, <AC09>, <AC10>, 
+ 		   <AC11>,
+ 		 { <RTRN>, "RTRN" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <OPEN>, <PAST>, { <LFSH>, 9 , shape="LFSH" }, <LSGT>, 
  		   <AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
  		   <AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
  		 { <RTSH>, "RTSH", color="grey20" }
*** xc/programs/xkbcomp/keycodes.c@@/PUBLIC-LATEST	Fri Dec 27 21:22:03 1996
--- xc/programs/xkbcomp/keycodes.c	Fri Jun 13 06:03:04 1997
***************
*** 1,4 ****
! /* $XConsortium: keycodes.c /main/11 1996/12/27 21:16:54 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: keycodes.c /main/13 1997/06/13 05:59:12 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 87,92 ****
--- 87,93 ----
      int			effectiveMax;
      unsigned long	names[XkbMaxLegalKeyCode+1];
      unsigned 		files[XkbMaxLegalKeyCode+1];
+     unsigned char	has_alt_forms[XkbMaxLegalKeyCode+1];
      IndicatorNameInfo *	leds;
      AliasInfo *		aliases;
  } KeyNamesInfo;
***************
*** 300,305 ****
--- 301,307 ----
      info->effectiveMax= 255;
      bzero((char *)info->names,sizeof(info->names));
      bzero((char *)info->files,sizeof(info->files));
+     bzero((char *)info->has_alt_forms,sizeof(info->has_alt_forms));
      if (info->leds)
  	ClearIndicatorNameInfo(info->leds,info);
      if (info->aliases)
***************
*** 359,365 ****
      Bool		reportCollisions;
  #endif
  {
! int		old,override;
  unsigned long	lval;
  
      if ((kc<info->effectiveMin)||(kc>info->effectiveMax)) {
--- 361,367 ----
      Bool		reportCollisions;
  #endif
  {
! int		old;
  unsigned long	lval;
  
      if ((kc<info->effectiveMin)||(kc>info->effectiveMax)) {
***************
*** 383,389 ****
  	LongToKeyName(info->names[kc],buf);
  	buf[4]= '\0';
  	if (info->names[kc]==lval) {
! 	    if (reportCollisions) {
  		WARN("Multiple identical key name definitions\n");
  		ACTION2("Later occurences of \"<%s> = %d\" ignored\n",buf,kc);
  	    }
--- 385,394 ----
  	LongToKeyName(info->names[kc],buf);
  	buf[4]= '\0';
  	if (info->names[kc]==lval) {
! 	    if (info->has_alt_forms[kc] || (merge==MergeAltForm)) {
! 		info->has_alt_forms[kc]= True;
! 	    }
! 	    else if (reportCollisions) {
  		WARN("Multiple identical key name definitions\n");
  		ACTION2("Later occurences of \"<%s> = %d\" ignored\n",buf,kc);
  	    }
***************
*** 406,432 ****
  	    info->files[kc]= 0;
  	}
      }
-     override= (merge==MergeOverride);
      old= FindKeyByLong(info,lval);
      if ((old!=0)&&(old!=kc)) {
! 	if (override) {
  	    info->names[old]= 0;
  	    info->files[old]= 0;
  	    if (reportCollisions) {
  		WARN1("Key name <%s> assigned to multiple keys\n",name);
  		ACTION2("Using %d, ignoring %d\n",kc,old);
  	    }
  	}
! 	else {
! 	    if (reportCollisions) {
  		WARN1("Key name <%s> assigned to multiple keys\n",name);
  		ACTION2("Using %d, ignoring %d\n",old,kc);
  	    }
  	    return True;
  	}
      }
      info->names[kc]= lval;
      info->files[kc]= fileID;
      return True;
  }
  
--- 411,442 ----
  	    info->files[kc]= 0;
  	}
      }
      old= FindKeyByLong(info,lval);
      if ((old!=0)&&(old!=kc)) {
! 	if (merge==MergeOverride) {
  	    info->names[old]= 0;
  	    info->files[old]= 0;
+ 	    info->has_alt_forms[old]= True;
  	    if (reportCollisions) {
  		WARN1("Key name <%s> assigned to multiple keys\n",name);
  		ACTION2("Using %d, ignoring %d\n",kc,old);
  	    }
  	}
! 	else if (merge!=MergeAltForm) {
! 	    if ((reportCollisions)&&(warningLevel>3)) {
  		WARN1("Key name <%s> assigned to multiple keys\n",name);
  		ACTION2("Using %d, ignoring %d\n",old,kc);
+ 		ACTION("Use 'alternate' keyword to assign the same name to multiple keys\n");
  	    }
  	    return True;
  	}
+ 	else {
+ 	    info->has_alt_forms[old]= True;
+ 	}
      }
      info->names[kc]= lval;
      info->files[kc]= fileID;
+     info->has_alt_forms[kc]= (merge==MergeAltForm);
      return True;
  }
  
***************
*** 454,464 ****
  	from->name= NULL;
      }
      for (i=from->computedMin;i<=from->computedMax;i++) {
  	if (from->names[i]==0)
  	    continue;
  	LongToKeyName(from->names[i],buf);
  	buf[4]= '\0';
! 	if (!AddKeyName(into,i,buf,merge,from->fileID,False))
  	    into->errorCount++;
      }
      if (from->leds) {
--- 464,478 ----
  	from->name= NULL;
      }
      for (i=from->computedMin;i<=from->computedMax;i++) {
+ 	unsigned thisMerge;
  	if (from->names[i]==0)
  	    continue;
  	LongToKeyName(from->names[i],buf);
  	buf[4]= '\0';
! 	if (from->has_alt_forms[i])
! 	     thisMerge= MergeAltForm;
! 	else thisMerge= merge;
! 	if (!AddKeyName(into,i,buf,thisMerge,from->fileID,False))
  	    into->errorCount++;
      }
      if (from->leds) {
*** xc/programs/xkbcomp/keycodes/sgi/indy@@/PUBLIC-LATEST	Sat Aug 31 12:21:02 1996
--- xc/programs/xkbcomp/keycodes/sgi/indy	Fri Jun 13 06:03:00 1997
***************
*** 1,4 ****
! // $XConsortium: indy /main/1 1996/08/31 12:17:15 kaleb $
  xkb_keycodes "pc101" {
      minimum= 15;
      maximum= 149;
--- 1,12 ----
! // $TOG: indy /main/3 1997/06/13 05:59:09 kaleb $
! default xkb_keycodes "universal" {
!     minimum= 15;
!     maximum= 149;
!     include "sgi/indy(pc105)"
!     alternate <BKSL> = 91;
!     alternate <BKSL> = 100;
!     alternate <BKSL> = 101;
! };
  xkb_keycodes "pc101" {
      minimum= 15;
      maximum= 149;
***************
*** 136,143 ****
  
  };
  xkb_keycodes "pc102" {
!     include "sgi/indy(pc101)"
      <LSGT> = 27;
  };
  xkb_keycodes "pc104" {
      include "sgi/indy(pc101)"
--- 144,154 ----
  
  };
  xkb_keycodes "pc102" {
!     <BKSL> = 91;
      <LSGT> = 27;
+     augment "sgi/indy(pc101)"
+     maximum= 149;
+     minimum= 15;
  };
  xkb_keycodes "pc104" {
      include "sgi/indy(pc101)"
***************
*** 151,156 ****
      <MENU> = 149;
  };
  xkb_keycodes "pc105" {
-     include "sgi/indy(pc104)"
      <LSGT> = 27;
  };
--- 162,203 ----
      <MENU> = 149;
  };
  xkb_keycodes "pc105" {
      <LSGT> = 27;
+     augment "sgi/indy(pc104)"
+     minimum= 15;
+     maximum= 149;
+ };
+ xkb_keycodes "jp106" {
+     <HZTG> = 22;
+     <AB11> = 89;
+     <AC12> = 91;
+     <NFER> = 141;
+     <XFER> = 142;
+     <HKTG> = 143;
+     alias <TLDE> = <HZTG>;
+     alias <AE00> = <HZTG>;
+     alias <AE13> = <BKSL>;
+     augment "sgi/indy(pc101)"
+     minimum= 15;
+     maximum= 149;
+ };
+ // can be combined with any other "indy" keycode
+ // description to add virtual keys which can be
+ // used to implement an overlay-based numeric
+ // keypad.
+ partial hidden xkb_keycodes "overlayKeypad" {
+     <KO7> = 17;
+     <KO8> = 18;
+     <KO9> = 19;
+     <KO6> = 146;
+     <KO5> = 145;
+     <KO4> = 144;
+     <KO1> = 136;
+     <KO2> = 137;
+     <KO3> = 138;
+     <KO0> = 135;
+     <KODL> = 139;
+ };
+ partial hidden xkb_keycodes "shiftLock" {
+     indicator 5 = "Shift Lock";
  };
*** xc/programs/xkbcomp/keymap/sgi/Imakefile@@/PUBLIC-LATEST	Sat Aug 31 12:21:24 1996
--- xc/programs/xkbcomp/keymap/sgi/Imakefile	Tue Jun 10 07:04:15 1997
***************
*** 1,7 ****
! XCOMM $XConsortium: Imakefile /main/2 1996/08/31 12:17:36 kaleb $
  
       DATAFILES = be bg ca cs de de_CH dk dvorak en_US es fi fr fr_CH \
! 		gb it no pl pt ru se th us
  
  all::
  
--- 1,7 ----
! XCOMM $TOG: Imakefile /main/3 1997/06/10 06:54:46 kaleb $
  
       DATAFILES = be bg ca cs de de_CH dk dvorak en_US es fi fr fr_CH \
! 		gb hu it jp no pl pt ru se th us
  
  all::
  
*** xc/programs/xkbcomp/keymap/sgi/be@@/PUBLIC-LATEST	Sat Aug 31 12:21:27 1996
--- xc/programs/xkbcomp/keymap/sgi/be	Sat Jun 14 06:40:15 1997
***************
*** 1,17 ****
! // $XConsortium: be /main/2 1996/08/31 12:17:40 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+be"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+be(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: be /main/4 1997/06/14 06:35:56 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+be"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+be(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/bg@@/PUBLIC-LATEST	Sat Aug 31 12:21:30 1996
--- xc/programs/xkbcomp/keymap/sgi/bg	Sat Jun 14 06:40:17 1997
***************
*** 1,10 ****
! // $XConsortium: bg /main/1 1996/08/31 12:17:43 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols  { 
! 	include "us(pc102)+bg+group(shift_toggle)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,10 ----
! // $TOG: bg /main/3 1997/06/14 06:35:58 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols  { 
! 	include "us(pc_universal)+bg+group(shift_toggle)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/ca@@/PUBLIC-LATEST	Sat Aug 31 12:21:33 1996
--- xc/programs/xkbcomp/keymap/sgi/ca	Sat Jun 14 06:40:21 1997
***************
*** 1,17 ****
! // $XConsortium: ca /main/1 1996/08/31 12:17:45 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+ca"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+ca(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: ca /main/3 1997/06/14 06:36:02 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+ca"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+ca(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/cs@@/PUBLIC-LATEST	Sat Aug 31 12:21:36 1996
--- xc/programs/xkbcomp/keymap/sgi/cs	Sat Jun 14 06:40:24 1997
***************
*** 1,9 ****
! // $XConsortium: cs /main/1 1996/08/31 12:17:49 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "us(pc102)+cs"		};
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indigo" {
--- 1,9 ----
! // $TOG: cs /main/3 1997/06/14 06:36:05 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "us(pc_universal)+cs"		};
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indigo" {
*** xc/programs/xkbcomp/keymap/sgi/de@@/PUBLIC-LATEST	Sat Aug 31 12:21:40 1996
--- xc/programs/xkbcomp/keymap/sgi/de	Sat Jun 14 06:40:27 1997
***************
*** 1,17 ****
! // $XConsortium: de /main/2 1996/08/31 12:17:53 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc102)+de"		};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+de(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
--- 1,17 ----
! // $TOG: de /main/4 1997/06/14 06:36:08 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal)+de"		};
!     xkb_geometry	{ include "sgi/indy(pc102)"			};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+de(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
*** xc/programs/xkbcomp/keymap/sgi/de_CH@@/PUBLIC-LATEST	Sat Aug 31 12:21:43 1996
--- xc/programs/xkbcomp/keymap/sgi/de_CH	Sat Jun 14 06:40:29 1997
***************
*** 1,17 ****
! // $XConsortium: de_CH /main/2 1996/08/31 12:17:56 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+de_CH"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+de_CH(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: de_CH /main/4 1997/06/14 06:36:10 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+de_CH"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+de_CH(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/dk@@/PUBLIC-LATEST	Sat Aug 31 12:21:46 1996
--- xc/programs/xkbcomp/keymap/sgi/dk	Sat Jun 14 06:40:32 1997
***************
*** 1,17 ****
! // $XConsortium: dk /main/1 1996/08/31 12:17:59 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc102)+dk"		};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+dk(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
--- 1,17 ----
! // $TOG: dk /main/3 1997/06/14 06:36:13 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal)+dk"		};
!     xkb_geometry	{ include "sgi/indy(pc102)"			};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+dk(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
*** xc/programs/xkbcomp/keymap/sgi/dvorak@@/PUBLIC-LATEST	Sat Aug 31 12:21:49 1996
--- xc/programs/xkbcomp/keymap/sgi/dvorak	Sat Jun 14 06:40:35 1997
***************
*** 1,10 ****
! // $XConsortium: dvorak /main/1 1996/08/31 12:18:02 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy"		};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc101)+dvorak"	};
!     xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo"		};
--- 1,10 ----
! // $TOG: dvorak /main/3 1997/06/14 06:36:16 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "us(pc_universal)+dvorak"	};
!     xkb_geometry	{ include "sgi/indy(pc101)"		};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo"		};
*** xc/programs/xkbcomp/keymap/sgi/en_US@@/PUBLIC-LATEST	Sat Aug 31 12:21:52 1996
--- xc/programs/xkbcomp/keymap/sgi/en_US	Sat Jun 14 06:40:37 1997
***************
*** 1,45 ****
! // $XConsortium: en_US /main/2 1996/08/31 12:18:05 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)"	};
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc102_nodeadkeys)"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy101" {
!     xkb_keycodes	{ include "sgi/indy(pc101)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc101)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indy101_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc101)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc101_nodeadkeys)"	};
!     xkb_geometry	{ include "sgi/indy(pc101)"		};
  };
  xkb_keymap "indy104" {
!     xkb_keycodes	{ include "sgi/indy(pc104)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc104)"	};
      xkb_geometry	{ include "microsoft(natural)"	};
  };
  xkb_keymap "indy104_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc104)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc104_nodeadkeys)"	};
!     xkb_geometry	{ include "microsoft(natural)"		};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"	};
--- 1,45 ----
! // $TOG: en_US /main/4 1997/06/14 06:36:18 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc_universal)"	};
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal_nodeadkeys)"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"			};
  };
  xkb_keymap "indy101" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc_universal)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indy101_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal_nodeadkeys)"	};
!     xkb_geometry	{ include "sgi/indy(pc101)"			};
  };
  xkb_keymap "indy104" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc_universal)"	};
      xkb_geometry	{ include "microsoft(natural)"	};
  };
  xkb_keymap "indy104_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal_nodeadkeys)"	};
!     xkb_geometry	{ include "microsoft(natural)"			};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"	};
*** xc/programs/xkbcomp/keymap/sgi/es@@/PUBLIC-LATEST	Sat Aug 31 12:21:56 1996
--- xc/programs/xkbcomp/keymap/sgi/es	Sat Jun 14 06:40:40 1997
***************
*** 1,17 ****
! // $XConsortium: es /main/1 1996/08/31 12:18:09 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+es"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+es(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: es /main/3 1997/06/14 06:36:21 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+es"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+es(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/fi@@/PUBLIC-LATEST	Sat Aug 31 12:21:59 1996
--- xc/programs/xkbcomp/keymap/sgi/fi	Sat Jun 14 06:40:43 1997
***************
*** 1,17 ****
! // $XConsortium: fi /main/1 1996/08/31 12:18:12 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+fi"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+fi(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: fi /main/3 1997/06/14 06:36:24 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+fi"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+fi(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/fr@@/PUBLIC-LATEST	Sat Aug 31 12:22:02 1996
--- xc/programs/xkbcomp/keymap/sgi/fr	Sat Jun 14 06:40:45 1997
***************
*** 1,17 ****
! // $XConsortium: fr /main/2 1996/08/31 12:18:15 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+fr"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols  { 
! 	include "en_US(pc102_nodeadkeys)+fr(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: fr /main/4 1997/06/14 06:36:26 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+fr"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols  { 
! 	include "en_US(pc_universal_nodeadkeys)+fr(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/fr_CH@@/PUBLIC-LATEST	Sat Aug 31 12:22:05 1996
--- xc/programs/xkbcomp/keymap/sgi/fr_CH	Sat Jun 14 06:40:48 1997
***************
*** 1,17 ****
! // $XConsortium: fr_CH /main/2 1996/08/31 12:18:18 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+fr_CH"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc102_nodeadkeys)+fr_CH(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: fr_CH /main/4 1997/06/14 06:36:29 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+fr_CH"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ 
! 	include "en_US(pc_universal_nodeadkeys)+fr_CH(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/gb@@/PUBLIC-LATEST	Sat Aug 31 12:22:08 1996
--- xc/programs/xkbcomp/keymap/sgi/gb	Sat Jun 14 06:40:50 1997
***************
*** 1,17 ****
! // $XConsortium: gb /main/1 1996/08/31 12:18:21 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+gb"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+gb(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: gb /main/3 1997/06/14 06:36:31 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+gb"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+gb(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/it@@/PUBLIC-LATEST	Sat Aug 31 12:22:12 1996
--- xc/programs/xkbcomp/keymap/sgi/it	Sat Jun 14 06:40:56 1997
***************
*** 1,17 ****
! // $XConsortium: it /main/1 1996/08/31 12:18:24 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+it"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+it(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: it /main/3 1997/06/14 06:36:37 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+it"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+it(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/no@@/PUBLIC-LATEST	Sat Aug 31 12:22:15 1996
--- xc/programs/xkbcomp/keymap/sgi/no	Sat Jun 14 06:41:01 1997
***************
*** 1,17 ****
! // $XConsortium: no /main/1 1996/08/31 12:18:28 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+no"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+no(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: no /main/3 1997/06/14 06:36:42 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+no"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+no(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/pl@@/PUBLIC-LATEST	Sat Aug 31 12:22:18 1996
--- xc/programs/xkbcomp/keymap/sgi/pl	Sat Jun 14 06:41:03 1997
***************
*** 1,17 ****
! // $XConsortium: pl /main/1 1996/08/31 12:18:31 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc102)+pl"	};
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc102)+pl(nodeadkeys)" };
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"	};
--- 1,17 ----
! // $TOG: pl /main/3 1997/06/14 06:36:45 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc_universal)+pl"	};
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "us(pc_universal)+pl(nodeadkeys)" 	};
!     xkb_geometry	{ include "sgi/indy(pc102)"			};
  };
  xkb_keymap "indigo" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"	};
*** xc/programs/xkbcomp/keymap/sgi/pt@@/PUBLIC-LATEST	Sat Aug 31 12:22:21 1996
--- xc/programs/xkbcomp/keymap/sgi/pt	Sat Jun 14 06:41:07 1997
***************
*** 1,17 ****
! // $XConsortium: pt /main/1 1996/08/31 12:18:34 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+pt"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+pt(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: pt /main/3 1997/06/14 06:36:48 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+pt"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+pt(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/ru@@/PUBLIC-LATEST	Sat Aug 31 12:22:24 1996
--- xc/programs/xkbcomp/keymap/sgi/ru	Sat Jun 14 06:41:10 1997
***************
*** 1,44 ****
! // $XConsortium: ru /main/1 1996/08/31 12:18:36 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc102)+ru(basic)"	};
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_alternate" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc102)+ru(basic)+group(toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_alternate1" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc102)+ru(basic)+group(shift_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_alternate2" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc102)+ru(basic)+group(ctrl_shift_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_alternate3" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc102)+ru(basic)+group(ctrl_alt_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
--- 1,53 ----
! // $TOG: ru /main/3 1997/06/14 06:36:51 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"			};
!     xkb_types		{ include "default"				};
!     xkb_compatibility	{ include "default"				};
!     xkb_symbols 	{ include "en_US(pc_universal)+ru(basic)"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"			};
! };
! xkb_keymap "indy_toggle" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
!     xkb_symbols { 
! 	include "en_US(pc_universal)+ru(basic)+group(toggle)" 
!     };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_shift_toggle" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc_universal)+ru(basic)+group(shift_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_ctrl_shift_toggle" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc_universal)+ru(basic)+group(ctrl_shift_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_ctrl_alt_toggle" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc_universal)+ru(basic)+group(ctrl_alt_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
! xkb_keymap "indy_caps_toggle" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
! 	include "en_US(pc_universal)+ru(basic)+group(caps_toggle)" 
      };
      xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
***************
*** 49,55 ****
      xkb_symbols 	{ include "en_US(pc102)+ru(basic)"	};
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_alternate" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
--- 58,64 ----
      xkb_symbols 	{ include "en_US(pc102)+ru(basic)"	};
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_toggle" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
***************
*** 58,64 ****
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_alternate1" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
--- 67,73 ----
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_shift_toggle" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
***************
*** 67,73 ****
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_alternate2" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
--- 76,82 ----
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_ctrl_shift_toggle" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
***************
*** 76,87 ****
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_alternate3" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
  	include "en_US(pc102)+ru(basic)+group(ctrl_alt_toggle)" 
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
--- 85,105 ----
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
! xkb_keymap "indigo_ctrl_alt_toggle" {
      xkb_keycodes	{ include "sgi/indigo(pc102)"		};
      xkb_types		{ include "default"			};
      xkb_compatibility	{ include "default"			};
      xkb_symbols { 
  	include "en_US(pc102)+ru(basic)+group(ctrl_alt_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_caps_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+ru(basic)+group(caps_toggle)" 
      };
      xkb_geometry	{ include "sgi/indigo(pc102)"		};
  };
*** xc/programs/xkbcomp/keymap/sgi/se@@/PUBLIC-LATEST	Sat Aug 31 12:22:27 1996
--- xc/programs/xkbcomp/keymap/sgi/se	Sat Jun 14 06:41:13 1997
***************
*** 1,17 ****
! // $XConsortium: se /main/2 1996/08/31 12:18:40 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+se"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc102_nodeadkeys)+se(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
--- 1,17 ----
! // $TOG: se /main/4 1997/06/14 06:36:54 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "en_US(pc_universal)+se"	};
!     xkb_geometry	{ include "sgi/indy(pc102)"		};
  };
  xkb_keymap "indy_nodeadkeys" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{
! 	include "en_US(pc_universal_nodeadkeys)+se(nodeadkeys)"
      };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
*** xc/programs/xkbcomp/keymap/sgi/th@@/PUBLIC-LATEST	Sat Aug 31 12:22:31 1996
--- xc/programs/xkbcomp/keymap/sgi/th	Sat Jun 14 06:41:16 1997
***************
*** 1,9 ****
! // $XConsortium: th /main/2 1996/08/31 12:18:44 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc102)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "en_US(pc102)+th+group(shift_toggle)"	};
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indigo" {
--- 1,11 ----
! // $TOG: th /main/4 1997/06/14 06:36:57 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{
! 	include "en_US(pc_universal)+th+group(shift_toggle)"
!     };
      xkb_geometry	{ include "sgi/indy(pc102)"	};
  };
  xkb_keymap "indigo" {
*** xc/programs/xkbcomp/keymap/sgi/us@@/PUBLIC-LATEST	Sat Aug 31 12:22:34 1996
--- xc/programs/xkbcomp/keymap/sgi/us	Sat Jun 14 06:41:18 1997
***************
*** 1,23 ****
! // $XConsortium: us /main/2 1996/08/31 12:18:47 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(pc101)"	};
!     xkb_types		{ include "default"		};
!     xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc101)"		};
!     xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indy101_euro" {
!     xkb_keycodes	{ include "sgi/indy(pc101)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc101euro)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indy_compose" {
!     xkb_keycodes	{ include "sgi/indy(pc101)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc101compose)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indigo" {
--- 1,23 ----
! // $TOG: us /main/5 1997/06/14 06:36:59 kaleb $
  default xkb_keymap "indy" {
!     xkb_keycodes	{ include "sgi/indy(universal)"		};
!     xkb_types		{ include "default"			};
!     xkb_compatibility	{ include "default"			};
!     xkb_symbols 	{ include "us(pc_universal)"		};
!     xkb_geometry	{ include "sgi/indy(pc101)"		};
  };
  xkb_keymap "indy101_euro" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc_universal)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indy_compose" {
!     xkb_keycodes	{ include "sgi/indy(universal)"	};
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
!     xkb_symbols 	{ include "us(pc_universal)"	};
      xkb_geometry	{ include "sgi/indy(pc101)"	};
  };
  xkb_keymap "indigo" {
*** xc/programs/xkbcomp/keymap/sun/de@@/PUBLIC-LATEST	Sat Aug 31 12:22:40 1996
--- xc/programs/xkbcomp/keymap/sun/de	Wed Mar 26 16:47:04 1997
***************
*** 1,4 ****
! // $XConsortium: de /main/1 1996/08/31 12:18:53 kaleb $
  //
  //Copyright (c) 1996  X Consortium
  //
--- 1,4 ----
! // $TOG: de /main/2 1997/03/26 16:50:37 kaleb $
  //
  //Copyright (c) 1996  X Consortium
  //
***************
*** 60,66 ****
      xkb_symbols 	{ 
  	include "sun/us(sun5)+iso9995-3(basic)+de"
      };
!     xkb_geometry	{ include "sun(type5)"		};
  };
  xkb_keymap "type5_de_nodeadkeys" {
      xkb_keycodes	{ include "sun(type5_euro)"	};
--- 60,66 ----
      xkb_symbols 	{ 
  	include "sun/us(sun5)+iso9995-3(basic)+de"
      };
!     xkb_geometry	{ include "sun(type5euro)"	};
  };
  xkb_keymap "type5_de_nodeadkeys" {
      xkb_keycodes	{ include "sun(type5_euro)"	};
***************
*** 69,75 ****
      xkb_symbols 	{ 
  	include "sun/us(sun5)+iso9995-3(nodeadkeys)+de(nodeadkeys)" 
      };
!     xkb_geometry	{ include "sun(type5)"		};
  };
  xkb_keymap "type5_de_openlook" {
      xkb_keycodes	{ include "sun(type5_euro)"	};
--- 69,75 ----
      xkb_symbols 	{ 
  	include "sun/us(sun5)+iso9995-3(nodeadkeys)+de(nodeadkeys)" 
      };
!     xkb_geometry	{ include "sun(type5euro)"	};
  };
  xkb_keymap "type5_de_openlook" {
      xkb_keycodes	{ include "sun(type5_euro)"	};
***************
*** 76,80 ****
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ include "sun/us(sun5ol)+iso9995-3+de"	};
!     xkb_geometry	{ include "sun(type5)"		};
  };
--- 76,80 ----
      xkb_types		{ include "default"		};
      xkb_compatibility	{ include "default"		};
      xkb_symbols 	{ include "sun/us(sun5ol)+iso9995-3+de"	};
!     xkb_geometry	{ include "sun(type5euro)"	};
  };
*** xc/programs/xkbcomp/misc.c@@/PUBLIC-LATEST	Fri Feb  2 14:18:46 1996
--- xc/programs/xkbcomp/misc.c	Fri Jun 13 06:03:10 1997
***************
*** 1,4 ****
! /* $XConsortium: misc.c /main/7 1996/02/02 14:17:22 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: misc.c /main/9 1997/06/13 05:59:19 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 500,520 ****
  		unsigned long	name,
  		unsigned int *	kc_rtrn,
  		Bool		use_aliases,
! 		Bool		create)
  #else
! FindNamedKey(xkb,name,kc_rtrn,use_aliases,create)
      XkbDescPtr		xkb;
      unsigned long	name;
      unsigned int *	kc_rtrn;
      Bool		use_aliases;
      Bool		create;
  #endif
  {
  register unsigned n;
  
      *kc_rtrn= 0;	/* some callers rely on this */
      if (xkb&&xkb->names&&xkb->names->keys) {
! 	for (n=xkb->min_key_code;n<=xkb->max_key_code;n++) {
  	    unsigned long tmp;
  	    tmp= KeyNameToLong(xkb->names->keys[n].name);
  	    if (tmp==name) {
--- 500,529 ----
  		unsigned long	name,
  		unsigned int *	kc_rtrn,
  		Bool		use_aliases,
! 		Bool		create,
! 		int		start_from)
  #else
! FindNamedKey(xkb,name,kc_rtrn,use_aliases,create,start_from)
      XkbDescPtr		xkb;
      unsigned long	name;
      unsigned int *	kc_rtrn;
      Bool		use_aliases;
      Bool		create;
+     int			start_from;
  #endif
  {
  register unsigned n;
  
+     if (start_from<xkb->min_key_code) {
+ 	start_from= xkb->min_key_code;
+     }
+     else if (start_from>xkb->max_key_code) {
+ 	return False;
+     }
+ 
      *kc_rtrn= 0;	/* some callers rely on this */
      if (xkb&&xkb->names&&xkb->names->keys) {
! 	for (n=start_from;n<=xkb->max_key_code;n++) {
  	    unsigned long tmp;
  	    tmp= KeyNameToLong(xkb->names->keys[n].name);
  	    if (tmp==name) {
***************
*** 525,531 ****
  	if (use_aliases) {
  	    unsigned long new_name;
  	    if (FindKeyNameForAlias(xkb,name,&new_name))
! 		return FindNamedKey(xkb,new_name,kc_rtrn,False,create);
  	}
      }
      if (create) {
--- 534,540 ----
  	if (use_aliases) {
  	    unsigned long new_name;
  	    if (FindKeyNameForAlias(xkb,name,&new_name))
! 		return FindNamedKey(xkb,new_name,kc_rtrn,False,create,0);
  	}
      }
      if (create) {
*** xc/programs/xkbcomp/misc.h@@/PUBLIC-LATEST	Tue Jan 23 06:58:22 1996
--- xc/programs/xkbcomp/misc.h	Tue Jun 10 07:03:33 1997
***************
*** 1,4 ****
! /* $XConsortium: misc.h /main/4 1996/01/23 06:57:05 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: misc.h /main/5 1997/06/10 06:54:04 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 139,145 ****
      unsigned long	/* name */,
      unsigned int *	/* kc_rtrn */,
      Bool		/* use_aliases */,
!     Bool		/* create */
  #endif
  );
  
--- 139,146 ----
      unsigned long	/* name */,
      unsigned int *	/* kc_rtrn */,
      Bool		/* use_aliases */,
!     Bool		/* create */,
!     int			/* start_from */
  #endif
  );
  
*** xc/programs/xkbcomp/parseutils.c@@/PUBLIC-LATEST	Fri Feb  2 14:18:51 1996
--- xc/programs/xkbcomp/parseutils.c	Fri Jun 13 06:03:13 1997
***************
*** 1,4 ****
! /* $XConsortium: parseutils.c /main/6 1996/02/02 14:17:26 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: parseutils.c /main/8 1997/06/13 05:59:21 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 30,35 ****
--- 30,36 ----
  #include "xkbpath.h"
  #include <X11/keysym.h>
  #include <X11/extensions/XKBgeom.h>
+ #include <X11/Xalloca.h>
  
  XkbFile	*rtrnValue;
  
***************
*** 946,949 ****
--- 947,966 ----
  	file->flags= flags;
      }
      return file;
+ }
+ 
+ unsigned 
+ #if NeedFunctionPrototypes
+ StmtSetMerge(ParseCommon *stmt,unsigned	merge)
+ #else
+ StmtSetMerge(stmt,merge)
+     ParseCommon *	stmt;
+     unsigned		merge;
+ #endif
+ {
+     if ((merge==MergeAltForm) && (stmt->stmtType!=StmtKeycodeDef)) {
+ 	yyerror("illegal use of 'alternate' merge mode");
+ 	merge= MergeDefault;
+     }
+     return merge;
  }
*** xc/programs/xkbcomp/parseutils.h@@/PUBLIC-LATEST	Fri Feb  2 14:18:55 1996
--- xc/programs/xkbcomp/parseutils.h	Fri Jun 13 06:03:16 1997
***************
*** 1,4 ****
! /* $XConsortium: parseutils.h /main/1 1996/02/02 14:17:30 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: parseutils.h /main/3 1997/06/13 05:59:24 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 261,266 ****
--- 261,273 ----
  #if NeedFunctionPrototypes
      char *	/* str */,
      unsigned	/* merge */
+ #endif
+ );
+ 
+ extern unsigned StmtSetMerge(
+ #if NeedFunctionPrototypes
+     ParseCommon *	/* stmt */,
+     unsigned		/* merge */
  #endif
  );
  
*** xc/programs/xkbcomp/rules/sgi@@/PUBLIC-LATEST	Sat Aug 31 10:37:23 1996
--- xc/programs/xkbcomp/rules/sgi	Sat Jun 14 06:41:21 1997
***************
*** 1,3 ****
--- 1,5 ----
+ // $TOG: sgi /main/4 1997/06/14 06:37:02 kaleb $
+ 
  ! option                =   symbols
    grp:switch            =   +group(switch)
    grp:toggle            =   +group(toggle)
***************
*** 4,50 ****
    grp:shift_toggle      =   +group(shift_toggle)
    grp:ctrl_shift_toggle =   +group(ctrl_shift_toggle)
    grp:ctrl_alt_toggle   =   +group(ctrl_alt_toggle)
    ctrl:nocaps           =   +ctrl(nocaps)
    ctrl:swapcaps         =   +ctrl(swapcaps)
    ctrl:ctrl_ac          =   +ctrl(ctrl_ac)
    ctrl:ctrl_aa          =   +ctrl(ctrl_aa)
  
! ! model   layout   	=	keycodes		geometry
!   indy    us		=    sgi/indy(pc101)		sgi/indy(pc101)
    indigo  us		=    sgi/indigo(pc101)      	sgi/indigo(pc101)
  
! ! model			=	keycodes		geometry
!   indy			=	sgi/indy(pc102)		sgi/indy(pc102)
!   indigo		=	sgi/indigo(pc102)	sgi/indigo(pc102)
!   microsoft		=    sgi/indy(pc104)         microsoft(natural)
!   kinesis		=    sgi/indy(pc101)		kinesis
!   dell101		=	sgi/indy(pc101)		dell(dell101)
!   flexpro		=    sgi/indy(pc101)         keytronic(FlexPro)
!   omnikey101		=    sgi/indy(pc101)         northgate(omnikey101)
!   pc101			=    sgi/indy(pc101)         pc(pc101)
!   pc102			=    sgi/indy(pc102)         pc(pc102)
!   jp106			=    sgi/indy(pc106)         pc(jp106)
!   digital101		=    sgi/indy(pc101)         digital/pc(pc101)
!   digital102		=    sgi/indy(pc102)         digital/pc(pc102)
!   digitalpcxaj		=    sgi/indy(pc106)		digital/pc(pcxaj)
  
  ! model     variant	=  symbols
!   microsoft nodeadkeys	=  en_US(pc104%_v)+%l%(v)
!   *         nodeadkeys	=  en_US(pc102%_v)+%l%(v)
  
  ! model     layout   =   symbols
!   microsoft us       =   us(pc104)
!   microsoft en_US    =   en_US(pc104)
!   microsoft intl     =   us(pc104compose)
!   microsoft *        =   en_US(pc104)+%l%(v)
!   kinesis   us       =   us(pc101)
!   kinesis   en_US    =   en_US(pc101)
!   kinesis   intl     =   us(pc101compose)
!   kinesis   *        =   en_US(pc101)+%l%(v)
!   *         intl     =   us(pc101compose)
!   *         us       =   us(pc101)
!   *         en_US    =   us(pc102)
!   *         *        =   en_US(pc102)+%l%(v)
  
  ! model   layout   =    compat     types
    *       *        =    complete   complete
--- 6,73 ----
    grp:shift_toggle      =   +group(shift_toggle)
    grp:ctrl_shift_toggle =   +group(ctrl_shift_toggle)
    grp:ctrl_alt_toggle   =   +group(ctrl_alt_toggle)
+   grp:caps_toggle	=   +group(caps_toggle)
    ctrl:nocaps           =   +ctrl(nocaps)
    ctrl:swapcaps         =   +ctrl(swapcaps)
    ctrl:ctrl_ac          =   +ctrl(ctrl_ac)
    ctrl:ctrl_aa          =   +ctrl(ctrl_aa)
+   keypad:overlay	=   +keypad(overlay)
+   keypad:overlay1	=   +keypad(overlay)
+   keypad:overlay2	=   +keypad(overlay)
+   lock:shift		=   +lock(shift)
+   pc104:altmeta		=   +pc104(altmeta)
+   pc104:compose		=   +pc104(compose)
  
! ! option		=   keycodes
!   lock:shift		=   +sgi/indy(shiftLock)
! 
! ! option		=   keycodes			compat
!   keypad:overlay	=   +sgi/indy(overlayKeypad)	+keypad(overlay)
!   keypad:overlay1	=   +sgi/indy(overlayKeypad)	+keypad(overlay1)
!   keypad:overlay2	=   +sgi/indy(overlayKeypad)	+keypad(overlay2)
! 
! ! model   layout   	=    keycodes			geometry
!   indy    us		=    sgi/indy(universal)	sgi/indy(pc101)
!   indy    intl          =    sgi/indy(universal)        sgi/indy(pc101)
!   indy    dvorak	=    sgi/indy(universal)	sgi/indy(pc101)
    indigo  us		=    sgi/indigo(pc101)      	sgi/indigo(pc101)
+   indigo  intl          =    sgi/indigo(pc101)          sgi/indigo(pc101)
+   indigo  dvorak	=    sgi/indigo(pc101)		sgi/indigo(pc101)
+   indy    jp		=    sgi/indy(jp106)		sgi/indy(jp106)
  
! ! model			=    keycodes			geometry
!   indy			=    sgi/indy(universal)	sgi/indy(pc102)
!   indy101		=    sgi/indy(universal)	sgi/indy(pc101)
!   indy102               =    sgi/indy(universal)	sgi/indy(pc102)
!   indy104               =    sgi/indy(universal)	microsoft(natural)
!   indy105               =    sgi/indy(universal)	microsoft(natural)
!   indy106		=    sgi/indy(jp106)		sgi/indy(jp106)
!   indigo		=    sgi/indigo(pc102)		sgi/indigo(pc102)
!   indigo102             =    sgi/indigo(pc102)          sgi/indigo(pc102)
!   microsoft		=    sgi/indy(universal)	microsoft(natural)
!   kinesis		=    sgi/indy(universal)	kinesis
!   dell101		=    sgi/indy(universal)	dell(dell101)
!   flexpro		=    sgi/indy(universal)	keytronic(FlexPro)
!   omnikey101		=    sgi/indy(universal)	northgate(omnikey101)
!   pc101			=    sgi/indy(universal)	pc(pc101)
!   pc102			=    sgi/indy(universal)	pc(pc102)
!   jp106			=    sgi/indy(jp106)		pc(jp106)
!   digital101		=    sgi/indy(universal)	digital/pc(pc101)
!   digital102		=    sgi/indy(universal)	digital/pc(pc102)
!   digitalpcxaj		=    sgi/indy(jp106)		digital/pc(pcxaj)
  
  ! model     variant	=  symbols
!   *         nodeadkeys	=  en_US(pc_universal%_v)+%l%(v)
  
  ! model     layout   =   symbols
!   *         us       =   us(pc_universal)
!   *	    jp       =   us(pc101)+sgi/%l%(v)
!   *         intl     =   us(pc_universal_compose)
!   *         en_US    =   en_US(pc_universal)
!   *         *        =   en_US(pc_universal)+%l%(v)
! 
! ! layout	=	compat
!   jp		=	complete+japan
  
  ! model   layout   =    compat     types
    *       *        =    complete   complete
*** xc/programs/xkbcomp/rules/sgi.lst@@/PUBLIC-LATEST	Sat Aug 31 10:37:26 1996
--- xc/programs/xkbcomp/rules/sgi.lst	Fri Jun 13 06:32:48 1997
***************
*** 1,6 ****
  ! model
!   indy			SGI Indy or Indigo^2
    indigo		SGI Indigo
    dell101		Dell 101-key PC
    flexpro		Keytronic FlexPro
    jp106			Generic 106-key Japanese PC
--- 1,14 ----
+ // $TOG: sgi.lst /main/3 1997/06/13 06:28:54 kaleb $
+ 
  ! model
!   indy			SGI O2, Indigo^2 or Indy
!   indy101		SGI O2, Indigo^2 or Indy (101-key US)
!   indy102		SGI O2, Indigo^2 or Indy (102-key European)
!   indy104               Generic 104-key PC
!   indy105               Generic 105-key PC
!   indy106               SGI O2, Indigo^2 or Indy (106-key Japanese)
    indigo		SGI Indigo
+   indigo102             SGI Indigo (102-key European)
    dell101		Dell 101-key PC
    flexpro		Keytronic FlexPro
    jp106			Generic 106-key Japanese PC
***************
*** 16,21 ****
--- 24,30 ----
    cs			Czechoslovakian
    de 			German
    de_CH			Swiss German
+   dvorak		Dvorak (US)
    dk			Danish
    en_US			US/English w/ISO9995-3
    es			Spanish
***************
*** 23,30 ****
--- 32,41 ----
    fr			French
    fr_CH			Swiss French
    gb			United Kingdom
+   hu			Hungarian
    it			Italian
    intl			US w/Compose Key
+   jp			Japanese
    no			Norwegian
    pl			Polish
    pt			Portugese
***************
*** 45,52 ****
--- 56,73 ----
    grp:shift_toggle	Pressing both shift keys together toggles group
    grp:ctrl_shift_toggle	Pressing shift and control together toggles group
    grp:ctrl_alt_toggle	Pressing alt and control together toggles group
+   grp:caps_toggle       Caps Lock key toggles group
    ctrl			Control Key Position
    ctrl:nocaps		Replace Caps Lock with another control key
    ctrl:swapcaps		Swap positions of control and Caps Lock
    ctrl:ctrl_ac		Control key is left of the 'A' key
    ctrl:ctrl_aa		Control key is at the left of the bottom row
+   keypad		Specify behavior of the numeric keypad
+   keypad:overlay	Use default Overlay instead of modifier for keypad
+   keypad:overlay1	Use Overlay1 instead of modifier for keypad
+   keypad:overlay2	Use Overlay2 instead of modifier for keypad
+   lock			Specify behavior of the lock key
+   lock:shift		Key is shift lock
+   lock:caps		Key is captals lock
+   lock:group		Key is group lock
+ 
*** xc/programs/xkbcomp/rules/xfree86@@/PUBLIC-LATEST	Sat Aug 31 10:37:29 1996
--- xc/programs/xkbcomp/rules/xfree86	Fri Jun 13 06:32:50 1997
***************
*** 1,3 ****
--- 1,5 ----
+ // $TOG: xfree86 /main/2 1997/06/13 06:28:57 kaleb $
+ 
  //
  //  Rules for resolving XKB components for use with XFree86
  //  Copyright 1996 by Joseph Moss
*** xc/programs/xkbcomp/rules/xfree86-it.lst@@/PUBLIC-LATEST	Sat Aug 31 10:37:31 1996
--- xc/programs/xkbcomp/rules/xfree86-it.lst	Fri Jun 13 06:32:31 1997
***************
*** 1,3 ****
--- 1,5 ----
+ // $TOG: xfree86-it.lst /main/2 1997/06/13 06:28:38 kaleb $
+ 
  //
  //  Elenco dei modelli e dei lingauggi
  //  Copyright 1996 by Joseph Moss
*** xc/programs/xkbcomp/rules/xfree86.lst@@/PUBLIC-LATEST	Sat Aug 31 10:37:34 1996
--- xc/programs/xkbcomp/rules/xfree86.lst	Fri Jun 13 06:32:53 1997
***************
*** 1,3 ****
--- 1,5 ----
+ // $TOG: xfree86.lst /main/2 1997/06/13 06:29:00 kaleb $
+ 
  //
  //  Rules descriptions for use with XFree86
  //  Copyright 1996 by Joseph Moss
*** xc/programs/xkbcomp/symbols.c@@/PUBLIC-LATEST	Fri Dec 27 21:22:16 1996
--- xc/programs/xkbcomp/symbols.c	Sat Jun 14 06:39:54 1997
***************
*** 1,4 ****
! /* $XConsortium: symbols.c /main/13 1996/12/27 21:17:07 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: symbols.c /main/15 1997/06/14 06:35:50 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 1637,1655 ****
      return ((width>=0)&&(width<=2));
  }
  
! static Bool
  #if NeedFunctionPrototypes
! CopySymbolsDef(XkbFileInfo *result,KeyInfo *key)
  #else
! CopySymbolsDef(result,key)
      XkbFileInfo *	result;
      KeyInfo *		key;
  #endif
  {
  register int	i;
  unsigned	okc,kc,width,tmp,nGroups;
  XkbKeyTypePtr	type;
! Bool		haveActions,autoType;
  KeySym *	outSyms;
  XkbAction *	outActs;
  XkbDescPtr	xkb;
--- 1637,1656 ----
      return ((width>=0)&&(width<=2));
  }
  
! Bool
  #if NeedFunctionPrototypes
! CopySymbolsDef(XkbFileInfo *result,KeyInfo *key,int start_from)
  #else
! CopySymbolsDef(result,key,start_from)
      XkbFileInfo *	result;
      KeyInfo *		key;
+     int			start_from;
  #endif
  {
  register int	i;
  unsigned	okc,kc,width,tmp,nGroups;
  XkbKeyTypePtr	type;
! Bool		haveActions,autoType,useAlias;
  KeySym *	outSyms;
  XkbAction *	outActs;
  XkbDescPtr	xkb;
***************
*** 1656,1663 ****
  unsigned	types[XkbNumKbdGroups];
  
      xkb= result->xkb;
!     if (!FindNamedKey(xkb,key->name,&kc,True,CreateKeyNames(xkb))) {
! 	if (warningLevel>=5) {
  	    WARN2("Key %s not found in %s keycodes\n",
  	    		longText(key->name,XkbMessage),
  			XkbAtomText(NULL,xkb->names->keycodes,XkbMessage));
--- 1657,1666 ----
  unsigned	types[XkbNumKbdGroups];
  
      xkb= result->xkb;
!     useAlias= (start_from==0);
!     if (!FindNamedKey(xkb,key->name,&kc,useAlias,CreateKeyNames(xkb),
! 								start_from)) {
! 	if ((start_from==0)&&(warningLevel>=5)) {
  	    WARN2("Key %s not found in %s keycodes\n",
  	    		longText(key->name,XkbMessage),
  			XkbAtomText(NULL,xkb->names->keycodes,XkbMessage));
***************
*** 1769,1775 ****
  	case XkbKB_Overlay2:
  	    /* find key by name! */
  	    if (!FindNamedKey(xkb,key->nameForOverlayKey,&okc,True,
! 	    						CreateKeyNames(xkb))) {
  		if (warningLevel>=1) {
  		    WARN2("Key %s not found in %s keycodes\n",
  			longText(key->nameForOverlayKey,XkbMessage),
--- 1772,1778 ----
  	case XkbKB_Overlay2:
  	    /* find key by name! */
  	    if (!FindNamedKey(xkb,key->nameForOverlayKey,&okc,True,
!     						CreateKeyNames(xkb),0)) {
  		if (warningLevel>=1) {
  		    WARN2("Key %s not found in %s keycodes\n",
  			longText(key->nameForOverlayKey,XkbMessage),
***************
*** 1795,1800 ****
--- 1798,1804 ----
  	else xkb->ctrls->per_key_repeat[kc/8]&= ~(1<<(kc%8));
  	xkb->server->explicit[kc]|= XkbExplicitAutoRepeatMask;
      }
+     CopySymbolsDef(result,key,kc+1);
      return True;
  }
  
***************
*** 1812,1818 ****
  
      xkb= result->xkb;
      if ((!entry->haveSymbol)&&(!FindNamedKey(xkb,entry->u.keyName,&kc,True,
!     							CreateKeyNames(xkb)))) {
  	if (warningLevel>=5) {
  	    WARN2("Key %s not found in %s keycodes\n",
  			longText(entry->u.keyName,XkbMessage),
--- 1816,1822 ----
  
      xkb= result->xkb;
      if ((!entry->haveSymbol)&&(!FindNamedKey(xkb,entry->u.keyName,&kc,True,
!     						CreateKeyNames(xkb),0))) {
  	if (warningLevel>=5) {
  	    WARN2("Key %s not found in %s keycodes\n",
  			longText(entry->u.keyName,XkbMessage),
***************
*** 1887,1893 ****
  		xkb->names->groups[i]= info.groupNames[i];
  	}
  	for (key=info.keys,i=0;i<info.nKeys;i++,key++) {
! 	    if (!CopySymbolsDef(result,key))
  		info.errorCount++;
  	}
  	if (warningLevel>3) {
--- 1891,1897 ----
  		xkb->names->groups[i]= info.groupNames[i];
  	}
  	for (key=info.keys,i=0;i<info.nKeys;i++,key++) {
! 	    if (!CopySymbolsDef(result,key,0))
  		info.errorCount++;
  	}
  	if (warningLevel>3) {
***************
*** 1898,1904 ****
  		    char buf[5];
  		    memcpy(buf,xkb->names->keys[i].name,4);
  		    buf[4]= '\0';
! 		    WARN1("No symbols defined for <%s>\n",buf);
  		}
  	    }
  	}
--- 1902,1908 ----
  		    char buf[5];
  		    memcpy(buf,xkb->names->keys[i].name,4);
  		    buf[4]= '\0';
! 		    WARN2("No symbols defined for <%s> (keycode %d)\n",buf,i);
  		}
  	    }
  	}
*** xc/programs/xkbcomp/symbols/Imakefile@@/PUBLIC-LATEST	Sat Sep 28 17:26:30 1996
--- xc/programs/xkbcomp/symbols/Imakefile	Tue Jun 10 07:05:30 1997
***************
*** 1,10 ****
! XCOMM $XConsortium: Imakefile /main/12 1996/09/28 17:18:11 rws $
  #define IHaveSubdirs
  
!     TESTDATA = 
!    DATAFILES = be bg ca cs ctrl de de_CH dk dvorak en_US es fi fr fr_CH \
! 		gb group iso9995-3 it no pl pt ru se th us
!      SUBDIRS = digital fujitsu sony sun nec
  
  MakeXkbDir($(LIBDIR)/xkb,symbols)
  InstallMultiple($(DATAFILES),$(LIBDIR)/xkb/symbols)
--- 1,11 ----
! XCOMM $TOG: Imakefile /main/13 1997/06/10 06:56:01 kaleb $
  #define IHaveSubdirs
  
!       TESTDATA = 
!      DATAFILES = be bg ca cs ctrl de de_CH dk dvorak en_US es fi fr fr_CH \
! 		 gb group hu iso9995-3 it keypad lock no pc104 pl pt ru se \
! 		 th us
!        SUBDIRS = digital fujitsu nec sgi sony sun
  
  MakeXkbDir($(LIBDIR)/xkb,symbols)
  InstallMultiple($(DATAFILES),$(LIBDIR)/xkb/symbols)
*** xc/programs/xkbcomp/symbols/en_US@@/PUBLIC-LATEST	Sat Aug 31 12:23:23 1996
--- xc/programs/xkbcomp/symbols/en_US	Sat Jun 14 06:41:24 1997
***************
*** 1,4 ****
! // $XConsortium: en_US /main/6 1996/08/31 12:19:35 kaleb $
  
  partial hidden alphanumeric_keys 
  xkb_symbols "basic" {
--- 1,4 ----
! // $TOG: en_US /main/7 1997/06/14 06:37:05 kaleb $
  
  partial hidden alphanumeric_keys 
  xkb_symbols "basic" {
***************
*** 40,46 ****
--- 40,55 ----
  
      modifier_map Mod3 { Mode_switch };
  };
+ xkb_symbols "pc_universal" {
+     key <RALT> { [ Mode_switch ] };
+     key <RWIN> { [ Multi_key ] };
  
+     augment "us(pc_universal)"
+     include "iso9995-3(basic)"
+ 
+     modifier_map Mod3 { Mode_switch };
+ };
+ 
  xkb_symbols "sun4" {
      include "us(sun4)"
      include "iso9995-3(basic)"
***************
*** 71,76 ****
--- 80,105 ----
      key <RWIN> { [ Multi_key ] };
  
      augment "us(pc104)"
+     include "iso9995-3(nodeadkeys101)"
+ 
+     modifier_map Mod3 { Mode_switch };
+ };
+ 
+ xkb_symbols "pc105_nodeadkeys" {
+     key <RALT> { [ Mode_switch ] };
+     key <RWIN> { [ Multi_key ] };
+ 
+     augment "us(pc105)"
+     include "iso9995-3(nodeadkeys101)"
+ 
+     modifier_map Mod3 { Mode_switch };
+ };
+ 
+ xkb_symbols "pc_universal_nodeadkeys" {
+     key <RALT> { [ Mode_switch ] };
+     key <RWIN> { [ Multi_key ] };
+ 
+     augment "us(pc_universal)"
      include "iso9995-3(nodeadkeys101)"
  
      modifier_map Mod3 { Mode_switch };
*** xc/programs/xkbcomp/symbols/group@@/PUBLIC-LATEST	Sat Aug 31 12:23:41 1996
--- xc/programs/xkbcomp/symbols/group	Fri Jun 13 06:28:54 1997
***************
*** 1,3 ****
--- 1,4 ----
+ // $TOG: group /main/3 1997/06/13 06:25:02 kaleb $
  // using the group(switch) map, the right alt key temporarily chooses 
  // the second keyboard group (until it is released).
  partial modifier_keys 
***************
*** 44,49 ****
--- 45,58 ----
      };
      key <LCTL>	{	[	Control_L,	ISO_Prev_Group ]	};
      key <RCTL>	{	[	Control_R,	ISO_Next_Group ]	};
+ };
+ 
+ // using the group(caps_toggle) map, pressing:
+ //     Caps Lock toggles groups
+ //     Shift+Caps Lock toggles caps lock
+ partial modifier_keys
+ xkb_symbols "caps_toggle" {
+     key	<CAPS> {	[  ISO_Next_Group,	 Caps_Lock	]	};
  };
  
  // using the group(ctrl_alt_toggle) map, pressing:
*** xc/programs/xkbcomp/symbols/ru@@/PUBLIC-LATEST	Sat Aug 31 12:23:59 1996
--- xc/programs/xkbcomp/symbols/ru	Tue Jun 10 07:05:46 1997
***************
*** 1,5 ****
! // $XConsortium: ru /main/3 1996/08/31 12:20:12 kaleb $
  partial alphanumeric_keys 
  xkb_symbols "shift_toggle" {
      include "ru(basic)"
      key <LFSH>	{	[	Shift_L,	ISO_Prev_Group ]	};
--- 1,10 ----
! // $TOG: ru /main/4 1997/06/10 06:56:17 kaleb $
  partial alphanumeric_keys 
+ xkb_symbols "toggle" {
+     include "ru(basic)"
+     key	<CAPS> {	[  ISO_Next_Group,	 Caps_Lock	]	};
+ };
+ partial alphanumeric_keys 
  xkb_symbols "shift_toggle" {
      include "ru(basic)"
      key <LFSH>	{	[	Shift_L,	ISO_Prev_Group ]	};
***************
*** 11,115 ****
      // Describes the differences between a very simple en_US
      // keyboard and a very simple Russian keybaord
  
!     name[Group1]= "Russian";
!     name[Group2]= "US/ASCII";
  
!     key <TLDE> {	[     Cyrillic_io,     Cyrillic_IO      ],	
!     			[	    grave,	asciitilde	]	};
!     key <LSGT> {	[	     less,	   greater	],
! 			[	      bar,       brokenbar	]	};
!     key <CAPS> {	[	 Caps_Lock			]	};
!     key <AD01> {	[ Cyrillic_shorti, Cyrillic_SHORTI     	],
! 			[	        q,	         Q	]	};
!     key <AE01> {	[               1,	    exclam 	],
! 			[		1,          exclam	]	};
!     key <AB01> {	[     Cyrillic_ya,     Cyrillic_YA     	],	
! 			[	        z,	         Z	]	};
!     key <AC02> {	[   Cyrillic_yeru,   Cyrillic_YERU   	],	
! 			[               s,               S	]	};
!     key <AC01> {	[     Cyrillic_ef,     Cyrillic_EF   	],	
! 			[               a,               A	]	};
!     key <AD02> {	[    Cyrillic_tse,    Cyrillic_TSE     	],	
! 			[	        w,               W	]	};
!     key <AE02> {	[               2,        quotedbl     	],	
!     			[		2,	        at	]	};
!     key <AB03> {	[     Cyrillic_es,     Cyrillic_ES   	],	
! 			[               c,               C	]	};
!     key <AB02> {	[    Cyrillic_che,    Cyrillic_CHE   	],	
! 			[               x,               X	]	};
!     key <AC03> {	[     Cyrillic_ve,     Cyrillic_VE   	],	
! 			[               d,               D	]	};
!     key <AD03> {	[      Cyrillic_u,      Cyrillic_U   	],	
! 			[               e,               E	]	};
!     key <AE04> {	[               4,       semicolon     	],	
!     			[		4,	    dollar     	]	};
!     key <AE03> {	[               3,      numerosign     	],	
!     			[		3,	numbersign    	]	};
!     key <AB04> {	[     Cyrillic_em,     Cyrillic_EM   	],	
! 			[               v,               V	]	};
!     key <AC04> {	[      Cyrillic_a,      Cyrillic_A   	],	
! 			[               f,               F	]	};
!     key <AD05> {	[     Cyrillic_ie,     Cyrillic_IE   	],	
! 			[               t,               T	]	};
!     key <AD04> {	[     Cyrillic_ka,     Cyrillic_KA   	],	
! 			[               r,               R	]	};
!     key <AE05> {	[               5,         percent 	],
! 			[		5,	   percent	]	};
!     key <AB06> {	[     Cyrillic_te,     Cyrillic_TE   	],	
! 			[               n,               N	]	};
!     key <AB05> {	[      Cyrillic_i,      Cyrillic_I   	],	
! 			[               b,               B	]	};
!     key <AC06> {	[     Cyrillic_er,     Cyrillic_ER   	],	
! 			[               h,               H	]	};
!     key <AC05> {	[     Cyrillic_pe,     Cyrillic_PE   	],	
! 			[               g,               G	]	};
!     key <AD06> {	[     Cyrillic_en,     Cyrillic_EN   	],	
! 			[               y,               Y	]	};
!     key <AE06> {	[               6,           colon     	],	
!     			[		6,     asciicircum     	]	};
!     key <AB07> {	[Cyrillic_softsign,Cyrillic_SOFTSIGN   	],	
! 			[               m,               M	]	};
!     key <AC07> {	[      Cyrillic_o,      Cyrillic_O   	],	
! 			[               j,               J	]	};
!     key <AD07> {	[    Cyrillic_ghe,    Cyrillic_GHE   	],	
! 			[               u,               U	]	};
!     key <AE07> {	[               7,        question     	],	
!     			[		7,       ampersand     	]	};
!     key <AE08> {	[               8,        asterisk  	],
! 			[		8,	  asterisk	]	};
!     key <AB08> {	[     Cyrillic_be,     Cyrillic_BE   	],	
! 			[           comma,            less   	]	};
!     key <AC08> {	[     Cyrillic_el,     Cyrillic_EL   	],	
! 			[               k,               K	]	};
!     key <AD08> {	[    Cyrillic_sha,    Cyrillic_SHA   	],	
! 			[               i,               I	]	};
!     key <AD09> {	[  Cyrillic_shcha,  Cyrillic_SHCHA   	],	
! 			[               o,               O	]	};
!     key <AE10> {	[               0,      parenright 	],
! 			[		0,	parenright	]	};
!     key <AE09> {	[               9,       parenleft 	],
! 			[		9,	 parenleft	]	};
!     key <AB09> {	[     Cyrillic_yu,     Cyrillic_YU   	],	
! 			[          period,         greater   	]	};
!     key <AB10> {	[          period,           comma   	],	
! 			[           slash,        question   	]	};
!     key <AC09> {	[     Cyrillic_de,     Cyrillic_DE   	],	
! 			[               l,               L	]	};
!     key <AC10> {	[    Cyrillic_zhe,    Cyrillic_ZHE   	],	
! 			[       semicolon,           colon	]	};
!     key <AD10> {	[     Cyrillic_ze,     Cyrillic_ZE   	],	
! 			[               p,               P	]	};
!     key <AE11> {	[           minus,      underscore 	],
  			[	    minus,	underscore	]	};
!     key <AC11> {	[      Cyrillic_e,      Cyrillic_E   	],	
! 			[      apostrophe,        quotedbl   	]	};
!     key <AD11> {	[     Cyrillic_ha,     Cyrillic_HA     	],	
! 			[     bracketleft,       braceleft	]	};
!     key <AE12> {	[           equal,            plus 	],
! 			[           equal,            plus	]	};
!     key <AD12> {	[Cyrillic_hardsign,Cyrillic_HARDSIGN	],	
! 			[    bracketright,      braceright    	]      	};
!     key <BKSL> {	[       backslash,	       bar	],
  			[	backslash,             bar	]	};
  
      // End alphanumeric section
--- 16,119 ----
      // Describes the differences between a very simple en_US
      // keyboard and a very simple Russian keybaord
  
!     name[Group1]= "US/ASCII";
!     name[Group2]= "Russian";
  
!     key	<TLDE> {	[	    grave,	asciitilde	],
! 			[     Cyrillic_io,     Cyrillic_IO	]	};
!     key	<LSGT> {	[	     less,	   greater	],
! 			[	      bar,	 brokenbar	]	};
!     key	<AD01> {	[		q,		 Q	],
! 			[ Cyrillic_shorti, Cyrillic_SHORTI	]	};
!     key	<AE01> {	[		1,	    exclam	],
! 			[		exclam,		 1	]	};
!     key	<AB01> {	[		z,		 Z	],
! 			[     Cyrillic_ya,     Cyrillic_YA	]	};
!     key	<AC02> {	[		s,		 S	],
! 			[   Cyrillic_yeru,   Cyrillic_YERU	]	};
!     key	<AC01> {	[		a,		 A	],
! 			[     Cyrillic_ef,     Cyrillic_EF	]	};
!     key	<AD02> {	[		w,		 W	],
! 			[    Cyrillic_tse,    Cyrillic_TSE	]	};
!     key	<AE02> {	[		2,		at	],
! 			[		quotedbl,	 2	]	};
!     key	<AB03> {	[		c,		 C	],
! 			[     Cyrillic_es,     Cyrillic_ES	]	};
!     key	<AB02> {	[		x,		 X	],
! 			[    Cyrillic_che,    Cyrillic_CHE	]	};
!     key	<AC03> {	[		d,		 D	],
! 			[     Cyrillic_ve,     Cyrillic_VE	]	};
!     key	<AD03> {	[		e,		 E	],
! 			[      Cyrillic_u,	Cyrillic_U	]	};
!     key	<AE04> {	[		4,	    dollar	],
! 			[		asterisk,	 4	]	};
!     key	<AE03> {	[		3,	numbersign	],
! 			[		apostrophe,	 3	]	};
!     key	<AB04> {	[		v,		 V	],
! 			[     Cyrillic_em,     Cyrillic_EM	]	};
!     key	<AC04> {	[		f,		 F	],
! 			[      Cyrillic_a,	Cyrillic_A	]	};
!     key	<AD05> {	[		t,		 T	],
! 			[     Cyrillic_ie,     Cyrillic_IE	]	};
!     key	<AD04> {	[		r,		 R	],
! 			[     Cyrillic_ka,     Cyrillic_KA	]	};
!     key	<AE05> {	[		5,	   percent	],
! 			[		colon,		 5	]	};
!     key	<AB06> {	[		n,		 N	],
! 			[     Cyrillic_te,     Cyrillic_TE	]	};
!     key	<AB05> {	[		b,		 B	],
! 			[      Cyrillic_i,	Cyrillic_I	]	};
!     key	<AC06> {	[		h,		 H	],
! 			[     Cyrillic_er,     Cyrillic_ER	]	};
!     key	<AC05> {	[		g,		 G	],
! 			[     Cyrillic_pe,     Cyrillic_PE	]	};
!     key	<AD06> {	[		y,		 Y	],
! 			[     Cyrillic_en,     Cyrillic_EN	]	};
!     key	<AE06> {	[		6,     asciicircum	],
! 			[		comma,		 6	]	};
!     key	<AB07> {	[		m,		 M	],
! 			[Cyrillic_softsign,Cyrillic_SOFTSIGN	]	};
!     key	<AC07> {	[		j,		 J	],
! 			[      Cyrillic_o,	Cyrillic_O	]	};
!     key	<AD07> {	[		u,		 U	],
! 			[    Cyrillic_ghe,    Cyrillic_GHE	]	};
!     key	<AE07> {	[		7,	 ampersand	],
! 			[		period,		 7	]	};
!     key	<AE08> {	[		8,	  asterisk	],
! 			[		semicolon,	 8	]	};
!     key	<AB08> {	[	    comma,	      less	],
! 			[     Cyrillic_be,     Cyrillic_BE	]	};
!     key	<AC08> {	[		k,		 K	],
! 			[     Cyrillic_el,     Cyrillic_EL	]	};
!     key	<AD08> {	[		i,		 I	],
! 			[    Cyrillic_sha,    Cyrillic_SHA	]	};
!     key	<AD09> {	[		o,		 O	],
! 			[  Cyrillic_shcha,  Cyrillic_SHCHA	]	};
!     key	<AE10> {	[		0,	parenright	],
! 			[		parenright,	 0	]	};
!     key	<AE09> {	[		9,	 parenleft	],
! 			[		parenleft,	 9	]	};
!     key	<AB09> {	[	   period,	   greater	],
! 			[     Cyrillic_yu,     Cyrillic_YU	]	};
!     key	<AB10> {	[	    slash,	  question	],
! 			[	    slash,	  question	]	};
!     key	<AC09> {	[		l,		 L	],
! 			[     Cyrillic_de,     Cyrillic_DE	]	};
!     key	<AC10> {	[	semicolon,	     colon	],
! 			[    Cyrillic_zhe,    Cyrillic_ZHE	]	};
!     key	<AD10> {	[		p,		 P	],
! 			[     Cyrillic_ze,     Cyrillic_ZE	]	};
!     key	<AE11> {	[	    minus,	underscore	],
  			[	    minus,	underscore	]	};
!     key	<AC11> {	[      apostrophe,	  quotedbl	],
! 			[      Cyrillic_e,	Cyrillic_E	]	};
!     key	<AD11> {	[     bracketleft,	 braceleft	],
! 			[     Cyrillic_ha,     Cyrillic_HA	]	};
!     key	<AE12> {	[	    equal,	      plus	],
! 			[	    equal,	      plus	]	};
!     key	<AD12> {	[    bracketright,	braceright	],
! 			[Cyrillic_hardsign,Cyrillic_HARDSIGN	]	};
!     key	<BKSL> {	[	backslash,	       bar	],
  			[	backslash,             bar	]	};
  
      // End alphanumeric section
***************
*** 121,123 ****
--- 125,128 ----
      modifier_map Control{ Control_L };
      modifier_map Mod3   { Mode_switch };
  };
+ 
*** xc/programs/xkbcomp/symbols/us@@/PUBLIC-LATEST	Sat Aug 31 12:24:09 1996
--- xc/programs/xkbcomp/symbols/us	Sat Jun 14 06:41:26 1997
***************
*** 1,4 ****
! // $XConsortium: us /main/11 1996/08/31 12:20:22 kaleb $
  
  // symbols definition for a very simple US/ASCII layout.
  // It has basically the alphanumeric keys, punctuation, 
--- 1,4 ----
! // $TOG: us /main/12 1997/06/14 06:37:07 kaleb $
  
  // symbols definition for a very simple US/ASCII layout.
  // It has basically the alphanumeric keys, punctuation, 
***************
*** 221,226 ****
--- 221,232 ----
      modifier_map Mod4   { Meta_L, Meta_R };
  };
  
+ // definition of Euro-style, Right "logo" key == [Mode_switch, Multi_key]
+ xkb_symbols "pc104euro" {
+     include "us(pc104)"
+     key <RWIN> {	[	Mode_switch, Multi_key	]	};
+ };
+ 
  // put the compose key on the right "logo" key
  xkb_symbols "pc104compose" {
      include "us(pc104)"
***************
*** 231,235 ****
--- 237,262 ----
  // the extra key on most European keyboards.
  xkb_symbols "pc105" {
      include "us(pc104)"
+     key <LSGT> {	[      less,    greater		]	};
+ };
+ xkb_symbols "pc105euro" {
+     include "us(pc104euro)"
+     key <LSGT> {	[      less,    greater		]	};
+ };
+ xkb_symbols "pc105compose" {
+     include "us(pc104compose)"
+     key <LSGT> {	[      less,    greater		]	};
+ };
+ // universam maps are identical to pc105; wish we had aliases for map names.
+ xkb_symbols "pc_universal" {
+     include "us(pc104)"
+     key <LSGT> {	[      less,    greater		]	};
+ };
+ xkb_symbols "pc105euro" {
+     include "us(pc104euro)"
+     key <LSGT> {	[      less,    greater		]	};
+ };
+ xkb_symbols "pc105compose" {
+     include "us(pc104compose)"
      key <LSGT> {	[      less,    greater		]	};
  };
*** xc/programs/xkbcomp/tokens.h@@/PUBLIC-LATEST	Sat Aug 31 12:19:43 1996
--- xc/programs/xkbcomp/tokens.h	Tue Jun 10 07:03:45 1997
***************
*** 1,4 ****
! /* $XConsortium: tokens.h /main/6 1996/08/31 12:15:55 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: tokens.h /main/7 1997/06/10 06:54:16 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 43,48 ****
--- 43,49 ----
  #define	OVERRIDE	11
  #define	AUGMENT		12
  #define	REPLACE		13
+ #define	ALTERNATE	14
  
  #define	VIRTUAL_MODS	20
  #define	TYPE		21
*** xc/programs/xkbcomp/xkbcomp.h@@/PUBLIC-LATEST	Sat Aug 31 12:19:50 1996
--- xc/programs/xkbcomp/xkbcomp.h	Tue Jun 10 07:03:48 1997
***************
*** 1,4 ****
! /* $XConsortium: xkbcomp.h /main/11 1996/08/31 12:16:02 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkbcomp.h /main/12 1997/06/10 06:54:19 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 105,110 ****
--- 105,111 ----
  #define	MergeAugment	1
  #define	MergeOverride	2
  #define	MergeReplace	3
+ #define	MergeAltForm	4
  
  #define	AutoKeyNames	(1L <<  0)
  #define	CreateKeyNames(x)	((x)->flags&AutoKeyNames)
*** xc/programs/xkbcomp/xkbparse.y@@/PUBLIC-LATEST	Sat Aug 31 12:19:53 1996
--- xc/programs/xkbcomp/xkbparse.y	Fri Jun 13 06:03:19 1997
***************
*** 1,4 ****
! /* $XConsortium: xkbparse.y /main/9 1996/08/31 12:16:06 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkbparse.y /main/11 1997/06/13 05:59:27 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 39,44 ****
--- 39,45 ----
  	OVERRIDE	11
  	AUGMENT		12
  	REPLACE		13
+ 	ALTERNATE	14
  	VIRTUAL_MODS	20
  	TYPE		21
  	INTERPRET	22
***************
*** 242,318 ****
  
  Decl		:	OptMergeMode VarDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode VModDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode InterpretDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyNameDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyAliasDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyTypeDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode SymbolsDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode ModMapDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode GroupCompatDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode IndicatorMapDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode IndicatorNameDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode ShapeDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode SectionDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	OptMergeMode DoodadDecl
  			{
! 			    $2->merge= $1;
  			    $$= &$2->common;
  			}
  		|	MergeMode STRING
  			{
! 			    $$= &IncludeCreate(scanStr,$1)->common;
                          }
  		;
  
--- 243,325 ----
  
  Decl		:	OptMergeMode VarDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode VModDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode InterpretDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyNameDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyAliasDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode KeyTypeDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode SymbolsDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode ModMapDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode GroupCompatDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode IndicatorMapDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode IndicatorNameDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode ShapeDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode SectionDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	OptMergeMode DoodadDecl
  			{
! 			    $2->merge= StmtSetMerge(&$2->common,$1);
  			    $$= &$2->common;
  			}
  		|	MergeMode STRING
  			{
! 			    if ($1==MergeAltForm) {
! 				yyerror("cannot use 'alternate' to include other maps");
! 				$$= &IncludeCreate(scanStr,MergeDefault)->common;
! 			    }
! 			    else {
! 				$$= &IncludeCreate(scanStr,$1)->common;
! 			    }
                          }
  		;
  
***************
*** 586,591 ****
--- 593,599 ----
  		|	AUGMENT			{ $$= MergeAugment; }
  		|	OVERRIDE		{ $$= MergeOverride; }
  		|	REPLACE			{ $$= MergeReplace; }
+ 		|	ALTERNATE		{ $$= MergeAltForm; }
  		;
  
  OptExprList	:	ExprList			{ $$= $1; }
*** xc/programs/xkbcomp/xkbscan.c@@/PUBLIC-LATEST	Sat Aug 31 12:20:00 1996
--- xc/programs/xkbcomp/xkbscan.c	Tue Jun 10 07:03:54 1997
***************
*** 1,4 ****
! /* $XConsortium: xkbscan.c /main/9 1996/08/31 12:16:13 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkbscan.c /main/10 1997/06/10 06:54:25 kaleb $ */
  /************************************************************
   Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 83,88 ****
--- 83,89 ----
  	case OVERRIDE:		sprintf(buf, "OVERRIDE"); break;
  	case AUGMENT:		sprintf(buf, "AUGMENT"); break;
  	case REPLACE:		sprintf(buf, "REPLACE"); break;
+ 	case ALTERNATE:		sprintf(buf, "ALTERNATE"); break;
  
  	case VIRTUAL_MODS:	sprintf(buf, "VIRTUAL_MODS"); break;
  	case TYPE:		sprintf(buf, "TYPE"); break;
***************
*** 312,317 ****
--- 313,319 ----
      { "override",		OVERRIDE		},
      { "augment",		AUGMENT			},
      { "replace",		REPLACE			},
+     { "alternate",		ALTERNATE		},
      { "partial",		PARTIAL			},
      { "default",		DEFAULT			},
      { "hidden",			HIDDEN			},
*** xc/programs/xkbprint/xkbprint.c@@/PUBLIC-LATEST	Sat Aug 31 12:41:38 1996
--- xc/programs/xkbprint/xkbprint.c	Tue Jun 10 07:05:54 1997
***************
*** 1,4 ****
! /* $XConsortium: xkbprint.c /main/5 1996/08/31 12:38:01 kaleb $ */
  /************************************************************
   Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
--- 1,4 ----
! /* $TOG: xkbprint.c /main/6 1997/06/10 06:56:25 kaleb $ */
  /************************************************************
   Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.
  
***************
*** 717,722 ****
--- 717,723 ----
  		uAction("Using \"C\" locale, instead\n");
  	    }
  	}
+ 	/* need C numerics so decimal point doesn't get screwed up */
  	setlocale(LC_NUMERIC,"C");
  	if ((inDpy!=outDpy)&&
  	    (XkbChangeKbdDisplay(outDpy,&result)!=Success)) {
*** xc/programs/xmodmap/xmodmap.man@@/PUBLIC-LATEST	Mon Dec  9 17:17:20 1996
--- xc/programs/xmodmap/xmodmap.man	Wed Apr  2 09:19:23 1997
***************
*** 1,4 ****
! .\" $XConsortium: xmodmap.man /main/26 1996/12/09 17:10:13 kaleb $
  .\" Copyright (c) 1988, 1989, 1990  X Consortium
  .\" Copyright 1987 Sun Microsystems, Inc.
  .\" 
--- 1,4 ----
! .\" $TOG: xmodmap.man /main/27 1997/04/02 09:22:54 kaleb $
  .\" Copyright (c) 1988, 1989, 1990  X Consortium
  .\" Copyright 1987 Sun Microsystems, Inc.
  .\" 
***************
*** 40,46 ****
  ..
  .TH XMODMAP 1 "Release 6.3" "X Version 11"
  .SH NAME
! xmodmap - utility for modifying keymaps in X
  .SH SYNOPSIS
  .B xmodmap
  [-options ...] [filename]
--- 40,46 ----
  ..
  .TH XMODMAP 1 "Release 6.3" "X Version 11"
  .SH NAME
! xmodmap - utility for modifying keymaps (and pointer buttons) in X
  .SH SYNOPSIS
  .B xmodmap
  [-options ...] [filename]
*** xc/programs/xrx/cgi-bin/Imakefile@@/PUBLIC-LATEST	Tue Dec  3 20:10:19 1996
--- xc/programs/xrx/cgi-bin/Imakefile	Fri Jun  6 10:31:43 1997
***************
*** 1,13 ****
! XCOMM $XConsortium: Imakefile /main/10 1996/12/03 20:04:42 rws $
  
  #ifndef CgiBinDir
! #define CgiBinDir /usr/xc/Jigsaw/Jigsaw/WWW/cgi-bin
  #endif
  #ifndef ProxyManager
! #define ProxyManager tcp/cambridge.x.org:6500
  #endif
  #ifndef WinCenterHost
! #define WinCenterHost windy.x.org
  #endif
  
      CGIBINDIR = CgiBinDir
--- 1,13 ----
! XCOMM $TOG: Imakefile /main/11 1997/06/06 10:34:59 kaleb $
  
  #ifndef CgiBinDir
! #define CgiBinDir /files/web/cgi-bin
  #endif
  #ifndef ProxyManager
! #define ProxyManager tcp/www.x.org:6500
  #endif
  #ifndef WinCenterHost
! #define WinCenterHost windy.osf.org
  #endif
  
      CGIBINDIR = CgiBinDir
*** xc/programs/xrx/cgi-bin/bitmap@@/PUBLIC-LATEST	Tue Dec  3 20:11:42 1996
--- xc/programs/xrx/cgi-bin/bitmap	Fri Jun 13 14:32:21 1997
***************
*** 1,5 ****
  #!/usr/local/bin/perl
! # $XConsortium: bitmap /main/6 1996/12/03 20:05:55 rws $
  # CGI script to launch xclock
  #
  
--- 1,5 ----
  #!/usr/local/bin/perl
! # $TOG: bitmap /main/7 1997/06/13 14:31:42 kaleb $
  # CGI script to launch xclock
  #
  
***************
*** 187,192 ****
--- 187,194 ----
  	}
  	# add display specification to the command line
  	$command .= " -display $xdisplay";
+ 	# and put it in the environment too for good measure.
+ 	$ENV{'DISPLAY'} = $xdisplay;
      }
      if ($width && $height) {
  	# add geometry specification to the command line
*** xc/programs/xrx/cgi-bin/dtcm@@/PUBLIC-LATEST	Tue Dec  3 20:11:48 1996
--- xc/programs/xrx/cgi-bin/dtcm	Fri Jun 13 14:34:28 1997
***************
*** 1,5 ****
  #!/usr/local/bin/perl
! # $XConsortium: dtcm /main/14 1996/12/03 20:06:00 rws $
  # CGI script to launch dtcm
  #
  
--- 1,5 ----
  #!/usr/local/bin/perl
! # $TOG: dtcm /main/15 1997/06/13 14:31:52 kaleb $
  # CGI script to launch dtcm
  #
  
***************
*** 227,232 ****
--- 227,234 ----
  	}
  	# add display specification to the command line
  	$command .= " -display $xdisplay";
+ 	# and put it in the environment too for good measure.
+ 	$ENV{'DISPLAY'} = $xdisplay;
      }
      if ($width && $height) {
  	# add geometry specification to the command line
*** xc/programs/xrx/cgi-bin/excel@@/PUBLIC-LATEST	Tue Dec  3 20:21:12 1996
--- xc/programs/xrx/cgi-bin/excel	Fri Jun 13 14:34:34 1997
***************
*** 1,5 ****
  #!/usr/local/bin/perl
! # $XConsortium: excel /main/3 1996/12/03 20:15:31 rws $
  # CGI script to launch excel
  #
  
--- 1,5 ----
  #!/usr/local/bin/perl
! # $TOG: excel /main/4 1997/06/13 14:31:58 kaleb $
  # CGI script to launch excel
  #
  
***************
*** 173,178 ****
--- 173,180 ----
  	}
  	# add display specification to the command line
  	$command .= " -display $xdisplay";
+ 	# and put it in the environment too for good measure.
+ 	$ENV{'DISPLAY'} = $xdisplay;
      }
      if ($width && $height) {
  	# add geometry specification to the command line
*** xc/programs/xrx/cgi-bin/xclock@@/PUBLIC-LATEST	Tue Dec  3 20:11:56 1996
--- xc/programs/xrx/cgi-bin/xclock	Fri Jun 13 14:34:38 1997
***************
*** 1,5 ****
  #!/usr/local/bin/perl
! # $XConsortium: xclock /main/6 1996/12/03 20:06:08 rws $
  # CGI script to launch xclock
  #
  
--- 1,5 ----
  #!/usr/local/bin/perl
! # $TOG: xclock /main/7 1997/06/13 14:32:02 kaleb $
  # CGI script to launch xclock
  #
  
***************
*** 187,192 ****
--- 187,194 ----
  	}
  	# add display specification to the command line
  	$command .= " -display $xdisplay";
+ 	# and put it in the environment too for good measure.
+ 	$ENV{'DISPLAY'} = $xdisplay;
      }
      if ($width && $height) {
  	# add geometry specification to the command line
*** xc/programs/xrx/cgi-bin/xload@@/PUBLIC-LATEST	Tue Dec  3 20:12:00 1996
--- xc/programs/xrx/cgi-bin/xload	Fri Jun 13 14:34:42 1997
***************
*** 1,5 ****
  #!/usr/local/bin/perl
! # $XConsortium: xload /main/12 1996/12/03 20:06:12 rws $
  # CGI script to launch xload
  #
  
--- 1,5 ----
  #!/usr/local/bin/perl
! # $TOG: xload /main/13 1997/06/13 14:32:05 kaleb $
  # CGI script to launch xload
  #
  
***************
*** 187,192 ****
--- 187,194 ----
  	}
  	# add display specification to the command line
  	$command .= " -display $xdisplay";
+ 	# and put it in the environment too for good measure.
+ 	$ENV{'DISPLAY'} = $xdisplay;
      }
      if ($width && $height) {
  	# add geometry specification to the command line
*** xc/programs/xrx/htdocs/Imakefile@@/PUBLIC-LATEST	Tue Dec  3 19:44:56 1996
--- xc/programs/xrx/htdocs/Imakefile	Fri Jun  6 10:31:57 1997
***************
*** 1,10 ****
! XCOMM $XConsortium: Imakefile /main/6 1996/12/03 19:39:14 rws $
  
  #ifndef HtmlDir
! #define HtmlDir /usr/xc/Jigsaw/Jigsaw/WWW
  #endif
  #ifndef WebServer
! #define WebServer cambridge.x.org:8001
  #endif
  
        HTMLDIR = HtmlDir
--- 1,10 ----
! XCOMM $TOG: Imakefile /main/7 1997/06/06 10:35:09 kaleb $
  
  #ifndef HtmlDir
! #define HtmlDir /files/web/xfiles/consortium/plug-in
  #endif
  #ifndef WebServer
! #define WebServer www.x.org
  #endif
  
        HTMLDIR = HtmlDir
*** /dev/null	Wed Jun 25 14:44:38 1997
--- xc/programs/xkbcomp/compat/keypad	Tue Jun 10 07:04:00 1997
***************
*** 0 ****
--- 1,60 ----
+ // $TOG: keypad /main/1 1997/06/10 06:54:31 kaleb $
+ 
+ // Interpretations needed to implement the numeric keypad
+ // as an overlay instead of a modifier.
+ 
+ partial hidden xkb_compatibility "overlay"  {
+     include "keypad(overlay1)"
+ };
+ partial hidden xkb_compatibility "overlay1"  {
+     virtual_modifiers NumLock,AltGr;
+ 
+     interpret.repeat= False;
+     setMods.clearLocks= True;
+     latchMods.clearLocks= True;
+     latchMods.latchToLock= True;
+ 
+     interpret Num_Lock {
+ 	virtualModifier= NumLock;
+ 	action= LockControls(ctrls=overlay1);
+     };
+     interpret Num_Lock+Any {
+ 	virtualModifier= NumLock;
+ 	action= LockControls(ctrls=overlay1);
+     };
+ 
+     indicator.allowExplicit= True;
+     indicator.driveskbd= True;
+     replace indicator "Num Lock" {
+ 	whichModState= Locked;
+ 	modifiers= NumLock;
+ 	controls= Overlay1;
+     };
+     indicator.allowExplicit= True;
+ };
+ partial hidden xkb_compatibility "overlay2"  {
+     virtual_modifiers NumLock,AltGr;
+ 
+     interpret.repeat= False;
+     setMods.clearLocks= True;
+     latchMods.clearLocks= True;
+     latchMods.latchToLock= True;
+ 
+     interpret Num_Lock {
+ 	virtualModifier= NumLock;
+ 	action= LockControls(ctrls=overlay2);
+     };
+     interpret Num_Lock+Any {
+ 	virtualModifier= NumLock;
+ 	action= LockControls(ctrls=overlay1);
+     };
+ 
+     indicator.allowExplicit= True;
+     indicator.driveskbd= True;
+     replace indicator "Num Lock" {
+ 	whichModState= Locked;
+ 	modifiers= NumLock;
+ 	controls= Overlay2;
+     };
+     indicator.allowExplicit= True;
+ };
*** /dev/null	Wed Jun 25 14:44:39 1997
--- xc/programs/xkbcomp/geometry/sgi/O2	Tue Jun 10 07:04:06 1997
***************
*** 0 ****
--- 1,616 ----
+ // $TOG: O2 /main/1 1997/06/10 06:54:37 kaleb $
+ //
+ // Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
+ //
+ // Permission to use, copy, modify, and distribute this
+ // software and its documentation for any purpose and without
+ // fee is hereby granted, provided that the above copyright
+ // notice appear in all copies and that both that copyright
+ // notice and this permission notice appear in supporting
+ // documentation, and that the name of Silicon Graphics not be 
+ // used in advertising or publicity pertaining to distribution 
+ // of the software without specific prior written permission.
+ // Silicon Graphics makes no representation about the suitability 
+ // of this software for any purpose. It is provided "as is"
+ // without any express or implied warranty.
+ // 
+ // SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+ // SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ // AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ // GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+ // DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+ // DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+ // OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ // THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ //
+ default xkb_geometry "pc101" {
+ 
+     // This is an approximate layout for a 101-key (US/ASCII) SGI
+     // keyboard.  I just took a similar layout (101 key PC keyboard)
+     // and adjusted the sizes of a few keys by eye.  I didn't actually
+     // *measure* a real keyboard.
+ 
+     description= "101-key keyboard for Silicon Graphics O2";
+ 
+     width= 448;
+     height= 162;
+ 
+     shape "EDGE" { 
+ 	cornerRadius= 2, 
+ 	{ [ 15,    0 ], [ 433,   0 ], [ 433, 10 ], [ 448, 10 ],
+ 	  [ 448, 162 ], [   0, 162 ], [   0, 10 ], [ 15,  10 ] }
+     };
+     shape.cornerRadius= 1;
+     shape "NORM" { { [ 18,18] }, { [2,1], [16,17] } };
+     shape "BKSP" { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "TABK" { { [ 28,18] }, { [2,1], [26,17] } };
+     shape "BKSL" { { [ 27,18] }, { [2,1], [25,17] } };
+     shape "RTRN" { { [ 40,18] }, { [2,1], [37,17] } };
+     shape "CAPS" { { [ 34,18] }, { [2,1], [29,17] } };
+     shape "RTSH" { { [ 49,18] }, { [2,1], [47,17] } };
+     shape "LFSH" { { [ 44,18] }, { [2,1], [42,17] } };
+     shape "MODK" { { [ 28,18] }, { [2,1], [26,17] } };
+     shape "SPCE" { { [130,18] }, { [2,1], [128,17] } };
+     shape "KP0"  { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "KPAD" { { [ 18,37] }, { [2,1], [16,36] } };
+     shape "LOGO" { { [ 12,12] } };
+ 
+     outline "Edges" {
+ 	top= 0;
+ 	left= 0;
+ 	shape= "EDGE";
+     };
+ 
+     section.left= 6;
+     row.left= 1;
+     key.shape= "NORM";
+     key.gap=  1;
+     section "Function" {
+ 	top= 25;
+ 	row {
+ 	    top= 1;
+ 	    keys {	{ <ESC>, color="grey20" },
+ 			{ <FK01>, 19}, <FK02>, <FK03>, <FK04>,
+ 			{ <FK05>, 11}, <FK06>, <FK07>, <FK08>,
+ 			{ <FK09>, 11}, <FK10>, <FK11>, <FK12>
+ 	    };
+ 	};
+     }; // End of "Function" section
+ 
+     section "Alpha" {
+ 	top= 58;
+ 	row {
+ 	    top= 1;
+ 	    keys { 	<TLDE>, <AE01>, <AE02>, <AE03>, <AE04>,
+ 			<AE05>, <AE06>, <AE07>, <AE08>, <AE09>,
+ 			<AE10>, <AE11>, <AE12>,
+ 			{ <BKSP>, "BKSP", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys {	{ <TAB>, "TABK", color= "grey20" },
+ 			<AD01>, <AD02>, <AD03>, <AD04>, <AD05>, 
+ 			<AD06>, <AD07>, <AD08>, <AD09>, <AD10>, 
+ 			<AD11>, <AD12>,
+ 			{ <BKSL>, "BKSL" }
+ 	    };	
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { 	{ <CAPS>, "CAPS", color="grey20" },
+ 	 		<AC01>, <AC02>, <AC03>, <AC04>, <AC05>, 
+ 			<AC06>, <AC07>, <AC08>, <AC09>, <AC10>, 
+ 			<AC11>, { <RTRN>, "RTRN", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys {	{ <LFSH>, "LFSH", color="grey20" }, 
+ 	 		<AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
+ 			<AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
+ 			{ <RTSH>, "RTSH", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    key.shape= "MODK";
+ 	    key.color= "grey20";
+ 	    keys {	<LCTL>,	{ <LALT>, 20 },
+ 			{ <SPCE>, "SPCE",color="white" },
+ 			<RALT>, { <RCTL>, 20 }
+ 	    };
+ 	};
+     }; // End of "Alpha" section
+ 
+     section "Editing" {
+ 	top= 25;
+ 	left= 299;
+ 	key.color= "grey20";
+ 	row {
+ 	    top= 1;
+ 	    keys { <PRSC>, <SCLK>, <PAUS> };
+ 	};
+ 	row {
+ 	    top= 33;
+ 	    keys { <INS>, <HOME>, <PGUP> };
+ 	};
+ 	row {
+ 	    top= 53;
+ 	    keys { <DELE>, <END>, <PGDN> };
+ 	};
+ 	row {
+ 	    top= 91;
+ 	    left= 20;
+ 	    keys { <UP> };
+ 	};
+ 	row {
+ 	    top= 110;
+ 	    keys { <LEFT>, <DOWN>, <RGHT> };
+ 	};
+     }; // End of "Editing" section
+ 
+     shape "LEDS" { cornerRadius= 0, { [ 76 ,20 ] } };
+     shape "LED"  { cornerRadius= 0, { [  3, 1.5] } };
+     solid "LedPanel" {
+ 	shape= "LEDS";
+ 	top=  25;
+ 	left= 364;
+ 	color= "grey10";
+     };
+     indicator.onColor= "green";
+     indicator.offColor= "green30";
+     indicator.top= 40.5;
+     indicator.shape= "LED";
+     indicator "NumLock"     { left= 372; };
+     indicator "CapsLock"    { left= 397; };
+     indicator "ScrollLock"  { left= 422; };
+ 
+     text.font= "helvetica";
+     text.weight= "bold";
+     text.slant= "r";
+     text.fontWidth= "normal";
+     text.fontSize= 12;
+     text.top= 39.5;
+     text.color= "black";
+     text "NumLockLabel"		{ left= 376.5; text="1"; };
+     text "CapsLockLabel"	{ left= 401.5; text="A"; };
+     text "ScrollLockLabel"	{ left= 426.5; text="S"; };
+     
+     logo "SGILogoImage" 	{ 
+ 	top= 26.5;
+ 	left= 396;
+ 	name= "SGI"; 
+ 	shape= "LOGO"; 
+     };
+     text.font= "helvetica";
+     text.weight= "bold";
+     text.slant= "o";
+     text.fontWidth= "narrow";
+     text.fontSize= 18;
+     text "SiliconLogoText"	{
+ 	top= 27;
+ 	left= 375;
+ 	width= 20;
+ 	text= "Silicon";
+     };
+     text "GraphicsLogoText"	{
+ 	top= 27;
+ 	left= 409;
+ 	width= 20;
+ 	text= "Graphics";
+     };
+ 
+     section "Keypad" {
+ 	top= 58;
+ 	left= 363;
+ 	row {
+ 	    top= 1;
+ 	    key.color= "grey20";
+ 	    keys { <NMLK>, <KPDV>, <KPMU>, <KPSU> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <KP7>, <KP8>, <KP9>, { <KPAD>, "KPAD", color= "grey20" } };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <KP4>, <KP5>, <KP6> };
+     	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <KP1>, <KP2>, <KP3>, { <KPEN>, "KPAD", color= "grey20" } };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { { <KP0>, "KP0" }, <KPDL> };
+ 	};
+     }; // End of "Keypad" section
+     alias <AC00> = <CAPS>;
+     alias <AA00> = <LCTL>;
+ };
+ 
+ xkb_geometry "pc102" {
+ 
+     // This is an approximate layout for 102-key SGI international
+     // keyboards.  I just took a similar layout (101 key PC keyboard)
+     // and adjusted the sizes of a few keys by eye.  I didn't actually
+     // *measure* a real keyboard.
+ 
+     description= "Silicon Graphics 102-key Keyboard";
+     width= 470;
+     height= 193;
+ 
+     shape.cornerRadius= 1;
+     shape "EDGE" { cornerRadius=2, { [ 470, 193 ] } };
+     shape "NORM" { { [18,18] }, { [2,1], [16,17] } };
+     shape "BKSP" { { [35,18] }, { [2,1], [33,17] } };
+     shape "TABK" { { [27,18] }, { [2,1], [25,17] } };
+     shape "RTRN" {
+ 	approx = { [ 0, 0], [26,37] },
+ 	{ [ 0, 0], [26, 0], [26,37],
+ 	  [ 5,37], [ 5,18], [ 0,18] },
+ 	{ [ 1, 1], [24, 1], [24,36],
+ 	  [ 7,36], [ 7,17], [ 1,17] }
+     };
+     shape "CAPS" { { [ 32,18] }, { [2,1], [25,17] } };
+     shape "RTSH" { { [ 50,18] }, { [2,1], [48,17] } };
+     shape "LFSH" { { [ 22,18] }, { [2,1], [20,17] } };
+     shape "MODK" { { [ 28,18] }, { [2,1], [26,17] } };
+     shape "SPCE" { { [130,18] }, { [2,1], [128,17] } };
+     shape "KP0"  { { [ 37,18] }, { [2,1], [35,17] } };
+     shape "KPAD" { { [ 18,37] }, { [2,1], [16,36] } };
+     shape "LOGO" { { [ 16,16] } };
+ 
+     outline "Edges" {
+ 	top= 0;
+ 	left= 0;
+ 	shape= "EDGE";
+     };
+ 
+     section.left= 19;
+     row.left= 1;
+     key.shape= "NORM";
+     key.gap=  1;
+     section "Function" {
+ 	top= 50;
+ 	row {
+ 	    top= 1;
+ 	    keys {  	{ <ESC>, color="grey20" },
+ 			{ <FK01>, 18}, <FK02>, <FK03>, <FK04>,
+ 			{ <FK05>, 10}, <FK06>, <FK07>, <FK08>,
+ 			{ <FK09>, 10}, <FK10>, <FK11>, <FK12>
+ 	    };
+ 	};
+     }; // End of "Function" section
+ 
+     section "Alpha" {
+ 	top= 83;
+ 	row {
+ 	    top= 1;
+ 	    keys { 	<TLDE>, <AE01>, <AE02>, <AE03>, <AE04>,
+ 			<AE05>, <AE06>, <AE07>, <AE08>, <AE09>,
+ 			<AE10>, <AE11>, <AE12>,
+ 			{ <BKSP>, "BKSP", color= "grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { 	{ <TAB>, "TABK", color= "grey20" },
+ 			<AD01>, <AD02>, <AD03>, <AD04>, <AD05>, 
+ 			<AD06>, <AD07>, <AD08>, <AD09>, <AD10>, 
+ 			<AD11>, <AD12>,
+ 			{ <RTRN>, "RTRN", color= "grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { 	{ <CAPS>, "CAPS", color= "grey20" },
+ 			<AC01>, <AC02>, <AC03>, <AC04>, <AC05>, 
+ 			<AC06>, <AC07>, <AC08>, <AC09>, <AC10>, 
+ 			<AC11>, <BKSL>
+ 	    };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { 	{ <LFSH>, "LFSH", color= "grey20" }, <LSGT>,
+ 			<AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
+ 			<AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
+ 			{ <RTSH>, "RTSH", color= "grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    key.shape= "MODK";
+ 	    key.color= "grey20";
+ 	    keys {	<LCTL>,
+ 			{ <LALT>, 19 },
+ 			{ <SPCE>, "SPCE", color="white" },
+ 			<RALT>,
+ 			{ <RCTL>, 19 }
+ 	    };
+ 	};
+     }; // End of "Alpha" section
+ 
+     section "Editing" {
+ 	top= 50;
+ 	left= 308;
+ 	key.color= "grey20";
+ 	row {
+ 	    top= 1;
+ 	    keys { <PRSC>, <SCLK>, <PAUS> };
+ 	};
+ 	row {
+ 	    top= 33;
+ 	    keys { <INS>, <HOME>, <PGUP> };
+ 	};
+ 	row {
+ 	    top= 53;
+ 	    keys { <DELE>, <END>, <PGDN> };
+ 	};
+ 	row {
+ 	    top= 91;
+ 	    left= 20;
+ 	    keys { <UP> };
+ 	};
+ 	row {
+ 	    top= 110;
+ 	    keys { <LEFT>, <DOWN>, <RGHT> };
+ 	};
+     }; // End of "Editing" section
+ 
+     shape "LEDS" { cornerRadius= 0, { [ 76 ,20 ] } };
+     shape "LED"  { cornerRadius= 0, { [  1,  3 ] } };
+     solid "LedPanel" {
+ 	shape= "LEDS";
+ 	top=  50;
+ 	left= 375;
+ 	color= "grey10";
+     };
+     indicator.onColor= "green";
+     indicator.offColor= "green30";
+     indicator.top= 64.5;
+     indicator.shape= "LED";
+     indicator "NumLock"     { left= 384; };
+     indicator "CapsLock"    { left= 409; };
+     indicator "ScrollLock"  { left= 434; };
+     text.top= 52;
+     text.color= "black";
+     text "NumLockLabel"		{ left= 380.5; text="Num\nLock"; };
+     text "CapsLockLabel"	{ left= 405; text="Caps\nLock"; };
+     text "ScrollLockLabel"	{ left= 430; text="Scroll\nLock"; };
+ 
+     logo "SGILogoImage" { 
+ 	top= 17;
+ 	left= 22;
+ 	name= "SGI"; 
+ 	shape= "LOGO"; 
+     };
+     text "SGILogoText"	{
+ 	top= 21;
+ 	left= 40;
+ 	width= 50;
+ 	text= "SiliconGraphics";
+ 	font= "helvetica";
+ 	slant= "o";
+ 	weight= "bold";
+ 	setWidth= "narrow";
+ 	fontSize= 24;
+     };
+ 
+     section "Keypad" {
+ 	top= 83;
+ 	left= 374;
+ 	row {
+ 	    top= 1;
+ 	    key.color= "grey20";
+ 	    keys { <NMLK>, <KPDV>, <KPMU>, <KPSU> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <KP7>, <KP8>, <KP9>, { <KPAD>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <KP4>, <KP5>, <KP6> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <KP1>, <KP2>, <KP3>, { <KPEN>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { { <KP0>, "KP0" }, <KPDL> };
+ 	};
+     }; // End of "Keypad" section
+     alias <AC00> = <CAPS>;
+     alias <AA00> = <LCTL>;
+ };
+ 
+ xkb_geometry "jp106" {
+     description= "Silicon Graphics 106-key Japanese keyboard";
+     width= 442;
+     height= 167;
+ 
+     shape "EDGE" { cornerRadius= 2, { [ 442, 167 ] } };
+     shape.cornerRadius= 1;
+     shape "NORM" { { [ 18,18] }, { [2,1], [ 16,17] } };
+     shape "BKSP" { { [ 18,18] }, { [2,1], [ 16,17] } };
+     shape "TABK" { { [ 28,18] }, { [2,1], [ 26,17] } };
+     shape "BKSL" { { [ 27,18] }, { [2,1], [ 25,17] } };
+     shape "RTRN" {
+         { [0,0],[ 27,0],[27,37],[4,37],[4,18],[0,18] } ,
+         { [2,1],[ 25,1],[25,36],[5,36],[5,17],[2,17] } };
+     shape "CAPS" { { [ 32,18] }, { [2,1], [ 30,17] } };
+     shape "LFSH" { { [ 42,18] }, { [2,1], [ 40,17] } };
+     shape "RTSH" { { [ 32,18] }, { [2,1], [ 30,17] } };
+     shape "MODK" { { [ 28,18] }, { [2,1], [ 26,17] } };
+     shape "SPCE" { { [ 46,18] }, { [2,1], [ 44,17] } };
+     shape "KP0"  { { [ 37,18] }, { [2,1], [ 35,17] } };
+     shape "KPAD" { { [ 18,37] }, { [2,1], [ 16,36] } };
+     shape "LOGO" { { [ 16,16] } };
+ 
+     outline "Edges" {
+ 	top= 0;
+ 	left= 0;
+ 	shape= "EDGE";
+     };
+ 
+     logo "SGILogoImage" { 
+ 	top= 5;
+ 	left= 6;
+ 	name= "SGI"; 
+ 	shape= "LOGO"; 
+     };
+ 
+     text "SGILogoText"	{
+ 	top= 9;
+ 	left= 25;
+ 	width= 50;
+ 	text= "SiliconGraphics";
+ 	font= "helvetica";
+ 	slant= "o";
+ 	weight= "bold";
+ 	fontWidth= "narrow";
+ 	fontSize= 24;
+     };
+ 
+     shape "LEDS" { cornerRadius= 0.1, { [ 76 ,20 ] } };
+     shape "LED"  { cornerRadius= 0, { [  5,  1 ] } };
+     solid "LedPanel" {
+ 	shape= "LEDS";
+ 	top=  25;
+ 	left= 362;
+ 	color= "grey10";
+     };
+ 
+     indicator.onColor= "green";
+     indicator.offColor= "green30";
+     indicator.top= 40;
+     indicator.shape= "LED";
+     indicator "NumLock"     { left= 366; };
+     indicator "CapsLock"    { left= 391; };
+     indicator "ScrollLock"  { left= 416; };
+     text.top= 28;
+     text.color= "black";
+     text "NumLockLabel"		{ left= 366; text="Num\nLock"; };
+     text "CapsLockLabel"	{ left= 391; text="Caps\nLock"; };
+     text "ScrollLockLabel"	{ left= 416; text="Scroll\nLock"; };
+ 
+     section.left= 5;
+     row.left= 1;
+     key.shape= "NORM";
+     key.gap=  1;
+     section "Function" {
+ 	top= 25;
+ 	row {
+ 	    top= 1;
+ 	    keys {  { <ESC>, color="grey20" },
+ 		    { <FK01>, 18 }, <FK02>, <FK03>, <FK04>,
+ 		    { <FK05>, 11 ,color="grey20"}, {<FK06>,color="grey20"}, 
+ 		    { <FK07>, color="grey20"}, {<FK08>,color="grey20"},
+ 		    { <FK09>, 11 }, <FK10>, <FK11>, <FK12>,
+ 		    { <PRSC>, 8 }, <SCLK>, <PAUS> 
+ 	    };
+ 	};
+     }; // End of "Function" section
+ 
+     section "Alpha" {
+ 	top= 61;
+ 	row {
+ 	    top= 1;
+ 	    keys { {<HZTG>,color="grey20"}, <AE01>, <AE02>, 
+                     <AE03>, <AE04>, <AE05>, <AE06>, <AE07>, 
+ 	            <AE08>, <AE09>, <AE10>, <AE11>, <AE12>,
+ 		    <AE13>, { <BKSP>, "BKSP", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { { <TAB>, "TABK", color="grey20" },
+ 		   <AD01>, <AD02>, <AD03>, <AD04>, <AD05>, 
+ 		   <AD06>, <AD07>, <AD08>, <AD09>, <AD10>, 
+ 		   <AD11>, <AD12>, { <RTRN>, 1 ,"RTRN",color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { { <CAPS>, "CAPS", color="grey20" },
+ 		   <AC01>, <AC02>, <AC03>, <AC04>, <AC05>, 
+ 		   <AC06>, <AC07>, <AC08>, <AC09>, <AC10>, 
+ 		   <AC11>, <AC12>
+ 	    };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { { <LFSH>, "LFSH", color="grey20" },
+ 		    <AB01>, <AB02>, <AB03>, <AB04>, <AB05>, 
+ 		    <AB06>, <AB07>, <AB08>, <AB09>, <AB10>, 
+ 		    <AB11>, { <RTSH>, "RTSH", color="grey20" }
+ 	    };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    key.shape= "MODK";
+ 	    key.color= "grey20";
+ 	    keys { <LCTL>, { <LALT>, 20 },<NFER>,
+ 		   { <SPCE>, "SPCE", color="white" },
+ 		   <XFER>,<HKTG>,<RALT>, { <RCTL>, 17 }
+ 	    };
+ 	};
+     }; // End of "Alpha" section
+ 
+     section "Editing" {
+ 	top= 61;
+ 	left= 296;
+ 	key.color= "grey20";
+ 	row {
+ 	    top= 1;
+ 	    keys { <INS>, <HOME>, <PGUP> };
+ 	};
+         row {
+ 	    top= 20;
+ 	    keys { <DELE>, <END>, <PGDN> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    left= 20;
+ 	    keys { <UP> };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { <LEFT>, <DOWN>, <RGHT> };
+ 	};
+     }; // End of "Editing" section
+ 
+     section "Keypad" {
+ 	top= 61;
+ 	left= 361;
+ 	row {
+ 	    top= 1;
+ 	    key.color= "grey20";
+ 	    keys { <NMLK>, <KPDV>, <KPMU>, <KPSU> };
+ 	};
+ 	row {
+ 	    top= 20;
+ 	    keys { <KP7>, <KP8>, <KP9>, { <KPAD>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 39;
+ 	    keys { <KP4>, <KP5>, <KP6> };
+ 	};
+ 	row {
+ 	    top= 58;
+ 	    keys { <KP1>, <KP2>, <KP3>, { <KPEN>, "KPAD", color="grey20" } };
+ 	};
+ 	row {
+ 	    top= 77;
+ 	    keys { { <KP0>, "KP0" }, <KPDL> };
+ 	};
+     }; // End of "Keypad" section
+ 
+     alias <AC00> = <CAPS>;
+     alias <AA00> = <LCTL>;
+ 
+ }; // End of "jp106" geometry
+ 
*** /dev/null	Wed Jun 25 14:44:39 1997
--- xc/programs/xkbcomp/keymap/sgi/hu	Sat Jun 14 06:40:54 1997
***************
*** 0 ****
--- 1,105 ----
+ // $TOG: hu /main/2 1997/06/14 06:36:35 kaleb $
+ default xkb_keymap "indy" {
+     xkb_keycodes	{ include "sgi/indy(universal)"			};
+     xkb_types		{ include "default"				};
+     xkb_compatibility	{ include "default"				};
+     xkb_symbols 	{ include "en_US(pc_universal)+hu(basic)"	};
+     xkb_geometry	{ include "sgi/indy(pc102)"			};
+ };
+ xkb_keymap "indy_toggle" {
+     xkb_keycodes	{ include "sgi/indy(universal)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc_universal)+hu(basic)+group(toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indy(pc102)"		};
+ };
+ xkb_keymap "indy_shift_toggle" {
+     xkb_keycodes	{ include "sgi/indy(universal)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc_universal)+hu(basic)+group(shift_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indy(pc102)"		};
+ };
+ xkb_keymap "indy_ctrl_shift_toggle" {
+     xkb_keycodes	{ include "sgi/indy(universal)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc_universal)+hu(basic)+group(ctrl_shift_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indy(pc102)"		};
+ };
+ xkb_keymap "indy_ctrl_alt_toggle" {
+     xkb_keycodes	{ include "sgi/indy(universal)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc_universal)+hu(basic)+group(ctrl_alt_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indy(pc102)"		};
+ };
+ xkb_keymap "indy_caps_toggle" {
+     xkb_keycodes	{ include "sgi/indy(universal)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc_universal)+hu(basic)+group(caps_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indy(pc102)"		};
+ };
+ xkb_keymap "indigo" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols 	{ include "en_US(pc102)+hu(basic)"	};
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+hu(basic)+group(toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_shift_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+hu(basic)+group(shift_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_ctrl_shift_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+hu(basic)+group(ctrl_shift_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_ctrl_alt_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+hu(basic)+group(ctrl_alt_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
+ xkb_keymap "indigo_caps_toggle" {
+     xkb_keycodes	{ include "sgi/indigo(pc102)"		};
+     xkb_types		{ include "default"			};
+     xkb_compatibility	{ include "default"			};
+     xkb_symbols { 
+ 	include "en_US(pc102)+hu(basic)+group(caps_toggle)" 
+     };
+     xkb_geometry	{ include "sgi/indigo(pc102)"		};
+ };
*** /dev/null	Wed Jun 25 14:44:40 1997
--- xc/programs/xkbcomp/keymap/sgi/jp	Sat Jun 14 06:40:59 1997
***************
*** 0 ****
--- 1,8 ----
+ // $TOG: jp /main/2 1997/06/14 06:36:40 kaleb $
+ default xkb_keymap "indy" {
+     xkb_keycodes	{ include "sgi/indy(jp106)"			};
+     xkb_types		{ include "default"				};
+     xkb_compatibility	{ include "default"				};
+     xkb_symbols 	{ include "us(pc101)+sgi/jp"			};
+     xkb_geometry	{ include "sgi/indy(jp106)"			};
+ };
*** /dev/null	Wed Jun 25 14:44:40 1997
--- xc/programs/xkbcomp/symbols/hu	Fri Jun 13 06:28:58 1997
***************
*** 0 ****
--- 1,113 ----
+ // $TOG: hu /main/2 1997/06/13 06:25:05 kaleb $
+ default partial alphanumeric_keys 
+ xkb_symbols "basic" {
+ 
+     // Describes the differences between a very simple US/ASCII
+     // keyboard and a very simple Hungarian keyboard.
+ 
+     // Alphanumeric section
+ 
+     name[group1]="Hungarian";
+ 
+     key <TLDE> {	[	0,		section		]	};
+     key <AE01> {	[	1,      	apostrophe	],
+ 			[	asciitilde			]	};
+     key <AE02> {	[	2,		quotedbl	],
+ 			[	caron				]	};
+     key <AE03> {	[	3,		plus		],
+ 			[	asciicircum			]	};
+     key <AE04> {	[	4,		exclam		],
+ 			[	breve				]	};
+     key <AE05> {	[	5,		percent		],
+ 			[	degree				]	};
+     key <AE06> {	[	6,		slash		],
+ 			[	ogonek				]	};
+     key <AE07> {	[	7,		equal		],
+ 			[	grave				]	};
+     key <AE08> {	[	8,		parenleft	],
+ 			[	abovedot			]	};
+     key <AE09> {	[	9,		parenright	],
+ 			[	apostrophe			]	};
+     key <AE10> {	[	odiaeresis,	Odiaeresis	],
+ 			[	doubleacute  			]	};
+     key <AE11> {	[	udiaeresis,	Udiaeresis	],
+ 			[	diaeresis			]	};
+     key <AE12> {	[	oacute,		Oacute		],
+ 			[	cedilla				]	};
+ 
+     key <AD01> {	[	q,		Q		],
+ 			[	backslash			]	};
+     key <AD02> {	[	w,		W		],
+ 			[	bar				]	};
+     key <AD03> {        [       e,              E               ]	};
+     key <AD06> {	[	z,		Z		]	};
+     key <AD08> {        [       i,              I               ],
+                         [       Iacute                          ]       };
+     key <AD11> {	[	odoubleacute,	Odoubleacute	],
+ 			[	division			]	};
+     key <AD12> {	[	uacute,		Uacute		],
+ 			[	multiply			]	};
+ 
+     key <AC02> {	[	s,		S		],
+ 			[	dstroke				]	};
+     key <AC03> {	[	d,		D		],
+ 			[	Dstroke				]	};
+     key <AC04> {	[	f,		F		],
+ 			[	bracketleft			]	};
+     key <AC05> {	[	g,		G		],
+ 			[	bracketright			]	};
+     key <AC07> {        [       j,              J               ],
+                         [       iacute                          ]       };
+     key <AC08> {	[	k,		K		],
+ 			[	lstroke				]	};
+     key <AC09> {	[	l,		L		],
+ 			[	Lstroke				]	};
+     key <AC10> {	[	eacute,		Eacute		],
+ 			[	dollar				]	};
+     key <AC11> {	[	aacute,		Aacute		],
+ 			[	ssharp				]	};
+     key <BKSL> {	[	udoubleacute,	Udoubleacute	],
+ 			[	currency			]	};
+ 
+     key <LSGT> {	[	iacute,		Iacute		],
+ 			[       less				]	};
+     key <AB01> {	[	y,		Y		],
+ 			[	greater				]	};
+     key <AB02> {	[	x,		X		],
+ 			[	numbersign			]	};
+     key <AB03> {	[	c,		C		],
+ 			[	ampersand			]	};
+     key <AB04> {	[	v,		V		],
+ 			[	at				]	};
+     key <AB05> {	[	b,		B		],
+ 			[	braceleft			]	};
+     key <AB06> {	[	n,		N		],
+ 			[	braceright			]	};
+     key <AB07> {        [       m,              M               ],
+                         [       less                            ]       };
+     key <AB08> {	[	comma,		question	],
+ 			[	semicolon			]	};
+     key <AB09> {	[	period,		colon		],
+ 			[	greater				]	};
+     key <AB10> {	[	minus,		underscore	],
+ 			[	asterisk			]	};
+ 
+     key <RALT> {	[	Mode_switch,	Multi_key	]	};
+ 
+     // End alphanumeric section
+ 
+     // begin modifier mappings
+     modifier_map Shift  { Shift_L };
+     modifier_map Lock   { Caps_Lock };
+     modifier_map Control{ Control_L };
+     modifier_map Mod3   { Mode_switch };
+ };
+ 
+ 
+ partial alphanumeric_keys 
+ xkb_symbols "nodeadkeys" {
+ 
+     // modify the default Hungarian layout to not have any dead keys.
+ 
+     include "hu(basic)"
+ };
*** /dev/null	Wed Jun 25 14:44:40 1997
--- xc/programs/xkbcomp/symbols/keypad	Fri Jun 13 06:29:01 1997
***************
*** 0 ****
--- 1,81 ----
+ // $TOG: keypad /main/2 1997/06/13 06:25:08 kaleb $
+ 
+ partial hidden keypad_keys 
+ xkb_symbols "overlay" {
+     include "keypad(overlay1)"
+ };
+ 
+ partial hidden keypad_keys 
+ xkb_symbols "overlay1" {
+ 
+     // Begin "Keypad" section
+ 
+     key  <KP7> {	[  KP_Home	],	overlay1=<KO7>	};
+     key  <KP8> {	[  KP_Up	],	overlay1=<KO8>	};
+     key  <KP9> {	[  KP_Prior	],	overlay1=<KO9>	};
+ 
+     key  <KP4> {	[  KP_Left	],	overlay1=<KO4>	};
+     key  <KP5> {	[  KP_Begin	],	overlay1=<KO5>	};
+     key  <KP6> {	[  KP_Right	],	overlay1=<KO6>	};
+ 
+     key  <KP1> {	[  KP_End	],	overlay1=<KO1>	};
+     key  <KP2> {	[  KP_Down	],	overlay1=<KO2>	};
+     key  <KP3> {	[  KP_Next	],	overlay1=<KO3>	};
+ 
+     key  <KP0> {	[  KP_Insert	],	overlay1=<KO0>	};
+     key <KPDL> {  	[  KP_Delete	],	overlay1=<KODL>	};
+ 
+     key  <KO7> {	[  KP_7	]	};
+     key  <KO8> {	[  KP_8	]	};
+     key  <KO9> {	[  KP_9	]	};
+ 
+     key  <KO4> {	[  KP_4	]	};
+     key  <KO5> {	[  KP_5	]	};
+     key  <KO6> {	[  KP_6	]	};
+ 
+     key  <KO1> {	[  KP_1	]	};
+     key  <KO2> {	[  KP_2	]	};
+     key  <KO3> {	[  KP_3	]	};
+ 
+     key  <KO0> {	[  KP_0	]	};
+     key  <KODL> {  	[  KP_Decimal ]	};
+ 
+     // End "Keypad" section
+ };
+ partial hidden keypad_keys 
+ xkb_symbols "overlay2" {
+ 
+     // Begin "Keypad" section
+ 
+     key  <KP7> {	[  KP_Home	],	overlay2=<KO7>	};
+     key  <KP8> {	[  KP_Up	],	overlay2=<KO8>	};
+     key  <KP9> {	[  KP_Prior	],	overlay2=<KO9>	};
+ 
+     key  <KP4> {	[  KP_Left	],	overlay2=<KO4>	};
+     key  <KP5> {	[  KP_Begin	],	overlay2=<KO5>	};
+     key  <KP6> {	[  KP_Right	],	overlay2=<KO6>	};
+ 
+     key  <KP1> {	[  KP_End	],	overlay2=<KO1>	};
+     key  <KP2> {	[  KP_Down	],	overlay2=<KO2>	};
+     key  <KP3> {	[  KP_Next	],	overlay2=<KO3>	};
+ 
+     key  <KP0> {	[  KP_Insert	],	overlay2=<KO0>	};
+     key <KPDL> {  	[  KP_Delete	],	overlay2=<KODL>	};
+ 
+     key  <KO7> {	[  KP_7	]	};
+     key  <KO8> {	[  KP_8	]	};
+     key  <KO9> {	[  KP_9	]	};
+ 
+     key  <KO4> {	[  KP_4	]	};
+     key  <KO5> {	[  KP_5	]	};
+     key  <KO6> {	[  KP_6	]	};
+ 
+     key  <KO1> {	[  KP_1	]	};
+     key  <KO2> {	[  KP_2	]	};
+     key  <KO3> {	[  KP_3	]	};
+ 
+     key  <KO0> {	[  KP_0	]	};
+     key  <KODL> {  	[  KP_Decimal ]	};
+ 
+     // End "Keypad" section
+ };
*** /dev/null	Wed Jun 25 14:44:41 1997
--- xc/programs/xkbcomp/symbols/lock	Fri Jun 13 06:29:04 1997
***************
*** 0 ****
--- 1,17 ----
+ // $TOG: lock /main/2 1997/06/13 06:25:10 kaleb $
+ 
+ partial hidden modifier_keys
+ xkb_symbols "shift" {
+     key <CAPS> {	[	Shift_Lock		]	};
+     modifier_map Shift { Shift_Lock };
+ };
+ partial hidden modifier_keys
+ xkb_symbols "caps" {
+     key <CAPS> {	[	Caps_Lock		]	};
+     modifier_map Lock { Caps_Lock }
+ };
+ partial hidden modifier_keys
+ xkb_symbols "group" {
+     key <CAPS> {	[	ISO_Next_Group		]	};
+ };
+ 
*** /dev/null	Wed Jun 25 14:44:41 1997
--- xc/programs/xkbcomp/symbols/pc104	Fri Jun 13 06:29:06 1997
***************
*** 0 ****
--- 1,20 ----
+ // $TOG: pc104 /main/2 1997/06/13 06:25:12 kaleb $
+ // Use "Alt_*" for both alt keys, "Meta_*" for both windows keys, and Menu for
+ // the menu key
+ default partial modifier_keys 
+ xkb_symbols "altmeta" {
+     key <LALT> {	[ 	Alt_L		]	};
+     key <LWIN> {	[ 	Meta_L		]	};
+     key <RALT> {	[ 	Alt_R		]	};
+     key <RWIN> {	[ 	Meta_R		]	};
+     key <MENU> {	[ 	Menu		]	};
+ };
+ 
+ // Same as the default, but put "Multi_key" (compose) on the menu key.
+ xkb_symbols "compose" {
+     key <LALT> {	[ 	Alt_L		]	};
+     key <LWIN> {	[ 	Meta_L		]	};
+     key <RALT> {	[ 	Alt_R		]	};
+     key <RWIN> {	[ 	Meta_R		]	};
+     key <MENU> {	[ 	Multi_key	]	};
+ }
*** /dev/null	Wed Jun 25 14:44:42 1997
--- xc/programs/xkbcomp/symbols/sgi/Imakefile	Tue Jun 10 07:05:49 1997
***************
*** 0 ****
--- 1,8 ----
+ XCOMM $TOG: Imakefile /main/1 1997/06/10 06:56:20 kaleb $
+ 
+      DATAFILES = jp
+ 
+ all::
+ 
+ InstallMultiple($(DATAFILES),$(LIBDIR)/xkb/symbols/sgi)
+ DependTarget()
*** /dev/null	Wed Jun 25 14:44:42 1997
--- xc/programs/xkbcomp/symbols/sgi/jp	Tue Jun 10 07:05:52 1997
***************
*** 0 ****
--- 1,46 ----
+ // $TOG: jp /main/1 1997/06/10 06:56:23 kaleb $
+ xkb_symbols "jp106" {
+ 
+     name[group1]="Japan/ASCII";
+ 
+     key <HZTG> {         [ Zenkaku_Hankaku 		    ] };
+     key <AE01> {         [               1,          exclam ] };
+     key <AE02> {         [               2,        quotedbl ] };
+     key <AE03> {         [               3,      numbersign ] };
+     key <AE04> {         [               4,          dollar ] };
+     key <AE05> {         [               5,         percent ] };
+     key <AE06> {         [               6,       ampersand ] };
+     key <AE07> {         [               7,      apostrophe ] };
+     key <AE08> {         [               8,       parenleft ] };
+     key <AE09> {         [               9,      parenright ] };
+     key <AE10> {         [               0,      asciitilde ] };
+     key <AE11> {         [           minus,           equal ] };
+     key <AE12> {         [     asciicircum,         overbar ] };
+     key <AE13> {         [             yen,             bar ] };
+ 
+     // keys <TAB> and <AD01> - <AD10> are identical to US/ASCII keyboard
+     key <AD11> {         [              at,           grave ] };
+     key <AD12> {         [     bracketleft,       braceleft ] };
+ 
+     key <CAPS> {         [      Eisu_Shift,       Caps_Lock ] };
+     // keys <AC01> - <AC09> are identical to US/ASCII keyboard
+     key <AC10> {         [       semicolon,            plus ] };
+     key <AC11> {         [           colon,        asterisk ] };
+     key <AC12> {         [    bracketright,      braceright ] };
+ 
+     // keys <LFSH> and <AB01> - <AB10> are identical to US/ASCII keyboard
+     key <AB11> {         [       backslash,      underscore ] };
+ 
+     key <NFER> {         [        Muhenkan ] };
+     key <XFER> {         [           Kanji ] };
+     key <HKTG> {         [ Hiragana_Katakana ] };
+ };
+ 
+ xkb_symbols "alternate106" {
+     key <AE10> {         [               0,      overbar ] };
+     key <AE12> {         [     asciicircum,      asciitilde] };
+     key <AE13> {         [       backslash,             bar ] };
+     key <AB11> {         [        underbar,      underscore ] };
+     augment "sgi/jp(jp106)"
+ };
+ 
*** xc/include/HPkeysym.h@@/main/0	Mon Jun 19 18:08:05 1995
--- xc/include/HPkeysym.h	Wed Jun 25 08:45:55 1997
***************
*** 0 ****
--- 1,159 ----
+ /* $TOG: HPkeysym.h /main/3 1997/06/25 08:45:56 barstow $ */
+ /*
+ 
+ Copyright (c) 1987  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining
+ a copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to
+ permit persons to whom the Software is furnished to do so, subject to
+ the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall
+ not be used in advertising or otherwise to promote the sale, use or
+ other dealings in this Software without prior written authorization
+ from the X Consortium.
+ 
+ Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted,
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in
+ supporting documentation, and that the names of Hewlett Packard
+ or Digital not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD
+ TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE.  Hewlett-Packard shall not be liable for errors
+ contained herein or direct, indirect, special, incidental or
+ consequential damages in connection with the furnishing,
+ performance, or use of this material.
+ 
+ */
+ 
+ #define hpXK_ClearLine		0x1000FF6F
+ #define hpXK_InsertLine		0x1000FF70
+ #define hpXK_DeleteLine		0x1000FF71
+ #define hpXK_InsertChar		0x1000FF72
+ #define hpXK_DeleteChar		0x1000FF73
+ #define hpXK_BackTab		0x1000FF74
+ #define hpXK_KP_BackTab		0x1000FF75
+ #define hpXK_Modelock1		0x1000FF48
+ #define hpXK_Modelock2		0x1000FF49
+ #define hpXK_Reset		0x1000FF6C
+ #define hpXK_System		0x1000FF6D
+ #define hpXK_User		0x1000FF6E
+ #define hpXK_mute_acute		0x100000A8
+ #define hpXK_mute_grave		0x100000A9
+ #define hpXK_mute_asciicircum	0x100000AA
+ #define hpXK_mute_diaeresis	0x100000AB
+ #define hpXK_mute_asciitilde	0x100000AC
+ #define hpXK_lira		0x100000AF
+ #define hpXK_guilder		0x100000BE
+ #define hpXK_Ydiaeresis		0x100000EE
+ #define hpXK_IO			0x100000EE
+ #define hpXK_longminus		0x100000F6
+ #define hpXK_block		0x100000FC
+ 
+ 
+ #ifndef _OSF_Keysyms
+ #define _OSF_Keysyms
+ 
+ #define osfXK_Copy		0x1004FF02
+ #define osfXK_Cut		0x1004FF03
+ #define osfXK_Paste		0x1004FF04
+ #define osfXK_BackTab		0x1004FF07
+ #define osfXK_BackSpace		0x1004FF08
+ #define osfXK_Clear		0x1004FF0B
+ #define osfXK_Escape		0x1004FF1B
+ #define osfXK_AddMode		0x1004FF31
+ #define osfXK_PrimaryPaste	0x1004FF32
+ #define osfXK_QuickPaste	0x1004FF33
+ #define osfXK_PageLeft		0x1004FF40
+ #define osfXK_PageUp		0x1004FF41
+ #define osfXK_PageDown		0x1004FF42
+ #define osfXK_PageRight		0x1004FF43
+ #define osfXK_Activate		0x1004FF44
+ #define osfXK_MenuBar		0x1004FF45
+ #define osfXK_Left		0x1004FF51
+ #define osfXK_Up		0x1004FF52
+ #define osfXK_Right		0x1004FF53
+ #define osfXK_Down		0x1004FF54
+ #define osfXK_EndLine		0x1004FF57
+ #define osfXK_BeginLine		0x1004FF58
+ #define osfXK_EndData		0x1004FF59
+ #define osfXK_BeginData		0x1004FF5A
+ #define osfXK_PrevMenu		0x1004FF5B
+ #define osfXK_NextMenu		0x1004FF5C
+ #define osfXK_PrevField		0x1004FF5D
+ #define osfXK_NextField		0x1004FF5E
+ #define osfXK_Select		0x1004FF60
+ #define osfXK_Insert		0x1004FF63
+ #define osfXK_Undo		0x1004FF65
+ #define osfXK_Menu		0x1004FF67
+ #define osfXK_Cancel		0x1004FF69
+ #define osfXK_Help		0x1004FF6A
+ #define osfXK_SelectAll		0x1004FF71
+ #define osfXK_DeselectAll	0x1004FF72
+ #define osfXK_Reselect		0x1004FF73
+ #define osfXK_Extend		0x1004FF74
+ #define osfXK_Restore		0x1004FF78
+ #define osfXK_Delete		0x1004FFFF
+ 
+ #endif /* _OSF_Keysyms */
+ 
+ 
+ /**************************************************************
+  * The use of the following macros is deprecated.
+  * They are listed below only for backwards compatibility.
+  */
+ #define XK_Reset                0x1000FF6C
+ #define XK_System               0x1000FF6D
+ #define XK_User                 0x1000FF6E
+ #define XK_ClearLine            0x1000FF6F
+ #define XK_InsertLine           0x1000FF70
+ #define XK_DeleteLine           0x1000FF71
+ #define XK_InsertChar           0x1000FF72
+ #define XK_DeleteChar           0x1000FF73
+ #define XK_BackTab              0x1000FF74
+ #define XK_KP_BackTab           0x1000FF75
+ #define XK_Ext16bit_L           0x1000FF76
+ #define XK_Ext16bit_R           0x1000FF77
+ #define XK_mute_acute           0x100000a8
+ #define XK_mute_grave           0x100000a9
+ #define XK_mute_asciicircum     0x100000aa
+ #define XK_mute_diaeresis       0x100000ab
+ #define XK_mute_asciitilde      0x100000ac
+ #define XK_lira                 0x100000af
+ #define XK_guilder              0x100000be
+ #define XK_Ydiaeresis           0x100000ee
+ #define XK_IO                   0x100000ee
+ #define XK_longminus            0x100000f6
+ #define XK_block                0x100000fc
*** xc/doc/specs/Xserver/fontlib.ms@@/PUBLIC-LATEST	Sun Apr 17 20:05:27 1994
--- xc/doc/specs/Xserver/fontlib.ms	Mon Jun  9 17:54:03 1997
***************
*** 48,54 ****
  .ft P
  .fi
  ..
! .\" $XConsortium $
  .EF 'Font Library Interface'- % -'July 27, 1991'
  .OF 'Font Library Interface'- % -'July 27, 1991'
  .EH ''''
--- 48,54 ----
  .ft P
  .fi
  ..
! .\" $TOG: fontlib.ms /main/5 1997/06/09 17:51:45 barstow $
  .EF 'Font Library Interface'- % -'July 27, 1991'
  .OF 'Font Library Interface'- % -'July 27, 1991'
  .EH ''''
***************
*** 394,396 ****
--- 394,403 ----
  .LP
  This is called from the FPE routine (*close_font), and so should not ever be
  called from the application.
+ .NH 2
+ maxPrivate
+ .LP
+ When initializing a new font structure, maxPrivate should be set to -1
+ so that the FontSetPrivate() macro works properly with an index of 0.
+ Initializing maxPrivate to 0 can cause problems if the server tries to set 
+ something at index 0.
