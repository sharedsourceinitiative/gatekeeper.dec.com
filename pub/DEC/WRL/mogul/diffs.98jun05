*** /wrl/proj/gatekeeper/WRL/mogul/draft-mogul-pps-api-02.txt	Fri May 29 11:01:41 1998
--- newapi.doc	Fri Jun 05 15:17:46 1998
***************
*** 5,11 ****
                                                  Jonathan Stone, Stanford
                                                Poul-Henning Kamp, FreeBSD
                                     Ulrich Windl, Universitaet Regensburg
!                                                              29 May 1998
  
  
     Pulse-Per-Second API for UNIX-like Operating Systems, Version 1.0
--- 5,11 ----
                                                  Jonathan Stone, Stanford
                                                Poul-Henning Kamp, FreeBSD
                                     Ulrich Windl, Universitaet Regensburg
!                                                              5 June 1998
  
  
     Pulse-Per-Second API for UNIX-like Operating Systems, Version 1.0
***************
*** 41,62 ****
  ABSTRACT
  
          RFC1589 describes a UNIX kernel implementation model for
!         high-precision time-keeping.  This is meant for use in
!         conjunction with the Network Time Protocol (NTP, RFC1305),
!         or similar time synchronization protocols.  One aspect of
!         this model is an accurate interface to the high-accuracy,
!         one pulse-per-second (PPS) output typically available from
!         precise time sources (such as a GPS or GOES receiver).
!         RFC1589 did not define an API for managing the PPS
!         facility.  This document specifies such an API.
  
  
  
- 
- 
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 1]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
                             TABLE OF CONTENTS
--- 41,62 ----
  ABSTRACT
  
          RFC1589 describes a UNIX kernel implementation model for
!         high-precision time-keeping.  This model is meant for use
!         in conjunction with the Network Time Protocol (NTP,
!         RFC1305), or similar time synchronization protocols.  One
!         aspect of this model is an accurate interface to the
!         high-accuracy, one pulse-per-second (PPS) output typically
!         available from precise time sources (such as a GPS or GOES
!         receiver).  RFC1589 did not define an API for managing the
!         PPS facility, leaving implementors without a portable means
!         for using PPS sources.  This document specifies such an
!         API.
  
  
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 1]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
                             TABLE OF CONTENTS
***************
*** 68,94 ****
  3 API                                                                  5
       3.1 PPS abstraction                                               5
       3.2 New data structures                                           6
!      3.3 Mode bit definitions                                          7
!      3.4 New functions                                                 9
!           3.4.1 New functions: obtaining PPS sources                   9
!           3.4.2 New functions: setting PPS parameters                 10
!           3.4.3 New functions: access to PPS timestamps               11
!           3.4.4 New functions: disciplining the kernel timebase       12
!           3.4.5 New functions: waiting for an event                   13
!      3.5 Compliance rules                                             14
!      3.6 Example                                                      15
! 4 Security Considerations                                             15
! 5 Acknowledgements                                                    16
! 6 References                                                          16
! 7 Authors' addresses                                                  16
  
! A. Extensions Related APIs                                            17
! A.1 Extension: Parameters for the ``echo'' mechanism                  17
! A.2 Extension: Obtaining information about external clocks            18
! A.3 Extension: Finding a PPS source                                   18
  
! B. Example implementation: PPSDISC Line discipline                    19
! B.1 Example                                                           20
  
  
  1 Introduction
--- 68,96 ----
  3 API                                                                  5
       3.1 PPS abstraction                                               5
       3.2 New data structures                                           6
!      3.3 Mode bit definitions                                          8
!      3.4 New functions                                                10
!           3.4.1 New functions: obtaining PPS sources                  10
!           3.4.2 New functions: setting PPS parameters                 11
!           3.4.3 New functions: access to PPS timestamps               12
!           3.4.4 New functions: disciplining the kernel timebase       13
!           3.4.5 New functions: waiting for an event                   14
!      3.5 Compliance rules                                             15
!           3.5.1 Functions                                             15
!           3.5.2 Mode bits                                             16
!      3.6 Examples                                                     16
! 4 Security Considerations                                             18
! 5 Acknowledgements                                                    18
! 6 References                                                          19
! 7 Authors' addresses                                                  19
  
! A. Extensions Related APIs                                            20
! A.1 Extension: Parameters for the ``echo'' mechanism                  20
! A.2 Extension: Obtaining information about external clocks            20
! A.3 Extension: Finding a PPS source                                   21
  
! B. Example implementation: PPSDISC Line discipline                    22
! B.1 Example                                                           22
  
  
  1 Introduction
***************
*** 108,126 ****
     systems often conform to the ``Single UNIX Specification'' [5],
     sometimes known as POSIX.
  
-    One convenient means to provide a PPS signal to a computer system is
-    to connect that signal to a modem-control pin on a serial-line
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 2]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
     interface to the computer.  The Data Carrier Detect (DCD) pin is
     frequently used for this purpose.  Typically, the time-code output of
     the time source is transmitted to the computer over the same serial
     line.  The computer detects a signal transition on the DCD pin,
!    usually by receiving an interrupt.
  
     Although existing practice has focussed on the use of serial lines
     and DCD transitions, PPS signals might also be delivered by other
--- 110,129 ----
     systems often conform to the ``Single UNIX Specification'' [5],
     sometimes known as POSIX.
  
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 2]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
+    One convenient means to provide a PPS signal to a computer system is
+    to connect that signal to a modem-control pin on a serial-line
     interface to the computer.  The Data Carrier Detect (DCD) pin is
     frequently used for this purpose.  Typically, the time-code output of
     the time source is transmitted to the computer over the same serial
     line.  The computer detects a signal transition on the DCD pin,
!    usually by receiving an interrupt, and records a timestamp as
!    immediately as possible.
  
     Although existing practice has focussed on the use of serial lines
     and DCD transitions, PPS signals might also be delivered by other
***************
*** 132,138 ****
     record a high-resolution timestamp as soon as possible after it
     detects a PPS signal transition (usually indicated by an interrupt).
     This timestamp can then be made available, with less stringent delay
!    constraints, to timekeeping software.  The software can compare the
     captured timestamp to the received time-code to accurately determine
     the absolute offset between the system clock and the precise time
     source.
--- 135,141 ----
     record a high-resolution timestamp as soon as possible after it
     detects a PPS signal transition (usually indicated by an interrupt).
     This timestamp can then be made available, with less stringent delay
!    constraints, to ztimekeeping software.  The software can compare the
     captured timestamp to the received time-code to accurately determine
     the absolute offset between the system clock and the precise time
     source.
***************
*** 139,152 ****
  
     The operating system may also deliver the PPS event immediately to a
     procedure used to discipline its internal timebase, such as the
!    hardpps() procedure described in RFC1589.
  
     The API specified in this document allows for one or more signal
     sources attached to a computer system to provide PPS inputs, at the
     option of user-level software.  User-level software may obtain
!    DCD-transition timestamps for any of these PPS sources.  User-level
!    software may optionally specify that at most one of these PPS sources
!    be used to discipline the system's internal timebase.
  
     Although the primary purpose of this API is for capturing true
     pulse-per-second events, the API may also be used for accurately
--- 142,155 ----
  
     The operating system may also deliver the PPS event immediately to a
     procedure used to discipline its internal timebase, such as the
!    ``hardpps()'' procedure described in RFC1589.
  
     The API specified in this document allows for one or more signal
     sources attached to a computer system to provide PPS inputs, at the
     option of user-level software.  User-level software may obtain
!    signal-transition timestamps for any of these PPS sources.
!    User-level software may optionally specify that at most one of these
!    PPS sources be used to discipline the system's internal timebase.
  
     Although the primary purpose of this API is for capturing true
     pulse-per-second events, the API may also be used for accurately
***************
*** 164,178 ****
     thousand per second.  However, since in most implementations the
     timestamping function will be implemented as a processor interrupt at
     a relatively high priority, it is prudent to limit the rate of such
-    events.  This may be done either by mechanisms in the hardware that
-    generates the signals, or by the operating system.
  
- 
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 3]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
  2 Data types for representing timestamps
  
     Computer systems use various representations of time.  Because this
--- 167,182 ----
     thousand per second.  However, since in most implementations the
     timestamping function will be implemented as a processor interrupt at
     a relatively high priority, it is prudent to limit the rate of such
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 3]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
+    events.  This may be done either by mechanisms in the hardware that
+    generates the signals, or by the operating system.
+ 
+ 
  2 Data types for representing timestamps
  
     Computer systems use various representations of time.  Because this
***************
*** 203,209 ****
     However, most computer systems cannot measure time to this resolution
     (this represents a clock rate of 5 GHz).  The POSIX gettimeofday()
     function returns a ``struct timeval'' value, with a resolution of 1
!    microsecond.  The POSIX clock_settime() function returns a ``struct
     timespec'' value, with a resolution of 1 nanosecond.
  
     This API uses the ``struct timespec'' representation, since in a
--- 207,213 ----
     However, most computer systems cannot measure time to this resolution
     (this represents a clock rate of 5 GHz).  The POSIX gettimeofday()
     function returns a ``struct timeval'' value, with a resolution of 1
!    microsecond.  The POSIX clock_gettime() function returns a ``struct
     timespec'' value, with a resolution of 1 nanosecond.
  
     This API uses the ``struct timespec'' representation, since in a
***************
*** 220,235 ****
     Some people would prefer the use of TAI, which is identical to UTC
     except that it does not correct for leap seconds.  Their preference
     for TAI stems from the difficulty of computing precise time
-    differences when leap seconds are involved, especially when using
-    times in the future (for which the exact number of leap seconds is,
-    in general, unknowable).
  
- 
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 4]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
     However, POSIX and NTP both use UTC, albeit with different base
     dates.  Given that support for TAI would, in general, require other
     changes to the POSIX specification, This API uses the POSIX base date
--- 224,239 ----
     Some people would prefer the use of TAI, which is identical to UTC
     except that it does not correct for leap seconds.  Their preference
     for TAI stems from the difficulty of computing precise time
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 4]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
+    differences when leap seconds are involved, especially when using
+    times in the future (for which the exact number of leap seconds is,
+    in general, unknowable).
+ 
     However, POSIX and NTP both use UTC, albeit with different base
     dates.  Given that support for TAI would, in general, require other
     changes to the POSIX specification, This API uses the POSIX base date
***************
*** 262,295 ****
  3.1 PPS abstraction
     A PPS signal consists of a series of pulses, each with an
     ``asserted'' (logical true) phase, and a ``clear'' (logical false)
!    phase.  The two phases may be of different lengths, but the
!    expectation is that the lengths will repeat exactly from cycle to
!    cycle.  The API may capture an ``assert timestamp'' at the moment of
!    the transition into the asserted phase, and a ``clear timestamp'' at
!    the moment of the transition into the clear phase.
  
     The specific assignment of the logical values ``true'' and ``false''
     with specific voltages of a PPS signal, if applicable, is outside the
!    scope of this specification.
  
     The API supports the direct provision of PPS events (and timestamps)
!    to a kernel function known as ``hardpps()'' (although the API does
!    not require the kernel implementation to use that symbol internally).
  
-    The API optionally supports an ``echo'' feature, in which the
-    incoming PPS signal is reflected through software, after the capture
-    of the corresponding timestamp, to an output signal pin (whose
-    definition is not part of this specification).  This feature may be
-    used to determine an upper bound on the actual delay between the
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 5]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
!    edges of the PPS signal and the capture of the timestamps; such
!    information may be useful in precise calibration of the system.
  
  3.2 New data structures
     The data structure declarations and symbol definitions for this API
     will appear in the header file <timepps.h>.
--- 266,314 ----
  3.1 PPS abstraction
     A PPS signal consists of a series of pulses, each with an
     ``asserted'' (logical true) phase, and a ``clear'' (logical false)
!    phase.  The two phases may be of different lengths.  The API may
!    capture an ``assert timestamp'' at the moment of the transition into
!    the asserted phase, and a ``clear timestamp'' at the moment of the
!    transition into the clear phase.
  
     The specific assignment of the logical values ``true'' and ``false''
     with specific voltages of a PPS signal, if applicable, is outside the
!    scope of this specification.  Implementators of PPS sources SHOULD
!    document these assignments.
  
     The API supports the direct provision of PPS events (and timestamps)
!    to a kernel function known as ``hardpps()'', as described in
!    RFC1589 [4].  (although the API does not require the kernel
!    implementation to use that symbol internally).
  
  
  Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 5]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
!    The API optionally supports an ``echo'' feature, in which events on
!    the incoming PPS signal may be reflected through software, after the
!    capture of the corresponding timestamp, to an output signal pin.
!    This feature may be used to determine an upper bound on the actual
!    delay between the edges of the PPS signal and the capture of the
!    timestamps; such information may be useful in precise calibration of
!    the system.
  
+    The designation of an output pin for the echo signal, and sense and
+    shape of the output transition, is outside the scope of this
+    specification, but SHOULD be documented for each implementation.  The
+    output pin MAY also undergo transitions at other times besides those
+    caused by PPS input events.
+ 
+       ---------
+       Note: this allows an implementation of the echo feature to
+       generate an output pulse per input pulse, or an output edge per
+       input pulse, or an output pulse per input edge. It also allows
+       the same signal pin to be used for several purposes
+       simultaneously.
+       ---------
+ 
  3.2 New data structures
     The data structure declarations and symbol definitions for this API
     will appear in the header file <timepps.h>.
***************
*** 318,325 ****
--- 337,352 ----
        typedef struct {
            pps_seq_t   assert_sequence;        /* assert event seq # */
            pps_seq_t   clear_sequence;         /* clear event seq # */
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 6]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
            struct timespec     assert_timestamp;
            struct timespec     clear_timestamp;
+           int         current_mode;           /* current mode bits */
        } pps_info_t;
  
        typedef struct {
***************
*** 335,349 ****
     aspect of the specification.  Each timestamp field represents the
     value of the operating system's internal timebase when the
     timestamped event occurred, or as close as possible to that time
!    (perhaps with the addition of a specified offset).
  
- 
- 
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 6]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     The assert_sequence number increases once per captured assert
     timestamp.  Its initial value is undefined.  If incremented past the
     largest unsigned long value, the next value is zero.  The
--- 362,371 ----
     aspect of the specification.  Each timestamp field represents the
     value of the operating system's internal timebase when the
     timestamped event occurred, or as close as possible to that time
!    (perhaps with the addition of a specified offset).  The current_mode
!    field contains the value of the mode bits (see section 3.3) at time
!    of the most recent transition for this PPS source.
  
     The assert_sequence number increases once per captured assert
     timestamp.  Its initial value is undefined.  If incremented past the
     largest unsigned long value, the next value is zero.  The
***************
*** 362,377 ****
        excessive event rate, or to detect that an event has failed to
        occur between two calls to the time_pps_fetch() function
        (defined later).
        ---------
  
     As an OPTIONAL feature of the API, the implementation MAY support
     adding offsets to the timestamps that are captured.  (Values of type
!    ``struct timestamp'' can represent negative offsets.)  The
!    assert_offset field specifies a value to be added to generate a
!    captured assert_timestamp.  The clear_offset field specifies a value
!    to be added to generate a captured clear_timestamp.
  
  3.3 Mode bit definitions
     The meaning of the bits in the mode field of the pps_params_t type
     are:
  
--- 384,417 ----
        excessive event rate, or to detect that an event has failed to
        occur between two calls to the time_pps_fetch() function
        (defined later).
+ 
+       In order to obtain an uninterrupted series of sequence numbers
+       (and hence of event timestamps), it may be necessary to sample
+       the pps_info_t values at a rate somewhat faster than the
+       underlying event rate.  For example, an application interested
+       in both assert and clear timestamps may need to sample at least
+       twice per second.  Proper use of the sequence numbers allows an
+       application to discover if it has missed any event timestamps
+       due to an insufficient sampling rate.
        ---------
  
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 7]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
     As an OPTIONAL feature of the API, the implementation MAY support
     adding offsets to the timestamps that are captured.  (Values of type
!    ``struct timespec'' can represent negative offsets.)  The
!    assert_offset field of a pps_params_t value specifies a value to be
!    added to generate a captured assert_timestamp.  The clear_offset of a
!    pps_params_t value field specifies a value to be added to generate a
!    captured clear_timestamp.
  
  3.3 Mode bit definitions
+    A set of mode bits is associated with each PPS source.
+ 
     The meaning of the bits in the mode field of the pps_params_t type
     are:
  
***************
*** 385,393 ****
        #define PPS_HARDPPSONASSERT     0x04
        #define PPS_HARDPPSONCLEAR      0x08
  
!       #define PPS_ECHO                0x40
!       #define PPS_ECHOINVERT          0x80
  
     whose meanings are:
  
     PPS_CAPTUREASSERT
--- 425,435 ----
        #define PPS_HARDPPSONASSERT     0x04
        #define PPS_HARDPPSONCLEAR      0x08
  
!       #define PPS_ECHOASSERT          0x40
!       #define PPS_ECHOCLEAR           0x80
  
+       #define PPS_CANWAIT             0x100
+ 
     whose meanings are:
  
     PPS_CAPTUREASSERT
***************
*** 394,406 ****
                     If this bit is set, the assert timestamp for the
                     associated PPS source will be captured.
  
- 
- 
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 7]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     PPS_CAPTURECLEAR
                     If this bit is set, the clear timestamp for the
                     associated PPS source will be captured.
--- 436,441 ----
***************
*** 417,422 ****
--- 452,463 ----
  
     PPS_OFFSETCLEAR If set, the clear_offset value is added to the
                     current value of the operating system's internal
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 8]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
                     timebase in order to generate the captured
                     clear_timestamp.  Has no meaning if the
                     PPS_CAPTURECLEAR mode bit is clear.
***************
*** 431,446 ****
                     be communicated to the operating system module that
                     disciplines the system's internal timebase.
  
!    PPS_ECHO        If set, the state of the PPS input signal is
!                    replicated on an output signal pin, but only after
!                    the capture of the requested timestamp (if any).
  
!    PPS_ECHOINVERT  If set, the inverse of the state of the PPS input
!                    signal is replicated on an output signal pin, but
!                    only after the capture of the requested timestamp (if
!                    any).
  
!    If neither PPS_CAPTUREASSERT nor PPS_CAPTURECLEAR is set, no
     timestamp will be available via the API.  If neither
     PPS_HARDPPSONASSERT nor PPS_HARDPPSONCLEAR is set, no calls will be
     made to discipline the operating system's internal timebase.  The
--- 472,498 ----
                     be communicated to the operating system module that
                     disciplines the system's internal timebase.
  
!    PPS_ECHOASSERT   If set, after the capture of an assert timestamp,
!                    the implementation generates a signal transition as
!                    rapidly as possible on an output signal pin.  This
!                    MUST NOT affect the delay between the PPS source's
!                    transition to the asserted phase and the capture of
!                    the assert timestamp.
  
!    PPS_ECHOCLEAR    If set, after the capture of a clear timestamp, the
!                    implementation generates a signal transition as
!                    rapidly as possible on an output signal pin.  This
!                    MUST NOT affect the delay between the PPS source's
!                    transition to the clear phase and the capture of the
!                    clear timestamp.
  
!    PPS_CANWAIT     If set, the time_pps_wait() function (see section
!                    3.4.5) is available for use with this PPS source.
!                    Otherwise, the time_pps_wait() function is a no-op.
!                    Note: this mode bit cannot be set by an application;
!                    it can only be read.
! 
!    If neither PPS_CAPTUREASSERT nor PPS_CAPTURECLEAR is set, no valid
     timestamp will be available via the API.  If neither
     PPS_HARDPPSONASSERT nor PPS_HARDPPSONCLEAR is set, no calls will be
     made to discipline the operating system's internal timebase.  The
***************
*** 453,469 ****
        1. They may be applied to at most one signal source at any
           given time.
  
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 8]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
        2. They may only be set by a process with sufficient
           privileges to modify the system's internal timebase.  (On
           UNIX systems, such modification is normally done using
           settimeofday() and/or adjtime(), and is restricted to
           users with superuser privilege.)
  
     The operating system may implement all of these mode bits, or just a
     subset of them.  If an attempt is made to set an unsupported mode
     bit, the API will return an error.
--- 505,520 ----
        1. They may be applied to at most one signal source at any
           given time.
  
        2. They may only be set by a process with sufficient
           privileges to modify the system's internal timebase.  (On
           UNIX systems, such modification is normally done using
           settimeofday() and/or adjtime(), and is restricted to
           users with superuser privilege.)
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 9]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
+ 
     The operating system may implement all of these mode bits, or just a
     subset of them.  If an attempt is made to set an unsupported mode
     bit, the API will return an error.
***************
*** 478,488 ****
     ppshandle       A variable of type ``pps_handle_t'', as defined in
                     section 3.2.
  
!    ppsinfobuf      A record of type ``struct pps_info_t'', as defined in
                     section 3.2.
  
!    ppsparams       A record of type ``struct pps_params_t'', as defined
!                    in section 3.2.
  
  3.4.1 New functions: obtaining PPS sources
     The API includes a functions to create and destroy PPS source
--- 529,539 ----
     ppshandle       A variable of type ``pps_handle_t'', as defined in
                     section 3.2.
  
!    ppsinfobuf      A record of type ``pps_info_t'', as defined in
                     section 3.2.
  
!    ppsparams       A record of type ``pps_params_t'', as defined in
!                    section 3.2.
  
  3.4.1 New functions: obtaining PPS sources
     The API includes a functions to create and destroy PPS source
***************
*** 508,524 ****
     configuration.  One typical case is a serial line, whose DCD pin is
     connected to a source of PPS events.
  
  
! 
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                    [Page 9]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
-    The time_pps_destroy() function makes the PPS handle unusable, and
-    frees any storage that might have been allocated for it.  It does not
-    close the associated file descriptor.
- 
        ---------
        Note: On operating systems that do not follow UNIX conventions
        for representing an accessible PPS source as an integer file
--- 559,577 ----
     configuration.  One typical case is a serial line, whose DCD pin is
     connected to a source of PPS events.
  
+    The time_pps_destroy() function makes the PPS handle unusable, and
+    frees any storage that might have been allocated for it.  It does not
+    close the associated file descriptor, nor does it change any of the
+    parameter settings for the PPS source.  If, for example, the
+    application wishes to disable the use of this PPS source for
+    disciplining the system's internal timebase, it must do so using
+    time_pps_setparams() before calling time_pps_destroy().
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 10]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
        ---------
        Note: On operating systems that do not follow UNIX conventions
        for representing an accessible PPS source as an integer file
***************
*** 564,577 ****
        int time_pps_getcap(pps_handle_t handle, int *mode);
  
  
- 
- 
- 
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 10]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     DESCRIPTION
  
     An application may use time_pps_setparams() to set the parameters
--- 617,622 ----
***************
*** 578,583 ****
--- 623,634 ----
     (mode bits and timestamp offsets) for a PPS source.  The pps_params_t
     type is defined in section 3.2; mode bits are defined in section 3.3.
     An application may use time_pps_getparams() to discover the current
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 11]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
     settings of the PPS parameters.  An application that needs to change
     only a subset of the existing parameters must first call
     time_pps_getparams() to obtain the current parameter values, then set
***************
*** 586,593 ****
     An application wishing to discover which mode bits it may set, with
     its current effective user ID, may call time_pps_getcap().  This
     function returns the set of mode bits that may be set by the
!    application without generating an EINVAL or EPERM error.  It does not
!    return the current values for the mode bits.
  
  
     RETURN VALUES
--- 637,648 ----
     An application wishing to discover which mode bits it may set, with
     its current effective user ID, may call time_pps_getcap().  This
     function returns the set of mode bits that may be set by the
!    application, without generating an EINVAL or EPERM error, for the
!    specified PPS source handle.  It does not return the current values
!    for the mode bits.  The mode bits returned by time_pps_getcap() for
!    distinct PPS handles may differ, reflecting the specific capabilities
!    of the underlying hardware connection to the PPS source, or of the
!    source itself.
  
  
     RETURN VALUES
***************
*** 624,638 ****
     timestamps.
  
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 11]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
     SYNOPSIS
  
        int time_pps_fetch(pps_handle_t handle,
!                               struct ppsinfo *ppsinfobuf);
  
  
     DESCRIPTION
--- 679,695 ----
     timestamps.
  
  
! 
! 
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 12]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
     SYNOPSIS
  
        int time_pps_fetch(pps_handle_t handle,
!                               pps_info_t *ppsinfobuf);
  
  
     DESCRIPTION
***************
*** 641,647 ****
     timestamps captured for the PPS source specified by the handle
     parameter.
  
!    The result is left in the ppsinfobuf parameter, whose fields are
     defined in section 3.2.
  
     If this function is invoked before the system has captured a
--- 698,704 ----
     timestamps captured for the PPS source specified by the handle
     parameter.
  
!    The result is stored in the ppsinfobuf parameter, whose fields are
     defined in section 3.2.
  
     If this function is invoked before the system has captured a
***************
*** 681,689 ****
        otherwise inappropriately configured, use of this feature may
        result in seriously incorrect timekeeping for the entire
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 12]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
        system.  For best results, the 1-PPS signal should have much
--- 738,746 ----
        otherwise inappropriately configured, use of this feature may
        result in seriously incorrect timekeeping for the entire
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 13]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
        system.  For best results, the 1-PPS signal should have much
***************
*** 698,707 ****
  
  3.4.5 New functions: waiting for an event
     The API includes a function that allows an application to block until
!    the next timestamp is captured.
  
     This is an OPTIONAL feature of the API, and may be implemented as a
!    stub that always returns an error.
  
  
     SYNOPSIS
--- 755,767 ----
  
  3.4.5 New functions: waiting for an event
     The API includes a function that allows an application to block until
!    the next timestamp is captured.  (It does not directly support the
!    use of the select() system call to wait for PPS events.)
  
     This is an OPTIONAL feature of the API, and may be implemented as a
!    stub that always returns zero.  An application can determine whether
!    the feature is implemented by using time_pps_getcap() to see if the
!    PPS_CANWAIT mode bit is set.
  
  
     SYNOPSIS
***************
*** 708,714 ****
  
        int time_pps_wait(pps_handle_t handle,
                                const struct timespec *timeout,
!                               struct ppsinfo *ppsinfobuf);
  
  
     DESCRIPTION
--- 768,774 ----
  
        int time_pps_wait(pps_handle_t handle,
                                const struct timespec *timeout,
!                               pps_info_t *ppsinfobuf);
  
  
     DESCRIPTION
***************
*** 727,748 ****
     function, had it been called immediately after the timestamp was
     captured.
  
  
-    RETURN VALUES
  
-    On successful completion, the time_pps_wait() function returns 0.
-    Otherwise, a value of -1 is returned and errno is set to indicate the
-    error.
  
  
  
  
! 
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 13]
  
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
     ERRORS
  
     If the time_pps_wait() function fails, errno may be set to one of the
--- 787,812 ----
     function, had it been called immediately after the timestamp was
     captured.
  
+    If the PPS_CANWAIT mode bit is clear, then this function is a no-op,
+    and always returns 0.
  
  
  
  
  
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 14]
  
! Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
+    RETURN VALUES
+ 
+    On successful completion, the time_pps_wait() function returns 0.
+    Otherwise, a value of -1 is returned and errno is set to indicate the
+    error.
+ 
+ 
     ERRORS
  
     If the time_pps_wait() function fails, errno may be set to one of the
***************
*** 759,764 ****
--- 823,832 ----
  
     [ETIMEDOUT]     The timeout duration has expired.
  
+    [EINTR]
+    A signal was delivered before the time limit specified by the timeout
+    parameter expired and before a timestamp has been captured.
+ 
  3.5 Compliance rules
     The key words "MUST", "MUST NOT", "REQUIRED","SHOULD", SHOULD NOT",
     "MAY", and "OPTIONAL" in this document are to be interpreted as
***************
*** 767,808 ****
     Some features of this specification are OPTIONAL, but others are
     REQUIRED.
  
!       - An implementation MUST provide these functions:
!            * time_pps_create()
!            * time_pps_destroy()
!            * time_pps_setparams()
!            * time_pps_getparams()
!            * time_pps_getcap()
!            * time_pps_fetch()
  
!       - An implementation MAY provide these optional functions:
!            * time_pps_wait()
  
-       - An implementation MUST support at least one of these mode
-         bits:
-            * PPS_CAPTUREASSERT
-            * PPS_CAPTURECLEAR
  
-         and MAY support both of them.
  
-       - An implementation MAY support these mode bits:
-            * PPS_OFFSETASSERT, if it supports PPS_CAPTUREASSERT
-            * PPS_OFFSETCLEAR, if it supports PPS_CAPTURECLEAR
-            * PPS_HARDPPSONASSERT, if it supports PPS_CAPTUREASSERT
-            * PPS_HARDPPSONCLEAR, if it supports PPS_CAPTURECLEAR
-            * PPS_ECHO
-            * PPS_ECHOINVERT
  
  
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 14]
! 
! Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
  
  
! 3.6 Example
!    A typical use of this API might be:
  
        int fd;
        pps_handle_t handle;
        pps_params_t params;
--- 835,887 ----
     Some features of this specification are OPTIONAL, but others are
     REQUIRED.
  
! 3.5.1 Functions
!    An implementation MUST provide these functions:
!       - time_pps_create()
!       - time_pps_destroy()
!       - time_pps_setparams()
!       - time_pps_getparams()
!       - time_pps_getcap()
!       - time_pps_fetch()
  
!    An implementation MUST provide these functions, but they may be
!    implementation as ``no-operation'' functions, possibly on a
!    per-source basis:
!       - time_pps_wait()
  
  
  
  
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 15]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
  
  
! 3.5.2 Mode bits
!    An implementation MUST support at least one of these mode bits for
!    each PPS source:
!       - PPS_CAPTUREASSERT
!       - PPS_CAPTURECLEAR
!    and MAY support both of them.  If an implementation supports both of
!    these bits for a PPS source, it MUST allow them to be set
!    simultaneously.
  
+    An implementation MAY support these mode bits:
+       - PPS_HARDPPSONASSERT
+       - PPS_HARDPPSONCLEAR
+       - PPS_ECHO
+       - PPS_ECHOINVERT
+       - PPS_OFFSETASSERT
+       - PPS_OFFSETCLEAR
  
!    An implementation that supports PPS_HARDPPSONASSERT for a PPS source
!    MUST support PPS_OFFSETASSERT for that PPS source. An implementation
!    that supports PPS_HARDPPSONCLEAR for a PPS source MUST support
!    PS_OFFSETCLEAR for that PPS source.
  
+ 3.6 Examples
+    A very simple use of this API might be:
+ 
        int fd;
        pps_handle_t handle;
        pps_params_t params;
***************
*** 830,843 ****
     Also note that, on a system that supports time_pps_wait(), the
     function of these lines:
  
            sleep(1);
            time_pps_fetch(handle, &infobuf);
  
     might be more reliably accomplished using:
  
!           time_pps_wait(handle, NULL, &infobuf);
  
  
  4 Security Considerations
  
     This API gives applications three capabilities:
--- 909,988 ----
     Also note that, on a system that supports time_pps_wait(), the
     function of these lines:
  
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 16]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
            sleep(1);
            time_pps_fetch(handle, &infobuf);
  
     might be more reliably accomplished using:
  
!           timeout.tv_sec = 100;
!           timeout.tv_nsec = 0;
!           time_pps_wait(handle, &timeout, &infobuf);
  
+    The (arbitrary) timeout value is used to protect against the
+    possibility that another application might disable PPS timestamps, or
+    that the hardware generating the timestamps might fail.
  
+    A slightly more elaborate use of this API might be:
+ 
+       int fd;
+       pps_handle_t handle;
+       pps_params_t params;
+       pps_info_t infobuf;
+       int avail_mode;
+ 
+       /* Open a file descriptor and enable PPS on rising edges */
+       fd = open(PPSfilename, O_RDONLY, 0);
+       time_pps_create(fd, &handle);
+ 
+       /*
+        * Find out what features are supported
+        */
+       time_pps_getcap(handle, &avail_mode);
+       if ((avail_mode & PPS_CAPTUREASSERT) == 0) {
+           fprintf(stderr, "%s cannot CAPTUREASSERT\n", PPSfilename);
+           exit(1);
+       }
+ 
+       /*
+        * Capture assert timestamps, and
+        *   compensate for a 675 nsec propagation delay
+        */
+       params.assert_offset.tv_sec = 0;
+       params.assert_offset.tv_nsec = 675;
+       params.mode = PPS_CAPTUREASSERT | PPS_OFFSETASSERT;
+ 
+       time_pps_setparams(handle, &params);
+ 
+       /* loop, printing the most recent timestamp every second or so */
+       while (1) {
+           if (avail_mode & PPS_CANWAIT) {
+               time_pps_wait(handle, NULL, &infobuf);
+           } else {
+               sleep(1);
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 17]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
+               time_pps_fetch(handle, &infobuf);
+           }
+           printf("Assert timestamp: %d.%09d, sequence: %ld\n",
+                       infobuf.assert_timestamp.tv_sec,
+                       infobuf.assert_timestamp.tv_nsec,
+                       infobuf.assert_sequence);
+       }
+ 
+    Again, most of the necessary error-checking has been omitted from
+    this example.
+ 
+ 
  4 Security Considerations
  
     This API gives applications three capabilities:
***************
*** 852,870 ****
     cause a slight increase in interrupt latency and interrupt-handling
     overhead.
  
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 15]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     The second capability might be useful in implementing certain kinds
     of covert communication channels.
  
     In most cases, neither of these first two issues is a significant
!    security threat.  The system administrator may prevent applications
!    from using this API by simply using the traditional UNIX file
!    protection facility to limit access to the relevant special files, so
!    the risk inherent in providing the API is minimal.
  
     The final capability is reserved to highly privileged users.  In UNIX
     systems, this means those with superuser privilege.  Such users can
--- 997,1009 ----
     cause a slight increase in interrupt latency and interrupt-handling
     overhead.
  
     The second capability might be useful in implementing certain kinds
     of covert communication channels.
  
     In most cases, neither of these first two issues is a significant
!    security threat, because the traditional UNIX file protection
!    facility may be used to to limit access to the relevant special
!    files.  Provision of the PPS API adds minimal additional risk.
  
     The final capability is reserved to highly privileged users.  In UNIX
     systems, this means those with superuser privilege.  Such users can
***************
*** 882,887 ****
--- 1021,1033 ----
     the drafting of this document.
  
  
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 18]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
  6 References
  
     1.  Scott Bradner.  Key words for use in RFCs to Indicate Requirement
***************
*** 908,919 ****
     Western Research Laboratory
     Digital Equipment Corporation
     250 University Avenue
- 
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 16]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     Palo Alto, California, 94305, U.S.A.
     Email: mogul@wrl.dec.com
     Phone: 1 650 617 3304 (email preferred)
--- 1054,1059 ----
***************
*** 932,942 ****
     Email: Jan.Brittenson@Eng.Sun.COM
  
     Jonathan Stone
!    Stanford University
!    Email: jonathan@DSG.Stanford.EDU
  
     Poul-Henning Kamp
     The FreeBSD Project
     Valbygaardsvej 8
     DK-4200 Slagelse
     Denmark
--- 1072,1090 ----
     Email: Jan.Brittenson@Eng.Sun.COM
  
     Jonathan Stone
!    Stanford Distributed Systems Group
!    Stanford, CA 94305
!    Phone: (650) 723-2513
!    Email: jonathan@dsg.stanford.edu
  
     Poul-Henning Kamp
     The FreeBSD Project
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 19]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
     Valbygaardsvej 8
     DK-4200 Slagelse
     Denmark
***************
*** 966,976 ****
     It might be useful to extend this API to provide either or both of
     these features:
  
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 17]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
        - A means by which the application can discover which output
          pin is echoing the input pin.
  
--- 1114,1119 ----
***************
*** 992,997 ****
--- 1135,1147 ----
        - Clock manufacturer, model number, and revision level
        - Whether the clock is synchronized to an absolute standard
        - For synchronized clocks,
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 20]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
             * The specific standard
             * The accuracy of the standard
             * The path used (direct connection, shortwave, longwave,
***************
*** 1023,1033 ****
     application to discover the PPS source (or sources) connected to a
     system, it might be more complex than necessary.
  
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 18]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
     A simpler approach would be to support a single function that
     provides the identity of one or more PPS sources.
  
--- 1173,1178 ----
***************
*** 1047,1052 ****
--- 1192,1204 ----
     version, etc., which could then be used by the application to control
     its behavior.
  
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 21]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
     This function might simply read the Nth line from a simple database,
     containing lines such as:
  
***************
*** 1078,1093 ****
        #define PPSFETCH      _IOR('t', 75, pps_info_t)
        #define PPSSETPARAM   _IOW('t', 76, pps_params_t)
        #define PPSGETPARAM   _IOR('t', 77, pps_params_t)
  
  
- Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 19]
- 
- Internet-Draft            Pulse-Per-Second API         29 May 1998 11:01
- 
- 
-       #define PPSGETCAP     _IOR('t', 78, pps_params_t)
- 
- 
  B.1 Example
  
     A typical use might be:
--- 1230,1238 ----
        #define PPSFETCH      _IOR('t', 75, pps_info_t)
        #define PPSSETPARAM   _IOW('t', 76, pps_params_t)
        #define PPSGETPARAM   _IOR('t', 77, pps_params_t)
+       #define PPSGETCAP     _IOR('t', 78, int)
  
  
  B.1 Example
  
     A typical use might be:
***************
*** 1104,1109 ****
--- 1249,1261 ----
         */
        ioctl(fd, PPSGETCAP, &params);
        if ((params.mode & PPS_CAPTUREASSERT) == 0 ||
+ 
+ 
+ Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 22]
+ 
+ Internet-Draft            Pulse-Per-Second API         5 June 1998 15:17
+ 
+ 
                (params.mode & PPS_HARDPPSONASSERT) == 0) {
            fprintf(stderr, "PPS source is not suitable\n");
            exit(1);
***************
*** 1137,1140 ****
  
  
  
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 20]
--- 1289,1311 ----
  
  
  
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! Mogul, Mills, Brittenson, Stone, Kamp, Windl                   [Page 23]
